<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MARKSZのBlog</title>
  
  <subtitle>Do what you love,Love what you do</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://molunerfinn.com/"/>
  <updated>2018-04-27T08:26:51.717Z</updated>
  <id>https://molunerfinn.com/</id>
  
  <author>
    <name>Molunerfinn</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Electron-vue开发实战4——通过CI发布以及更新的方式</title>
    <link href="https://molunerfinn.com/electron-vue-5/"/>
    <id>https://molunerfinn.com/electron-vue-5/</id>
    <published>2018-04-24T14:11:00.000Z</published>
    <updated>2018-04-27T08:26:51.717Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间，我用<a href="https://github.com/SimulatedGREG/electron-vue" target="_blank" rel="noopener">electron-vue</a>开发了一款跨平台（目前支持Mac和Windows）的免费开源的图床上传应用——<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a>，在开发过程中踩了不少的坑，不仅来自应用的业务逻辑本身，也来自electron本身。在开发这个应用过程中，我学了不少的东西。因为我也是从0开始学习electron，所以很多经历应该也能给初学、想学electron开发的同学们一些启发和指示。故而写一份Electron的开发实战经历，用最贴近实际工程项目开发的角度来阐述。希望能帮助到大家。</p><p>预计将会从几篇<a href="https://molunerfinn.com/tags/Electron-vue/">系列文章</a>或方面来展开：</p><ol><li><a href="https://molunerfinn.com/electron-vue-1/">electron-vue入门</a></li><li><a href="https://molunerfinn.com/electron-vue-2/">Main进程和Renderer进程的简单开发</a></li><li><a href="https://molunerfinn.com/electron-vue-3/">引入基于Lodash的JSON database——lowdb</a></li><li><a href="https://molunerfinn.com/electron-vue-4/">跨平台的一些兼容措施</a></li><li><a href="https://molunerfinn.com/electron-vue-5/">通过CI发布以及更新的方式</a></li><li>…（想到再写）</li></ol><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p><code>PicGo</code>是采用<code>electron-vue</code>开发的，所以如果你会<code>vue</code>，那么跟着一起来学习将会比较快。如果你的技术栈是其他的诸如<code>react</code>、<code>angular</code>，那么纯按照本教程虽然在render端（可以理解为页面）的构建可能学习到的东西不多，不过在main端（electron的主进程）应该还是能学习到相应的知识的。</p><p>如果之前的文章没阅读的朋友可以先从<a href="https://molunerfinn.com/tags/Electron-vue/">之前的文章</a>跟着看。</p><a id="more"></a><h2 id="LOGO的准备"><a href="#LOGO的准备" class="headerlink" title="LOGO的准备"></a>LOGO的准备</h2><p>经过前面几篇文章的实战，我相信大家已经对于构建一个基本的electron应用没有太多的问题了。本文主要阐述一下如何让我们的应用通过CI系统来自动帮我们构建应用，然后发布给用户使用。以及之后如果有更新，要如何通知用户更新。</p><p>当然，在此之前，我们还需要做一件事：给你应用加上好看的LOGO。LOGO的设计和制作不在本文的设计范围内。为了我们的应用能够跨平台地使用，不同平台上应用的LOGO尺寸和格式也不尽相同。三个平台所需的图片格式如下：</p><ul><li>Linux - png</li><li>macOS - icns</li><li>Windows - ico</li></ul><p>准备一张1024*1024以下，256*256以上（长宽一致）的png图片，(推荐512 * 512）然后我们可以用一些工具来实现从png到其他两种格式。搜索png转ico或者png转icns的话有很多在线转换的网站，可以去上面在线转换。在mac上我推荐用的是<a href="http://www.img2icnsapp.com/" target="_blank" rel="noopener">image2icon</a>这个工具。</p><p>然后我们将所得的三个图片文件，放到electron-vue项目根目录的<code>build/icons/</code>目录下。</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fqnr7sfuvjj20h806cglq.jpg" alt=""></p><h2 id="不同平台的构建配置"><a href="#不同平台的构建配置" class="headerlink" title="不同平台的构建配置"></a>不同平台的构建配置</h2><p>本文我们主要采用electron-vue已经配置好的基于<a href="https://github.com/electron-userland/electron-builder" target="_blank" rel="noopener">electron-builder</a>的构建脚本来进行我们的应用构建。构建脚本会读取<code>package.json</code>里的<code>build</code>字段里的配置来进行构建。electron-vue默认的配置如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">"build": &#123;</span><br><span class="line">  "productName": "ElectronVue",</span><br><span class="line">  "appId": "org.simulatedgreg.electron-vue",</span><br><span class="line">  "dmg": &#123;</span><br><span class="line">    "contents": [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"x"</span>: <span class="number">410</span>,</span><br><span class="line">        <span class="attr">"y"</span>: <span class="number">150</span>,</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"link"</span>,</span><br><span class="line">        <span class="attr">"path"</span>: <span class="string">"/Applications"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"x"</span>: <span class="number">130</span>,</span><br><span class="line">        <span class="attr">"y"</span>: <span class="number">150</span>,</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"file"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  "directories": &#123;</span><br><span class="line">    "output": "build"</span><br><span class="line">  &#125;,</span><br><span class="line">  "files": [</span><br><span class="line">    "dist/electron",</span><br><span class="line">    "node_modules/",</span><br><span class="line">    <span class="string">"package.json"</span></span><br><span class="line">  ],</span><br><span class="line">  "mac": &#123;</span><br><span class="line">    "icon": "build/icons/icon.icns"</span><br><span class="line">  &#125;,</span><br><span class="line">  "win": &#123;</span><br><span class="line">    "icon": "build/icons/icon.ico"</span><br><span class="line">  &#125;,</span><br><span class="line">  "linux": &#123;</span><br><span class="line">    "icon": "build/icons"</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单讲述一下build配置里的一些字段的含义。</p><p>首先<code>productName</code>是你的应用的名字。<code>appId</code>的作用是用于Windows平台区分应用的标识。（<strong>注意</strong>该配置必须配置，而且稍后会有使用该配置的地方。如果不配置不使用的话，构建出来的Windows平台的应用将无法发送eletron的桌面通知）<code>dmg</code>这个配置里描述了macOS平台里，打开<code>dmg</code>安装包后显示的界面里的信息。如下图：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fqnrlfwfcej20u00mct9y.jpg" alt=""></p><p>表示了有两个标识，一个是应用文件，坐标是<code>(130, 150)</code>， 一个是应用文件夹的快捷方式，坐标是<code>(410, 150)</code>。</p><p><code>directories</code>的<code>output</code>字段是你应用打包完生成的文件放置的目录。</p><p><code>files</code>指明了要打包的目录。</p><p>而<code>mac</code>，<code>win</code>，<code>linux</code>是针对三个平台的不同的配置了。可以看出默认的配置里对它们的配置都是指向了不同的icon图标（也就是上一节所说的LOGO）。</p><p>PicGo在实际开发中，针对一些情况对默认的<code>build</code>配置项做出了一些增改：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">"build": &#123;</span><br><span class="line">  "productName": "PicGo",</span><br><span class="line">  "appId": "com.molunerfinn.picgo",</span><br><span class="line">  "directories": &#123;</span><br><span class="line">    "output": "build"</span><br><span class="line">  &#125;,</span><br><span class="line">  "files": [</span><br><span class="line">    <span class="string">"dist/electron/**/*"</span></span><br><span class="line">  ],</span><br><span class="line">  "dmg": &#123;</span><br><span class="line">    "contents": [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"x"</span>: <span class="number">410</span>,</span><br><span class="line">        <span class="attr">"y"</span>: <span class="number">150</span>,</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"link"</span>,</span><br><span class="line">        <span class="attr">"path"</span>: <span class="string">"/Applications"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"x"</span>: <span class="number">130</span>,</span><br><span class="line">        <span class="attr">"y"</span>: <span class="number">150</span>,</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"file"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  "mac": &#123;</span><br><span class="line">    "icon": "build/icons/icon.icns",</span><br><span class="line">    "extendInfo": &#123;</span><br><span class="line">      "LSUIElement": 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  "win": &#123;</span><br><span class="line">    "icon": "build/icons/icon.ico",</span><br><span class="line">    "target": "nsis"</span><br><span class="line">  &#125;,</span><br><span class="line">  "nsis": &#123;</span><br><span class="line">    "oneClick": false,</span><br><span class="line">    "allowToChangeInstallationDirectory": true</span><br><span class="line">  &#125;,</span><br><span class="line">  "linux": &#123;</span><br><span class="line">    "icon": "build/icons"</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>由于PicGo在macOS上主要是一个顶部栏应用，所以在底部docker栏我并不想拥有一个占位的图标，所以在<code>mac</code>字段里加入了：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"extendInfo": &#123;</span><br><span class="line">  "LSUIElement": 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个属性。参考相关<a href="https://github.com/electron-userland/electron-builder/issues/1456" target="_blank" rel="noopener">issue</a>。</p><p>在Windows平台上，默认打包出来的安装包并没有办法选择安装的路径，只会默认装到C盘的用户目录。这个并不是我们想要的。我们想要的是让用户自己选择安装的路径。</p><p>所以需要修改<code>windows</code>的一些配置以及加上一个<code>nsis</code>的配置来实现：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">"win": &#123;</span><br><span class="line">  "icon": "build/icons/icon.ico",</span><br><span class="line">  "target": "nsis"</span><br><span class="line">&#125;,</span><br><span class="line">"nsis": &#123;</span><br><span class="line">  "oneClick": false,</span><br><span class="line">  "allowToChangeInstallationDirectory": true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于目前我还没有打包过Linux平台的应用，所以Linux相关的配置暂时先不做修改。</p><h3 id="Windows平台打包的一个小坑"><a href="#Windows平台打包的一个小坑" class="headerlink" title="Windows平台打包的一个小坑"></a>Windows平台打包的一个小坑</h3><p>还记得前面说到的一个配置：<code>appId</code>么，这个配置需要我们在主进程<code>index.js</code>里也要使用。否则打包后的应用将失去Windows平台的应用通知功能。这个<code>appId</code>是可以任意取的，只要保证不和其他应用重复即可。对于PicGo而言，<code>appId</code>是<code>com.molunerfinn.picgo</code>。</p><p>打开你的<code>main/index.js</code>，在Windows平台的时候加上这个<code>appId</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">import</span> pkg <span class="keyword">from</span> <span class="string">'../../package.json'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (process.platform === <span class="string">'win32'</span>) &#123;</span><br><span class="line">  app.setAppUserModelId(pkg.build.appId)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就解决了通知的那个问题。</p><h2 id="通过CI系统自动构建与发布"><a href="#通过CI系统自动构建与发布" class="headerlink" title="通过CI系统自动构建与发布"></a>通过CI系统自动构建与发布</h2><h3 id="版本相关"><a href="#版本相关" class="headerlink" title="版本相关"></a>版本相关</h3><p>发布应用其实是一个比较繁琐的活，往往跟你的版本控制绑在一块，所以通常在项目开始的阶段就要有所布局。我说说我的做法吧，不一定很科学，不过简单易行。</p><ol><li>仓库主要两个分支，一个dev一个master。平时在dev上开发，只有在发布新版的时候merge到master上。</li><li>书写简单的更新版本的脚本，一键打tag+push到GitHub。</li><li>结合CI系统，自动构建master分支的代码，并将应用推送到GitHub仓库去。</li></ol><p>其中简单的更新版本的脚本我是在<code>package.json</code>里写了简单的<code>scripts</code>：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "patch": "npm version patch &amp;&amp; git push origin master &amp;&amp; git push origin --tags", // 小版本</span><br><span class="line">  "minor": "npm version minor &amp;&amp; git push origin master &amp;&amp; git push origin --tags", // 次版本</span><br><span class="line">  "major": "npm version major &amp;&amp; git push origin master &amp;&amp; git push origin --tags"  // 大版本</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>里面用到了npm的一个命令，<code>npm version [options]</code>，具体可以参考version的<a href="https://docs.npmjs.com/cli/version" target="_blank" rel="noopener">文档</a>。简单来说，它能够自动帮你升级版本，修改<code>package.json</code>里的version，并打上相应的git tag，很方便。</p><p>举个例子，一个符合语义的版本号通常由如下三个部分组成：<code>major.minor.patch</code>，比如<code>1.5.3</code>。如果我运行了<code>npm run patch</code>，那么将会将小版本更新：<code>1.5.4</code>，同时修改<code>package.json</code>里的<code>version</code>字段为<code>1.5.4</code>并自动打上一个git tag <code>1.5.4</code>，并将这个修改和tag推送到远端。</p><p>不过需要注意的是，一开始我是通过electron-vue自带的<code>npm run build</code>这个脚本让CI去执行构建，但是发现无法自动上传到GitHub的release里。所以通过查阅相关资料后，发现最简单的就是把对应的npm scripts命名为<code>release</code>。于是我把原本的<code>npm run build</code>的脚本复制了一遍，起了一个新名<code>release</code>:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  // ...</span><br><span class="line">  "release": "node .electron-vue/build.js &amp;&amp; electron-builder",</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CI相关"><a href="#CI相关" class="headerlink" title="CI相关"></a>CI相关</h3><p>说到这里都还没说到CI系统。什么是CI？可以参考阮一峰老师给出的解释<a href="http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html" target="_blank" rel="noopener">《持续集成是什么？》</a>。我们如果每次发布应用都需要我们在本地构建，然后手动上传到GitHub（或者其他地方）去，然后让别人能下载的话，未免太累了。而且通常我们开发electron应用就是为了能够跨平台，但是要构建不同的平台的应用意味着我们要在不同的平台分别构建。这也是不能忍受的。</p><p>于是网上有一些第三方的CI系统，它们能够帮我们，在某些分支（比如master）发生了某些更新（比如更新了tag）的时候帮我们执行某些脚本（比如构建、测试）。这样就省却了我们在本地、多平台构建的烦心事，而且让一些都变得「自动化」了起来。</p><p>有了CI之后，我的electron应用的发布就变成这样的流程了：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fqq9mnpumwj20rb04bt9a.jpg" alt=""></p><p>这样，我们只需要Push代码足矣。</p><p>针对Linux或者macOS的构建，我们可以使用<a href="https://travis-ci.org/" target="_blank" rel="noopener">Travis-CI</a>，针对Windows平台的构建，我们可以使用<a href="https://www.appveyor.com/" target="_blank" rel="noopener">AppVeyor</a>。一个好消息是，它们对于在GitHub上的开源项目都是可以免费构建的，并且和GitHub的仓库结合地特别好，配置也比较简单，可以说的非常良心了。</p><p>在使用它们之前，我们需要给予它们一定的权限让它们能够访问我们的GitHub仓库。所以需要：</p><ol><li>用你的GitHub账号注册它们，才能获取你的仓库列表。</li><li>在GitHub上生成<a href="https://github.com/settings/tokens" target="_blank" rel="noopener">token</a>，赋予CI系统读写你的仓库的权限。生成token的具体操作可以查看之前我写的一篇针对hexo持久化构建的<a href="https://molunerfinn.com/hexo-travisci-https/">文章</a>。</li><li>针对不同的CI平台创建不同的配置文件，好让它们知道你要它们执行什么操作。不过electron-vue很友好地为我们准备了Travis-CI的配置文件模板<code>.travis.yml</code>和AppVeyor的配置文件模板<code>appveyor.yml</code>。所以我们基本上只需要在它们的基础上小修改即可。</li></ol><h3 id="Travis-CI"><a href="#Travis-CI" class="headerlink" title="Travis-CI"></a>Travis-CI</h3><p>注册并登录Travis-CI后，找到你要构建的仓库，然后打开，点击设置进入如下页面：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19gy1fi438l5g9sj218a0wmn1u.jpg" alt=""></p><p>配置一下环境变量，名为<code>GH_TOKEN</code>，token的值就是上一步我们在GitHub生成的token。等会会有用。</p><p>PicGo经过修改后的<code>.travis.yml</code>如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Commented sections below can be used to run tests on the CI server</span></span><br><span class="line"><span class="comment"># https://simulatedgreg.gitbooks.io/electron-vue/content/en/testing.html#on-the-subject-of-ci-testing</span></span><br><span class="line"><span class="attr">osx_image:</span> <span class="string">xcode8.3</span></span><br><span class="line"><span class="attr">sudo:</span> <span class="string">required</span></span><br><span class="line"><span class="attr">dist:</span> <span class="string">trusty</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">c</span></span><br><span class="line"><span class="attr">matrix:</span></span><br><span class="line"><span class="attr">  include:</span></span><br><span class="line"><span class="attr">  - os:</span> <span class="string">osx</span></span><br><span class="line">  <span class="comment"># - os: linux</span></span><br><span class="line"><span class="attr">    env:</span> <span class="string">CC=clang</span> <span class="string">CXX=clang++</span> <span class="string">npm_config_clang=1</span></span><br><span class="line"><span class="attr">    compiler:</span> <span class="string">clang</span></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line"><span class="attr">  directories:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">node_modules</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">"$HOME/.electron"</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">"$HOME/.cache"</span></span><br><span class="line"><span class="attr">addons:</span></span><br><span class="line"><span class="attr">  apt:</span></span><br><span class="line"><span class="attr">    packages:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">libgnome-keyring-dev</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">icnsutils</span></span><br><span class="line"><span class="attr">before_install:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">mkdir</span> <span class="bullet">-p</span> <span class="string">/tmp/git-lfs</span> <span class="string">&amp;&amp;</span> <span class="string">curl</span> <span class="bullet">-L</span> <span class="attr">https://github.com/github/git-lfs/releases/download/v1.2.1/git-lfs-$([</span></span><br><span class="line">  <span class="string">"$TRAVIS_OS_NAME"</span> <span class="string">==</span> <span class="string">"linux"</span> <span class="string">]</span> <span class="string">&amp;&amp;</span> <span class="string">echo</span> <span class="string">"linux"</span> <span class="string">||</span> <span class="string">echo</span> <span class="string">"darwin"</span><span class="string">)-amd64-1.2.1.tar.gz</span></span><br><span class="line">  <span class="string">| tar -xz -C /tmp/git-lfs --strip-components 1 &amp;&amp; /tmp/git-lfs/git-lfs pull</span></span><br><span class="line"><span class="string"></span><span class="attr">install:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">nvm</span> <span class="string">install</span> <span class="number">8.9</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">curl</span> <span class="bullet">-o-</span> <span class="bullet">-L</span> <span class="attr">https://yarnpkg.com/install.sh</span> <span class="string">| bash</span></span><br><span class="line"><span class="string">- source ~/.bashrc</span></span><br><span class="line"><span class="string">- npm install -g xvfb-maybe</span></span><br><span class="line"><span class="string">- yarn</span></span><br><span class="line"><span class="string"></span><span class="attr">script:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">release</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">yarn</span> <span class="string">run</span> <span class="attr">build:docs</span></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line"><span class="attr">  only:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">master</span></span><br><span class="line"><span class="attr">after_script:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">cd</span> <span class="string">docs/dist</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">init</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">config</span> <span class="string">user.name</span> <span class="string">"Molunerfinn"</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">config</span> <span class="string">user.email</span> <span class="string">"marksz@teamsz.xyz"</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">add</span> <span class="string">.</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">commit</span> <span class="bullet">-m</span> <span class="string">"Travis build docs"</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">push</span>  <span class="bullet">--force</span> <span class="bullet">--quiet</span> <span class="string">"https://$&#123;GH_TOKEN&#125;@github.com/Molunerfinn/PicGo.git"</span> <span class="attr">master:gh-pages</span></span><br></pre></td></tr></table></figure><p>抛去很多前置依赖（比如C++编译库之类的）和构建环境（是什么系统，是什么语言），那些都是electron-vue给我们预置好的。我们需要注意的仅仅是几个部分：</p><ol><li>script</li><li>branches</li><li>after_script</li></ol><p><code>script</code>是当系统和环境和依赖都准备好之后，你要CI运行的命令。在这里我运行了两个命令，一个是<code>npm run release</code>，这个就是打包构建应用啦，并且执行了这个命令之后，<code>electron-builder</code>会自动将生成好的安装包推送到我们GitHub仓库的draft release里。另一个是构建PicGo<a href="https://molunerfinn.com/PicGo/">主页</a>的命令<code>yarn run build:docs</code>。</p><p><code>branches</code>声明了你要在哪些分支在GitHub接收到了代码更新之后就构建，这里我们自然选择的是master。</p><p><code>after_script</code>是当你执行完script里的脚本之后要做的事。可以为空。对于我而言主要在这个部分将上一步构建好的PicGo主页推送到GitHub的<code>gh-pages</code>分支。当然如果你的应用有使用说明、文档之类的网站，也可以在这里进行构建和推送。</p><p>注意到，在<code>after_script</code>命令的最后一行，有个<code>${GH_TOKEN}</code>，这个就是我们之前在Travis-CI配置里配置的环境变量<code>GH_TOKEN</code>。用环境变量的好处是不会暴露你的TOKEN，只有构建系统知道。</p><h3 id="AppVeyor"><a href="#AppVeyor" class="headerlink" title="AppVeyor"></a>AppVeyor</h3><p>有了之前的经验，AppVeyor就更简单了。注册登录后，我们在主页添加一个PROJECT，选中你要构建的仓库。然后找到SETTING设置：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fqqawmvu6sj21ji06e3z0.jpg" alt=""></p><p>然后在左侧的<code>Genral</code>一栏的内容区中，找到构建的分支为master，以及设置我们仅在<code>tag</code>更新的时候构建：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fqqazwrslxj21600emjse.jpg" alt=""></p><blockquote><p>当然这个都是根据项目实际来的配置，我只是说PicGo的项目是这样配置的。</p></blockquote><p>然后在左侧的<code>Environment</code>区，找到环境变量配置，我们依然写入<code>GH_TOKEN</code>:</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fqqb1ufhj7j21ow0gydhu.jpg" alt=""></p><p><strong>修改完配置都别忘了拉到底部去保存！</strong></p><p>这样就算配置完了网页端的。而现在我们来看看<code>appveyor.yml</code>这个配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Commented sections below can be used to run tests on the CI server</span></span><br><span class="line"><span class="comment"># https://simulatedgreg.gitbooks.io/electron-vue/content/en/testing.html#on-the-subject-of-ci-testing</span></span><br><span class="line"><span class="attr">version:</span> <span class="number">0.1</span><span class="string">.&#123;build&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line"><span class="attr">  only:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">master</span></span><br><span class="line"></span><br><span class="line"><span class="attr">image:</span> <span class="string">Visual</span> <span class="string">Studio</span> <span class="number">2017</span></span><br><span class="line"><span class="attr">platform:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">x64</span></span><br><span class="line"></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">node_modules</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">'%APPDATA%\npm-cache'</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">'%USERPROFILE%\.electron'</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">'%USERPROFILE%\AppData\Local\Yarn\cache'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">init:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">config</span> <span class="bullet">--global</span> <span class="string">core.autocrlf</span> <span class="string">input</span></span><br><span class="line"></span><br><span class="line"><span class="attr">install:</span></span><br><span class="line"><span class="attr">  - ps:</span> <span class="string">Install-Product</span> <span class="string">node</span> <span class="number">8</span> <span class="string">x64</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">reset</span> <span class="bullet">--hard</span> <span class="string">HEAD</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">node</span> <span class="bullet">--version</span></span><br><span class="line"></span><br><span class="line"><span class="attr">build_script:</span></span><br><span class="line">  <span class="comment">#- yarn test</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">release</span></span><br><span class="line"></span><br><span class="line"><span class="attr">test:</span> <span class="string">off</span></span><br></pre></td></tr></table></figure><p>依然是只需要关注我们所关心的配置即可。一个是<code>branches</code>，一个是<code>build_script</code>。有了<code>Travis-CI</code>的<code>.travis.yml</code>的经验，我相信你也能很快理解它。</p><p>经过上述配置之后，你已经实现了一个简单的前端工程的自动化构建推送流程了。而今你只需要关注代码提交，应用的构建都将会由CI系统自动帮你完成。当然CI系统也不仅仅是拿来构建electron应用的，正如你所见的，你能想到的其他项目的构建、测试其实它都能帮你通过预定义好的脚本完成。</p><h3 id="发布Release"><a href="#发布Release" class="headerlink" title="发布Release"></a>发布Release</h3><p>当CI构建玩应用，会将其推送到你的GitHub的release页面成为一个<code>draf</code>（草稿），你可以编辑这个草稿，加上标题和更新说明，就可以点击<code>publish</code>发布你的新版本的应用啦。</p><h2 id="electron应用的更新"><a href="#electron应用的更新" class="headerlink" title="electron应用的更新"></a>electron应用的更新</h2><p>electron应用的自动更新其实社区有很好的解决方案<a href="https://github.com/electron-userland/electron-builder/tree/master/packages/electron-updater" target="_blank" rel="noopener">electron-updater</a>。而electron-vue也在主进程的<code>main/index.js</code>里预先帮我们写好了一段注释的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import &#123; autoUpdater &#125; from 'electron-updater'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// autoUpdater.on('update-downloaded', () =&gt; &#123;</span></span><br><span class="line"><span class="comment">//   autoUpdater.quitAndInstall()</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// app.on('ready', () =&gt; &#123;</span></span><br><span class="line"><span class="comment">//   if (process.env.NODE_ENV === 'production') &#123;</span></span><br><span class="line"><span class="comment">//     autoUpdater.checkForUpdates()</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>只要引入autoUpdater就能自动帮我们检查更新和自动下载安装更新。不过，凡事都有不过。这个方式虽然很简单，但是它需要的条件比较严格，需要你拥有证书用于应用签名。而macOS平台下的证书需要你申请开发者，一年99$的费用让我望而却步。</p><p>于是我只能退而求其次，能不能通过查询GitHub的release版本号，来比对当前版本，是否需要更新，并提醒用户呢？经过尝试，发现可行。我的实现方法如下:</p><p>我首先写了一个<code>updateChecker</code>的助手：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; dialog, shell &#125; <span class="keyword">from</span> <span class="string">'electron'</span></span><br><span class="line"><span class="keyword">import</span> db <span class="keyword">from</span> <span class="string">'../../datastore'</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"><span class="keyword">import</span> pkg <span class="keyword">from</span> <span class="string">'../../../package.json'</span></span><br><span class="line"><span class="keyword">const</span> version = pkg.version</span><br><span class="line"><span class="keyword">const</span> release = <span class="string">'https://api.github.com/repos/Molunerfinn/PicGo/releases/latest'</span></span><br><span class="line"><span class="keyword">const</span> downloadUrl = <span class="string">'https://github.com/Molunerfinn/PicGo/releases/latest'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> checkVersion = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> showTip = db.read().get(<span class="string">'picBed.showUpdateTip'</span>).value()</span><br><span class="line">  <span class="keyword">if</span> (showTip === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    db.read().set(<span class="string">'picBed.showUpdateTip'</span>, <span class="literal">true</span>).write()</span><br><span class="line">    showTip = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 自动更新的弹窗如果用户没有设置不再提醒，就可以去查询是否需要更新</span></span><br><span class="line">  <span class="keyword">if</span> (showTip) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> axios.get(release)</span><br><span class="line">    <span class="keyword">if</span> (res.status === <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> latest = res.data.name <span class="comment">// 获取版本号</span></span><br><span class="line">      <span class="keyword">const</span> result = compareVersion2Update(version, latest) <span class="comment">// 比对版本号，如果本地版本低于远端则更新</span></span><br><span class="line">      <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        dialog.showMessageBox(&#123;</span><br><span class="line">          type: <span class="string">'info'</span>,</span><br><span class="line">          title: <span class="string">'发现新版本'</span>,</span><br><span class="line">          buttons: [<span class="string">'Yes'</span>, <span class="string">'No'</span>],</span><br><span class="line">          message: <span class="string">'发现新版本，更新了很多功能，是否去下载最新的版本？'</span>,</span><br><span class="line">          checkboxLabel: <span class="string">'以后不再提醒'</span>,</span><br><span class="line">          checkboxChecked: <span class="literal">false</span></span><br><span class="line">        &#125;, (res, checkboxChecked) =&gt; &#123;</span><br><span class="line">          <span class="keyword">if</span> (res === <span class="number">0</span>) &#123; <span class="comment">// if selected yes</span></span><br><span class="line">            shell.openExternal(downloadUrl)</span><br><span class="line">          &#125;</span><br><span class="line">          db.read().set(<span class="string">'picBed.showUpdateTip'</span>, !checkboxChecked).write()</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if true -&gt; update else return false</span></span><br><span class="line"><span class="keyword">const</span> compareVersion2Update = <span class="function">(<span class="params">current, latest</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> currentVersion = current.split(<span class="string">'.'</span>).map(<span class="function"><span class="params">item</span> =&gt;</span> <span class="built_in">parseInt</span>(item))</span><br><span class="line">  <span class="keyword">const</span> latestVersion = latest.split(<span class="string">'.'</span>).map(<span class="function"><span class="params">item</span> =&gt;</span> <span class="built_in">parseInt</span>(item))</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (currentVersion[i] &lt; latestVersion[i]) &#123;</span><br><span class="line">      flag = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> flag</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> checkVersion</span><br></pre></td></tr></table></figure><p>然后在<code>main/index.js</code>里，我在app准备启动的时候，调用这个更新助手：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">import</span> uploader <span class="keyword">from</span> <span class="string">'./utils/uploader.js'</span></span><br><span class="line"></span><br><span class="line">app.on(<span class="string">'ready'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  updateChecker()</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样就能在启动应用的时候弹出更新提示：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fqqbm19ptvj20nc08swf7" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文简要地讲述了electron应用用上CI系统帮我们自动化构建和推送，以及在没有申请开发者，没有证书用于应用的代码签名的情况下如何告知用户进行应用更新。要做一个健壮的应用就应该考虑到应用的版本发布、版本更新和对用户的更新通知。</p><p>本文很多都是我在开发<code>PicGo</code>的时候碰到的问题、踩的坑。也许文中简单的几句话背后就是我无数次的查阅和调试。希望这篇文章能够给你的<code>electron-vue</code>开发带来一些启发。文中相关的代码，你都可以在<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a>的项目仓库里找到，欢迎star~如果本文能够给你带来帮助，那么将是我最开心的地方。如果喜欢，欢迎关注我的<a href="https://molunerfinn.com">博客</a>以及<a href="https://molunerfinn.com/tags/Electron-vue/">本系列文章</a>的后续进展。</p><blockquote><p><strong>注：文中的图片除未特地说明之外均属于我个人作品，需要转载请私信</strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前段时间，我用&lt;a href=&quot;https://github.com/SimulatedGREG/electron-vue&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;electron-vue&lt;/a&gt;开发了一款跨平台（目前支持Mac和Windows）的免费开源的图床上传应用——&lt;a href=&quot;https://github.com/Molunerfinn/PicGo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PicGo&lt;/a&gt;，在开发过程中踩了不少的坑，不仅来自应用的业务逻辑本身，也来自electron本身。在开发这个应用过程中，我学了不少的东西。因为我也是从0开始学习electron，所以很多经历应该也能给初学、想学electron开发的同学们一些启发和指示。故而写一份Electron的开发实战经历，用最贴近实际工程项目开发的角度来阐述。希望能帮助到大家。&lt;/p&gt;&lt;p&gt;预计将会从几篇&lt;a href=&quot;https://molunerfinn.com/tags/Electron-vue/&quot;&gt;系列文章&lt;/a&gt;或方面来展开：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-1/&quot;&gt;electron-vue入门&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-2/&quot;&gt;Main进程和Renderer进程的简单开发&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-3/&quot;&gt;引入基于Lodash的JSON database——lowdb&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-4/&quot;&gt;跨平台的一些兼容措施&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-5/&quot;&gt;通过CI发布以及更新的方式&lt;/a&gt;&lt;/li&gt;&lt;li&gt;…（想到再写）&lt;/li&gt;&lt;/ol&gt;&lt;h2 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h2&gt;&lt;p&gt;&lt;code&gt;PicGo&lt;/code&gt;是采用&lt;code&gt;electron-vue&lt;/code&gt;开发的，所以如果你会&lt;code&gt;vue&lt;/code&gt;，那么跟着一起来学习将会比较快。如果你的技术栈是其他的诸如&lt;code&gt;react&lt;/code&gt;、&lt;code&gt;angular&lt;/code&gt;，那么纯按照本教程虽然在render端（可以理解为页面）的构建可能学习到的东西不多，不过在main端（electron的主进程）应该还是能学习到相应的知识的。&lt;/p&gt;&lt;p&gt;如果之前的文章没阅读的朋友可以先从&lt;a href=&quot;https://molunerfinn.com/tags/Electron-vue/&quot;&gt;之前的文章&lt;/a&gt;跟着看。&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="https://molunerfinn.com/categories/Web/"/>
    
      <category term="开发" scheme="https://molunerfinn.com/categories/Web/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="前端" scheme="https://molunerfinn.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Vue" scheme="https://molunerfinn.com/tags/Vue/"/>
    
      <category term="Electron" scheme="https://molunerfinn.com/tags/Electron/"/>
    
      <category term="Electron-vue" scheme="https://molunerfinn.com/tags/Electron-vue/"/>
    
  </entry>
  
  <entry>
    <title>一周一部好电影V【WEEK196 1987:黎明到来的那一天】</title>
    <link href="https://molunerfinn.com/PerfectMoviePerWeek5/"/>
    <id>https://molunerfinn.com/PerfectMoviePerWeek5/</id>
    <published>2018-04-23T22:36:00.000Z</published>
    <updated>2018-04-27T08:26:51.713Z</updated>
    
    <content type="html"><![CDATA[<h3 id="2018-04-23-WEEK196-1987-黎明到来的那一天"><a href="#2018-04-23-WEEK196-1987-黎明到来的那一天" class="headerlink" title="2018-04-23 WEEK196 1987:黎明到来的那一天"></a>2018-04-23 WEEK196 1987:黎明到来的那一天</h3><p>1987:黎明到来的那一天——————————————일구팔칠<br><img src="https://img.piegg.cn/week196.jpg?imgslim" alt="1987:黎明到来的那一天"></p><a id="more"></a><ul><li>导演：张俊焕</li><li>主演：金允锡/河正宇/柳海真/金泰梨/朴喜洵/李熙俊/..</li><li>片长：129分钟</li><li>影 片类型：剧情</li><li>豆 瓣评分：无</li><li>IMDB评分：8.0/10(from768users)</li></ul><p>Hi，各位好久不见！本周给大家推荐的一部电影是国内豆瓣都「没有办法出现」的韩国电影《1987:黎明到来的那一天》。因为某些原因这部电影在国内被封杀，所以我也不好说得太多。去看看吧，好电影值得一看。</p><hr><h3 id="2018-04-08-WEEK195-头号玩家"><a href="#2018-04-08-WEEK195-头号玩家" class="headerlink" title="2018-04-08 WEEK195 头号玩家"></a>2018-04-08 WEEK195 头号玩家</h3><p>头号玩家——————————————Ready Player One<br><img src="https://img.piegg.cn/week195.jpg?imgslim" alt="头号玩家"></p><!--more--><ul><li>导演：史蒂文·斯皮尔伯格</li><li>主演：泰伊·谢里丹/ 奥利维亚·库克/本·门德尔森/马克·里朗斯/丽娜·维特/森崎温/赵家正/西蒙·佩吉/T·J·米勒/汉娜·乔恩-卡门/拉尔夫·尹爱森/苏珊·林奇/克莱尔·希金斯/劳伦斯·斯佩尔曼/佩蒂塔·维克斯/艾萨克·安德鲁斯</li><li>片长：140分钟</li><li>影 片类型：动作/科幻/冒险</li><li>豆 瓣评分：8.9/10(from311,268users)</li><li>IMDB评分：7.9/10(from68,363users)</li></ul><p>Hi，各位好久不见！本周给大家推荐的是最近影院的大热门《头号玩家》。这部电影的豆瓣评分有点「虚高」，不过不可否认确实是一部非常棒的科幻电影。这是斯皮尔伯格送给年轻人、玩家、动漫迷们一份最好的礼物。</p><p>和过往的科幻电影有所不同的是，故事发生在不远的未来，不过科技并没有发展到「变态」的程度。所以电影里的很多东西，包括VR都是在现有的基础上进行的升华。而营造出来的虚拟世界无疑是最吸引眼球的。有人说这部电影是一部彩蛋里插播电影的电影。确实这部电影里彩蛋特别多，但是不用担心，没有人会真的了解所有的彩蛋，所以哪怕你并不关心游戏、动漫、电影，你也能在电影院感受两个半小时的视听盛宴。</p><p>大概最感动的地方就是遇到你所认识、你所熟知的角色、游戏在电影中的一闪而过。你会想起当年在家里打红白机、小霸王的那个年代，你会想起当年守在电视机前只为等待一部好看的动画片的自己。这部电影想要告诉你的也是一样——那些在你脑海中挥之不去的，那些回忆，那些童年才是最真实的。现实世界终究是追求自由追求真实的，在虚拟世界里再如何成功也不过是过眼烟云，现实中的伙伴，生活才是你最应该珍惜的。好电影，值得去一看。</p><hr><h3 id="2018-03-14-WEEK194-启示录"><a href="#2018-03-14-WEEK194-启示录" class="headerlink" title="2018-03-14 WEEK194 启示录"></a>2018-03-14 WEEK194 启示录</h3><p>启示录——————————————Apocalypto<br><img src="https://img.piegg.cn/week194.jpg?imgslim" alt="启示录"></p><!--more--><ul><li>导演：梅尔·吉布森</li><li>主演：鲁迪·杨布拉德/达利娅·埃尔南德斯/乔纳森·布雷维尔/莫里斯·博德耶洛海德/劳尔·特鲁希洛/赫拉多·塔拉塞纳/卡洛斯·伊米里奥·巴厄兹/阿米尔卡尔·拉米瑞兹/伊斯雷尔·康特雷拉斯/伊斯雷尔·里<br>奥斯/玛利亚·迪亚兹/埃斯皮里迪恩·阿科斯塔·卡奇/梅拉·萨布罗/伊阿祖娅·拉里奥斯/艾贝尔·伍尔里奇</li><li>片长：139分钟</li><li>影 片类型：剧情/动作/冒险</li><li>豆 瓣评分：8.5/10(from46,606users)</li><li>IMDB评分：7.8/10(from257,854users)</li></ul><p>Hi，各位好久不见！这部电影是来自公众号的粉丝推荐的一部好电影。很开心来一起分享它！这部电影的背景是玛雅文明衰落时期的故事，但是实际上有些情节又与当时鼎盛的阿兹特克文明有所重合。不过抛去历史背景，这个发生在热带雨林里的故事，却是惊心动魄，让人叹为观止。</p><p>影片的节奏松紧有度。开篇的情节把主要的人物性格、特点都印刻在观众的脑海中。而到了中途，就开始了震撼的追逐。如果从片名里直译的《启示录》里你看不到大致的情节的话，台译版的《阿波卡猎逃》可能就会让你的肾上腺素有所提升。不过如果你读过或者知道圣经里的《启示录》的话，那么这个题目真是太恰当不过了。一场文明的毁灭与新的文明的重生。这是一部让你无法忘却的电影，「文明」世界带去的文明，无非也是野蛮的征服。好电影，值得一看。</p><hr><h3 id="2018-03-14-WEEK193-红海行动"><a href="#2018-03-14-WEEK193-红海行动" class="headerlink" title="2018-03-14 WEEK193 红海行动"></a>2018-03-14 WEEK193 红海行动</h3><p>红海行动——————————————红海行动<br><img src="https://img.piegg.cn/week193.jpg?imageslim" alt="红海行动"></p><!--more--><ul><li>导演：林超贤</li><li>主演：张译/黄景瑜/海清/杜江/蒋璐霞/尹昉/王强/郭郁滨/王雨甜/麦亨利/张涵予/王彦霖</li><li>片长：138分钟</li><li>影 片类型：剧情/动作/犯罪</li><li>豆 瓣评分：8.5/10(from321,371users)</li><li>IMDB评分：7.6/10(from1,254users)</li></ul><p>Hi，各位好久不见！前不久我刚去看了最近大热的《红海行动》。记得当初也给大家推荐过《湄公河行动》和《战狼2》。不得不说这两年来我们自己拍出来的战争、动作片的水准是越来越高了。本片的导演也是《湄公河行动》的导演林超贤。可以说自《湄公河行动》后的两年，真的是卷土重来。并且带来了质量更好，水平更高，更加真实而震撼的场面。</p><p>本片根据真实事件改编，还原度相当高。不仅影片出现的枪械、装备、坦克等都非常写实，而且一些镜头例如汽车炸弹、精密狙击、迫击炮狂轰滥炸等等都有很强的视觉冲击。而最震撼人心的，还有出现的很多「血腥」的场景——以往在国产电影里被剪掉无法搬上荧幕的战争的一些遗体、残骸。而整体剧情也非常紧凑，从头到尾都无尿点啊。而海陆空全面的镜头也让人大呼过瘾。同时，反战的主题也深入人心啊。好电影，值得一看！</p><hr><h3 id="2018-03-01-WEEK192-弱点"><a href="#2018-03-01-WEEK192-弱点" class="headerlink" title="2018-03-01 WEEK192 弱点"></a>2018-03-01 WEEK192 弱点</h3><p>弱点——————————————The Blind Side<br><img src="https://img.piegg.cn/week192.jpg?imageslim" alt="弱点"></p><!--more--><ul><li>导演：约翰·李·汉考克</li><li>主演：桑德拉·布洛克/蒂姆·麦格罗/昆东·亚伦/杰·海德/莉莉·柯林斯/雷·迈克金农/凯西·贝茨</li><li>片长：USA: 129 分钟</li><li>影 片类型：剧情/家庭/传记/运动</li><li>豆 瓣评分：8.4/10(from104,599users)</li><li>IMDB评分：7.7/10(from248,692users)</li></ul><p>Hi，各位好久不见，新年快乐呀！趁新年还未完全过去，赶紧来给大家推荐每周一部的好电影，拖更了好久哈哈。本周给大家推荐的是一部来自美国的温情电影《弱点》。不过我一直觉得翻译有问题，翻译成「盲点」应该更好点。</p><p>这部电影是根据原著《The Blind Side: Evolution of the Game》改编的电影，而原著的原型也是来自于真实的故事。所以说这部电影的真实感让人非常感动——片中的人大多都超出你的想象的好。与大部分的电影不同的是，它的矛盾点、冲突点特别少。虽然在一些细节的处理上有些过快，不过能够在两个小时里塞进一个橄榄球传奇球员从默默无闻青年时代到最后脱颖而出的选秀状元，可以说是真的很不容易了。我在看的时候一直在惯性思考着等着导演「耍把戏」，不过从头到尾都非常地温馨，非常的动人。</p><p>它是一部能够打动你的泪腺的电影，一部好电影，献给新年的第一部推荐。</p><hr><h3 id="2018-02-04-WEEK191-抓住那个家伙"><a href="#2018-02-04-WEEK191-抓住那个家伙" class="headerlink" title="2018-02-04 WEEK191 抓住那个家伙"></a>2018-02-04 WEEK191 抓住那个家伙</h3><p>抓住那个家伙——————————————몽타주<br><img src="https://img.piegg.cn/week191.jpg?imageslim" alt="抓住那个家伙"></p><!--more--><ul><li>导演：郑根燮</li><li>主演：金相庆/严正化/宋永彰/曹熙奉/刘承睦/李俊赫/朴哲民</li><li>片长：120分钟</li><li>影 片类型：剧情/惊悚/犯罪</li><li>豆 瓣评分：7.9/10(from25,085users)</li><li>IMDB评分：7.5/10(from3,342users)</li></ul><p>Hi，各位好久不见！本周依然给大家推荐一部有悬疑色彩的犯罪电影。这部来自韩国的电影从一开始就让我们感到一丝伤感。导演很擅长用暗色调渲染这种压抑而忧伤的气氛。所以从一开始我们就逐渐掉进这个陷阱中了。</p><p>整体上电影是双线并进，两条时间线互相交错，以至于到最后汇合的时候碰撞出的火花恐怕要让你拍案叫绝。两起案件，两个真相。和里面的警察一样，我们大多数人都会被眼前的“证据”蒙蔽，相信一些说不过去的“真相”。而很多事情是需要推敲，需要冷静的。</p><p>受害者也是加害者，这样的双重身份在电影里互相交织，让人性这个词又得以从电影剧本里脱颖而出。事实上，这部电影也是一部关于人性的思考，关于悔过的思考。好电影，值得一看~</p><hr><h3 id="2018-01-28-WEEK190-目击者追凶"><a href="#2018-01-28-WEEK190-目击者追凶" class="headerlink" title="2018-01-28 WEEK190 目击者追凶"></a>2018-01-28 WEEK190 目击者追凶</h3><p>目击者追凶——————————————目擊者<br><img src="https://img.piegg.cn/week190.jpg?imageslim" alt="目击者追凶"></p><!--more--><ul><li>导演：程伟豪</li><li>主演：庄凯勋/许玮甯/柯佳嬿/李铭顺/李淳/陈彦允/郑志伟/汤志伟/卜国耕</li><li>片长：117分钟</li><li>影 片类型：悬疑/惊悚/犯罪</li><li>豆 瓣评分：8.1/10(from55,592users)</li><li>IMDB评分：7.0/10(from1,020users)</li></ul><p>Hi，各位好久不见！本周给大家推荐的是一部来自台湾的悬疑电影《目击者追凶》。我记得去年我曾推荐过一部大热的西班牙悬疑电影《看不见的客人》，精妙的剧本，峰会路转的剧情让很多人拍案叫绝。而这部来自宝岛台湾的电影也不逊色。</p><p>明线、暗线的堆叠，从一开始就埋下的伏笔。导演在一些细节的处理，比如一些闪回的镜头上做的是真的不错的。一次次小规模的反转铸就了最后令人吃惊而毛骨悚然的结局。这部电影里可以说基本没有“好人”。恐怕唯一的好人就是可怜的阿吉了。而所有其他出现在镜头里的主要角色，都有着外表和内在不同的反差。这也是这部电影可圈可点的地方。</p><p>而一部好的悬疑电影自然是到最后一刻才会完美收官。本片也不例外，片末的“鬼故事”，实在是画龙点睛之笔。好电影，值得一看。</p><hr><h3 id="2018-01-21-WEEK189-无问西东"><a href="#2018-01-21-WEEK189-无问西东" class="headerlink" title="2018-01-21 WEEK189 无问西东"></a>2018-01-21 WEEK189 无问西东</h3><p>无问西东——————————————Forever Young<br><img src="https://img.piegg.cn/week189.jpg?imageslim" alt="无问西东"></p><!--more--><ul><li>导演：李芳芳</li><li>主演：章子怡/黄晓明/张震/王力宏/陈楚生/韩童生/王盛德/米雪/保罗·菲利普·克拉克/祖锋/铁政/章泽天</li><li>片长：138分钟</li><li>影 片类型：剧情/爱情/战争</li><li>豆 瓣评分：7.5/10(from140,810users)</li><li>IMDB评分：6.5/10(from138users)</li></ul><p>Hi，各位好久不见！本次给大家推荐的是一部时隔5年重见天日的电影——《无问西东》。这部电影本来是打算献礼给清华大学建校100周年的，因为某些不可知的原因，一再推迟到如今才能上映。剧中的主演也都在这5年中结婚生子，变化之大也令人感慨。</p><p>既然是献礼给清华大学的电影，剧中自然少不了清华大学的身影。电影分成了4段故事来讲述。每段时间内发生的故事都有鲜明的时代特色。而4个故事之间的关联，也在影片“不经意”之间透露出来。而这样的安排也引起了一堆的不认可。然而我却觉得这样的安排非常棒。和云图的前世今生相比，这样的安排不仅更加贴近真实而且更加动人。</p><p>而每个故事里的主人公的演技我认为在当时，哪怕放到现在也都是非常不错的。就像豆瓣里有人说的，“最棒的王力宏和非常好的黄晓明”。两个小时，4个故事，横跨100年。这样庞大的题材，虽然导演确实在某些细节上处理的有些牵强，不过依旧不改这部电影交出的高分答卷。应对人生的选择，人声的苦难，你该如何继续？如果你没有看过《南渡北归》，你无法明白当年西南联大有多么不容易，当年的那些大家能够给本科生上课是有多么珍贵。电影最后给出的一个个那些年顶尖的学者，真是满满的感动和自豪。无问西东，砥砺前行。好电影，值得一看。</p><hr><h3 id="2018-01-08-WEEK188-三块广告牌"><a href="#2018-01-08-WEEK188-三块广告牌" class="headerlink" title="2018-01-08 WEEK188 三块广告牌"></a>2018-01-08 WEEK188 三块广告牌</h3><p>三块广告牌——————————————Three Billboards Outside Ebbing, Missouri<br><img src="https://img.piegg.cn/week188.jpg?imageslim" alt="三块广告牌"></p><!--more--><ul><li>导演：马丁·麦克唐纳</li><li>主演：弗兰西斯·麦克多蒙德/伍迪·哈里森/山姆·洛克威尔/艾比·考尼什/卢卡斯·赫奇斯/彼特·丁拉基/约翰·浩克斯/卡赖伯·兰德里·琼斯/凯瑟琳·牛顿/凯瑞·康顿/泽利科·伊万内克/萨玛拉·维文/克拉克·彼得斯/尼克·西塞</li><li>片长：115分钟</li><li>影 片类型：剧情/犯罪</li><li>豆 瓣评分：8.7/10(from20,455users)</li><li>IMDB评分：8.3/10(from31,903users)</li></ul><p>Hi，各位好久不见！忙完考试之后终于有时间来写本周的电影推荐了。本周给大家推荐的是去年底在美国上映（中国将在18年3月上映）的电影《三块广告牌》。</p><p>在这部充满美式幽默和美式愤怒的电影里，看到了久违的不靠煽情而让你动容的一部电影。不过我认为，真正让这部电影拥有如此好评的原因在于两点：</p><ol><li>导演（同时也是编剧）的讲故事的功力深厚</li><li>演员（尤其是科恩嫂）的演技强劲</li></ol><p>这部是一部讲述愤怒与善良，爱与恨的电影。愤怒不能解决问题，但是爱可以。影片塑造的多个人物都具有两面性——这也是本部电影最棒的地方。没有一个人是可以用好或者不好来形容的。每个人都有自己的阳光和阴暗面——而一开始我们不免进入了导演给我们设置的俗套。而随着剧情的发展你才会发现这一切都不是那么简单。“坏”警长其实不坏——相反还非常受人敬仰，“烂”警察其实不烂——相反他还自损三千地只为抓犯人等等。</p><p>而在被套路或者反套路的同时，你也逐渐了解到美国社会的诸多矛盾以及人的诸多美好品质。愤怒不能解决问题，但是善良与爱是可以的。好电影，值得一看。</p><hr><h3 id="2018-01-01-WEEK187-我能说"><a href="#2018-01-01-WEEK187-我能说" class="headerlink" title="2018-01-01 WEEK187 我能说"></a>2018-01-01 WEEK187 我能说</h3><p>我能说——————————————아이 캔 스피크<br><img src="https://img.piegg.cn/week187.jpg?imageslim" alt="我能说" title="我能说"></p><!--more--><ul><li>导演：金炫锡</li><li>主演：罗文姬/李帝勋/廉惠兰/朴哲民/李相喜/李知勋/郑妍周/金素真</li><li>片长：119分钟</li><li>影 片类型：剧情/喜剧</li><li>豆 瓣评分：8.8/10(from19,693users)</li><li>IMDB评分：7.7/10(from195users)</li></ul><p>Hi，各位新年快乐~转眼之间一周一部好电影已经来到了第5个年头。前四个年头通过一周一部好电影我已经推送了186部各种主题，各种类型，各种风格的电影，希望新的一年里能够有更多的好电影能够分享给各位~</p><p>本周给大家推荐的电影是一部去年韩国的电影《我能说》。一部能用喜剧的形式来讲述“慰安妇”这个沉痛主题的电影，真的无不佩服编剧的功力以及演员的水平。两个主演的表演真的太动人了。</p><p>这部电影能分成两部分。前半部分以喜剧为主，讲述一个“鬼怪奶奶”的各种“鬼怪”行径。而前半部分用尽努力“掩盖”的欢乐，在后半段会被导演“无情”地打碎，同时打碎的还有观众的泪腺。而同时引出的是这部电影的主题啊——那些被人们忽略的受害者们，那些无法说出，不愿说出，不想说出自己曾经经历的受害者们。她们真的需要更多我们的关怀和帮助。国内今年的《二十二》也是同样的主题。不同的角度，不过都是同样的出发点和同样的愿望——日本政府的一句道歉。好电影，值得一看。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;2018-04-23-WEEK196-1987-黎明到来的那一天&quot;&gt;&lt;a href=&quot;#2018-04-23-WEEK196-1987-黎明到来的那一天&quot; class=&quot;headerlink&quot; title=&quot;2018-04-23 WEEK196 1987:黎明到来的那一天&quot;&gt;&lt;/a&gt;2018-04-23 WEEK196 1987:黎明到来的那一天&lt;/h3&gt;&lt;p&gt;1987:黎明到来的那一天——————————————일구팔칠&lt;br&gt;&lt;img src=&quot;https://img.piegg.cn/week196.jpg?imgslim&quot; alt=&quot;1987:黎明到来的那一天&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="日志" scheme="https://molunerfinn.com/categories/%E6%97%A5%E5%BF%97/"/>
    
      <category term="周电" scheme="https://molunerfinn.com/categories/%E6%97%A5%E5%BF%97/%E5%91%A8%E7%94%B5/"/>
    
    
      <category term="电影" scheme="https://molunerfinn.com/tags/%E7%94%B5%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title>浅谈前后端路由与前后端渲染</title>
    <link href="https://molunerfinn.com/fe-be-router-render/"/>
    <id>https://molunerfinn.com/fe-be-router-render/</id>
    <published>2018-03-27T21:26:00.000Z</published>
    <updated>2018-04-27T08:26:51.717Z</updated>
    
    <content type="html"><![CDATA[<p>最近经常会遇到有人问诸如类似下面的问题：</p><ul><li>为啥我写的Vue应用在开发阶段都没问题，部署到服务端之后访问不了除了<code>/</code>的页面呢</li><li>为啥我写的SPA页面的路由用hash模式都没问题，改成history模式就问题百出呢</li><li>啥是前端路由啥是后端路由，要怎么配后端才能支持我的前端路由呢</li></ul><p>这个问题是很多初学者会问的问题，于是结合我自己的学习经历也来简单的讲解一下这二者的区别与联系，希望能对你们有所帮助。</p><p>老手可以绕道，去看些更有用的文章吧~</p><a id="more"></a><h2 id="什么是路由"><a href="#什么是路由" class="headerlink" title="什么是路由"></a>什么是路由</h2><p><a href="https://zhuanlan.zhihu.com/p/24814675" target="_blank" rel="noopener">理解Web路由</a>这篇文章讲得特别好了。</p><blockquote><p>在Web开发过程中，经常会遇到『路由』的概念。那么，到底什么是路由？简单来说，路由就是URL到函数的映射。</p></blockquote><p>访问的URL会映射到相应的函数里（这个函数是广义的，可以是前端的函数也可以是后端的函数），然后由相应的函数来决定返回给这个URL什么东西。路由就是在做一个匹配的工作。</p><h2 id="从后端路由讲起"><a href="#从后端路由讲起" class="headerlink" title="从后端路由讲起"></a>从后端路由讲起</h2><p>在web开发早期的「刀耕火种」年代里，一直是后端路由占据主导地位。不管是php，还是jsp、asp，用户能通过URL访问到的页面，大多是通过后端路由匹配之后再返回给浏览器的。经典面试题，「你从浏览器地址栏里输入<code>www.baidu.com</code>到你看到网页这个过程中经历了什么」其实讲的也是这个道理。</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fproibqucxj20lu03odg9.jpg" alt=""></p><p>在web后端，不管是什么语言的后端框架，都会有一个专门开辟出来的路由模块或者路由区域，用来匹配用户给出的URL地址，以及一些表单提交、ajax请求的地址。通常遇到无法匹配的路由，后端将会返回一个<code>404</code>状态码。这也是我们常说的<code>404 NOT FOUND</code>的由来。</p><h3 id="URL与Methods"><a href="#URL与Methods" class="headerlink" title="URL与Methods"></a>URL与Methods</h3><p>如果你关注RESTful API，那么将会很熟悉下面四种发起请求的类型：<code>GET</code>，<code>POST</code>，<code>PUT</code>，<code>DELETE</code>。</p><blockquote><p>它们分别对应四种基本操作：<strong>GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。</strong> ——来自阮一峰<a href="http://www.ruanyifeng.com/blog/2011/09/restful.html" target="_blank" rel="noopener">《理解RESTful架构》</a></p></blockquote><p>虽然上面说的是RESTful API，但是实际上我们在地址栏输入一个URL，并回车的时候，是以<code>GET</code>请求发出去的。这也体现了，URL地址和请求的method也应该是一一对应。下面给出一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">router.post(<span class="string">'/user/:id'</span>, addUser)</span><br></pre></td></tr></table></figure><p>假如我的后端路由配置里只有这一句路由。那么我通过浏览器里访问：<code>http://xxx.com/user/123</code>的话是无法访问到的，也会返回一个404。因为后端只配了一个<code>post</code>方法的路由。如果要接受这个请求，那么必须有如下的路由：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">router.get(<span class="string">'/user/:id'</span>, getUser) <span class="comment">// 配置get路由</span></span><br><span class="line">router.post(<span class="string">'/user/:id'</span>, addUser)</span><br></pre></td></tr></table></figure><h3 id="后端路由与服务端渲染"><a href="#后端路由与服务端渲染" class="headerlink" title="后端路由与服务端渲染"></a>后端路由与服务端渲染</h3><p>前面说了，「刀耕火种」的年代里，网页通常是通过后端路由直出给客户端浏览器的。也就是网页的html一般是在后端服务器里通过模板引擎渲染好再交给前端的。至于一些其他的效果，是通过预先写在页面里的jQuery、Bootstrap等常见的前端框架去负责的。</p><p>如果你说有些网站已经是通过ajax去实现的页面，比如gmail，比如qq邮箱。那么你要注意到哪怕是这些页面，它们页面的「龙骨」也并非是全部通过ajax去实现的，依然还是后端直出——这也就是我们现在又老生常谈的<strong>服务端渲染</strong>。</p><p>服务端渲染的好处有很多，比如对于SEO友好，一些对安全性要求高的页面采用服务端渲染是更保险的。而在当时还没有node.js的年代，为了良好地构建前端页面，都是通过服务端语言对应的模板引擎来实现动态网页、页面结构的组织、组件的复用。比如Laravel的blade，用在Django上的jinja2，用在Struts的jsp等等。实际上到如今，一门后端语言想要能实现自己的web功能，都需要有自己对应的模板引擎。</p><p>node.js诞生之后，前端拥有自己的后端渲染的模板引擎也成为了现实。常见的比如pug、ejs、nunjucks等。这些模板引擎搭配Express、Koa等后端框架也在一开始风靡一时。</p><p>不过在这个过程中，随着web应用的开发越来越复杂，单纯服务端渲染的问题开始慢慢的暴露出来了——耦合性太强了，jQuery时代的页面不好维护，页面切换白屏严重等等。耦合性问题虽然能通过良好的代码结构、规范来解决，不过jQuery时代的页面不好维护这是有目共睹的，全局变量满天飞，代码入侵性太高。后续的维护通常是在给前面的代码打补丁。而页面切换的白屏问题虽然可以通过ajax、或者iframe等来解决，但是在实现上就麻烦了——进一步增加了可维护的难度。</p><p>于是，我们开始进入了前端路由的时代。</p><h2 id="过渡到前端路由"><a href="#过渡到前端路由" class="headerlink" title="过渡到前端路由"></a>过渡到前端路由</h2><p>前端路由——顾名思义，<strong>页面跳转的URL规则匹配</strong>由前端来控制。而前端路由主要是有两种显示方式：</p><ul><li>带有hash的前端路由，优点是兼容性高。缺点是URL带有<code>#</code>号不好看</li><li>不带hash的前端路由，优点是URL不带<code>#</code>号，好看。缺点是既需要浏览器支持也需要后端服务器支持</li></ul><p>前端路由应用最广泛的例子就是当今的SPA的web项目。不管是Vue、React还是Angular的页面工程，都离不开相应配套的router工具。前端路由带来的最明显的好处就是，地址栏URL的跳转不会白屏了——这也得益于前端渲染带来的好处。</p><h3 id="前端路由与前端渲染"><a href="#前端路由与前端渲染" class="headerlink" title="前端路由与前端渲染"></a>前端路由与前端渲染</h3><p>讲前端路由就不能不说前端渲染。我以Vue项目为例。如果你是用官方的<code>vue-cli</code>搭配webpack模板构建的项目，你有没有想过你的浏览器拿到的html是什么样的？是你页面长的那样有<code>button</code>有<code>form</code>的样子么？我想不是的。在生产模式下，你看看构建出来的<code>index.html</code>长什么样：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Vue<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"xxxx.xxx.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"yyyy.yyy.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"zzzz.zzz.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通常长上面这个样子。可以看到，这个其实就是你的浏览器从服务端拿到的html。这里面空荡荡的只有一个<code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code>这个入口的div以及下面配套的一系列js文件。所以你看到的页面其实是通过那些js渲染出来的。这也是我们常说的前端渲染。</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fproyjjjlij20jg03oq3a.jpg" alt=""></p><p>前端渲染把渲染的任务交给了浏览器，通过客户端的算力来解决页面的构建，这个很大程度上缓解了服务端的压力。而且配合前端路由，无缝的页面切换体验自然是对用户友好的。不过带来的坏处就是对SEO不友好，毕竟搜索引擎的爬虫只能爬到上面那样的html，对浏览器的版本也会有相应的要求。</p><p>需要明确的是，只要在浏览器地址栏输入URL再回车，是一定会去后端服务器请求一次的。而如果是在页面里通过点击按钮等操作，利用router库的api来进行的URL更新是不会去后端服务器请求的。</p><h4 id="Hash模式"><a href="#Hash模式" class="headerlink" title="Hash模式"></a>Hash模式</h4><p>hash模式利用的是浏览器不会对<code>#</code>号后面的路径对服务端发起路由请求。也即在浏览器里输入如下这两个地址：<code>http://localhost/#/user/1</code>和<code>http://localhost/</code>其实到服务端都是去请求<code>http://localhost</code>这个页面的内容。</p><p>而前端的router库通过捕捉<code>#</code>号后面的参数、地址，来告诉前端库（比如Vue）渲染对应的页面。这样，不管是我们在浏览器的地址栏输入，或者是页面里通过router的api进行的跳转，都是一样的跳转逻辑。所以这个模式是不需要后端配置其他逻辑的，只要给前端返回<code>http://localhost</code>对应的html，剩下具体是哪个页面，就由前端路由去判断便可。</p><h4 id="History模式"><a href="#History模式" class="headerlink" title="History模式"></a>History模式</h4><p>不带<code>#</code>号的路由，也就是我们通常能见到的URL形式。router库要实现这个功能一般都是通过HTML5提供的<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/History_API" target="_blank" rel="noopener">history</a>这个api。比如<code>history.pushState()</code>可以向浏览器地址栏push一个URL，而这个URL是不会向后端发起请求的！通过这个特性，便能很方便地实现漂亮的URL。不过需要注意的是，这个api对于IE9及其以下版本浏览器是不支持的，IE10开始支持，所以对于浏览器版本是有要求的。vue-router会检测浏览器版本，当无法启用history模式的时候会自动降级为hash模式。</p><p>上面说了，你在页面里的跳转，通常是通过router的api去进行的跳转，router的api调用的通常是<code>history.pushState()</code>这个api，所以跟后端没什么关系。但是<strong>一旦你从浏览器地址栏里输入一个地址，比如<code>http://localhost/user/1</code></strong>,这个URL是会向后端发起一个get请求的。后端路由表里如果没有配置相应的路由，那么自然就会返回一个404了！这也就是很多朋友在生产模式遇到404页面的原因。</p><p>那么很多人会问了，那为什么我在开发模式下没问题呢？那是因为<code>vue-cli</code>在开发模式下帮你启动的那个<code>express</code>开发服务器帮你做了这方面的配置。理论上在开发模式下本来也是需要配置服务端的，只不过<code>vue-cli</code>都帮你配置好了，所以你就不用手动配置了。</p><p>那么该如何配置呢？其实在生产模式下配置也很简单，参考vue-router给出的<a href="https://router.vuejs.org/zh-cn/essentials/history-mode.html" target="_blank" rel="noopener">配置例子</a>。一个原则就是，在所有后端路由规则的最后，配置一个规则，如果前面其他路由规则都不匹配的情况下，就执行这个规则——把构建好的那个<code>index.html</code>返回给前端。这样就解决了后端路由抛出的404的问题了，因为只要你输入了<code>http://localhost/user/1</code>这地址，那么由于后端其他路由都不匹配，那么就会返回给浏览器<code>index.html</code>。</p><p>浏览器拿到这个html之后，router库就开始工作，开始获取地址栏的URL信息，然后再告诉前端库（比如Vue）渲染对应的页面。到这一步就跟hash模式是类似的了。</p><p>当然，由于后端无法抛出404的页面错误，404的URL规则自然是交给前端路由来决定了。你可以自己在前端路由里决定什么URL都不匹配的404页面应该显示什么。</p><h2 id="前端路由与服务端渲染"><a href="#前端路由与服务端渲染" class="headerlink" title="前端路由与服务端渲染"></a>前端路由与服务端渲染</h2><p>虽然前端渲染有诸多好处，不过SEO的问题，还是比较突出的。所以react、vue等框架在后来也在服务端渲染上做着自己的努力。基于前端库的服务端渲染跟以前基于后端语言的服务端渲染又有所不同。前端框架的服务端渲染大多依然采用的是前端路由，并且由于引入了状态统一、vnode等等概念，它们的服务端渲染对服务器的性能要求比php等语言基于的字符串填充的模板引擎渲染对于服务器的性能要求高得多。所以在这方面不仅是框架本身在不断改进算法、优化，服务端的性能也必须要有所提升。当初掘金换成SSR的时候也遇到了对应的性能问题，就是这个原因。</p><p>当然在二者之间，也出现了预渲染的概念。也即先在服务端构建出一部分静态的html文件，用于直出浏览器。然后剩下的页面再通过常用的前端渲染来实现。通常我们可以把首页采用预渲染的方式。这个的好处是明显的，兼顾了SEO和服务器的性能要求。不过它无法做到全站SEO，生产构建阶段耗时也会有所提高，这也是遗憾所在。</p><p>关于预渲染，可以考虑使用<a href="https://github.com/chrisvfritz/prerender-spa-plugin" target="_blank" rel="noopener">prerender-spa-plugin</a>这个webapck的插件，它的3.x版本开始使用<strong>puppeteer</strong>来构建html文件了。</p><h2 id="前后端分离"><a href="#前后端分离" class="headerlink" title="前后端分离"></a>前后端分离</h2><p>得益于前端路由和现代前端框架的完整的前后端渲染能力，跟页面渲染、组织、组件相关的东西，后端终于可以不用再参与了。</p><p>前后端分离的开发模式也逐渐开始普及。前端开始更加注重页面开发的工程化、自动化，而后端则更专注于api的提供和数据库的保障。代码层面上耦合度也进一步降低，分工也更加明确。我们也摆脱了当初「刀耕火种」的web开发年代。撒花~</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>希望通过此文能够让你对于前后端路由和前后端渲染有所了解。在实际开发的过程中，也不应该仅仅关注于自己所在的领域，相关的领域也要有所涉猎，这样才能面对问题游刃有余。</p><blockquote><p>注：文中的图我使用OmniGraffle制作。转载请注明作者！</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近经常会遇到有人问诸如类似下面的问题：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;为啥我写的Vue应用在开发阶段都没问题，部署到服务端之后访问不了除了&lt;code&gt;/&lt;/code&gt;的页面呢&lt;/li&gt;&lt;li&gt;为啥我写的SPA页面的路由用hash模式都没问题，改成history模式就问题百出呢&lt;/li&gt;&lt;li&gt;啥是前端路由啥是后端路由，要怎么配后端才能支持我的前端路由呢&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这个问题是很多初学者会问的问题，于是结合我自己的学习经历也来简单的讲解一下这二者的区别与联系，希望能对你们有所帮助。&lt;/p&gt;&lt;p&gt;老手可以绕道，去看些更有用的文章吧~&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="https://molunerfinn.com/categories/Web/"/>
    
      <category term="开发" scheme="https://molunerfinn.com/categories/Web/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="前端" scheme="https://molunerfinn.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="后端" scheme="https://molunerfinn.com/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="笔记" scheme="https://molunerfinn.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Electron-vue开发实战3——跨平台的一些兼容措施</title>
    <link href="https://molunerfinn.com/electron-vue-4/"/>
    <id>https://molunerfinn.com/electron-vue-4/</id>
    <published>2018-03-20T14:40:00.000Z</published>
    <updated>2018-04-27T08:26:51.713Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间，我用<a href="https://github.com/SimulatedGREG/electron-vue" target="_blank" rel="noopener">electron-vue</a>开发了一款跨平台（目前支持Mac和Windows）的免费开源的图床上传应用——<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a>，在开发过程中踩了不少的坑，不仅来自应用的业务逻辑本身，也来自electron本身。在开发这个应用过程中，我学了不少的东西。因为我也是从0开始学习electron，所以很多经历应该也能给初学、想学electron开发的同学们一些启发和指示。故而写一份Electron的开发实战经历，用最贴近实际工程项目开发的角度来阐述。希望能帮助到大家。</p><p>预计将会从几篇系列文章或方面来展开：</p><ol><li><a href="https://molunerfinn.com/electron-vue-1/">electron-vue入门</a></li><li><a href="https://molunerfinn.com/electron-vue-2/">Main进程和Renderer进程的简单开发</a></li><li><a href="https://molunerfinn.com/electron-vue-3/">引入基于Lodash的JSON database——lowdb</a></li><li><a href="https://molunerfinn.com/electron-vue-4/">跨平台的一些兼容措施</a></li><li>通过CI发布以及更新的方式</li><li>…（想到再写）</li></ol><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p><code>PicGo</code>是采用<code>electron-vue</code>开发的，所以如果你会<code>vue</code>，那么跟着一起来学习将会比较快。如果你的技术栈是其他的诸如<code>react</code>、<code>angular</code>，那么纯按照本教程虽然在render端（可以理解为页面）的构建可能学习到的东西不多，不过在main端（electron的主进程）应该还是能学习到相应的知识的。</p><p>如果之前的文章没阅读的朋友可以先从之前的文章跟着看。</p><a id="more"></a><h2 id="跨平台的重要性"><a href="#跨平台的重要性" class="headerlink" title="跨平台的重要性"></a>跨平台的重要性</h2><p>虽然electron在大多数情况下的跨平台措施已经帮我们做得很好了。不过需要注意的是，不同平台必然存在细节上的差异。我们在书写跨平台应用的时候，如果只在自己书写平台下测试通过的话是不足以说明我们的应用是健壮的。（当然如果你只想提供给某个平台那另当别论）所以针对不同的发布平台，就需要做一些兼容性措施。</p><p>就我自己的感受而言，macOS平台支持的特性相对比较多，而这里面又很多是独有的，所以很多能在macOS上实现的功能却不一定能在windows上实现。所以对于windows用户而言，在保证整体应用的可用性的情况下，就有可能要相应地做一些妥协和牺牲。不过在windows上的一些操作习惯也可以反过来服务于macOS平台。这点我会在下面给出一个例子详细说明。</p><h2 id="留意不同平台的独有功能"><a href="#留意不同平台的独有功能" class="headerlink" title="留意不同平台的独有功能"></a>留意不同平台的独有功能</h2><p>在开发electron应用的时候，很多时候我们只注意去查找api名，却容易忽视这个api能够使用的平台。在官方文档里，对于一些独占的api，大多都会有标识标出：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fpifmc1muoj21mo0ti0wa.jpg" alt=""></p><p>不过需要注意的是一些未有平台标识的api里的配置项，也有可能是某个平台的独占：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fpifrhg1r8j21k804w0tt.jpg" alt=""></p><p>平时开发的过程中，用到文档的地方还是需要细细留心，避免后续不必要的麻烦。</p><h2 id="跨平台措施入门"><a href="#跨平台措施入门" class="headerlink" title="跨平台措施入门"></a>跨平台措施入门</h2><p>上面讲了这么多，该到实例的时候了。在electron应用中，通常来说<code>renderer</code>进程的东西不需要做太多的跨平台措施——毕竟不管是哪个平台，都是跑在Chrome里的页面。所以大多数情况下，这个方面的工作会放在<code>main</code>进程里。不过也有例外：</p><h3 id="title-bar的操作区处理"><a href="#title-bar的操作区处理" class="headerlink" title="title-bar的操作区处理"></a>title-bar的操作区处理</h3><p>下面是PicGo的windows版：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fpig60gzw6j20m80ciwf1.jpg" alt=""></p><p>下面是PicGo的macOS版：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fpig71431kj218g0p0tav.jpg" alt=""></p><p>可以发现除了颜色有些区别之外，顶部的<code>title-bar</code>操作栏也有些区别。macOS的程序窗口习惯将窗口的缩放、关闭按钮放在窗口的左上角。而windows程序则相反，它们喜欢放在窗口的右上角。所以为了迎合用户的操作习惯，我们在开发electron程序的时候也应该注意到这一点。</p><p>当然，如果是通过普通的<code>BrowserWindow</code>创建的窗口，那么将会自动拥有常见的macOS、windows的顶部栏，以及默认的样式。</p><p>我在这里想说的是如果想要更加美观的界面，通常我们喜欢「沉浸式」的顶部栏。对于macOS而言，沉浸式的顶部栏就是将顶部栏的三个操作按钮直接「嵌入」窗口主题的左上角。而对于windows而言，只能删去顶部的三个操作按钮，自己用前端的方式来实现了。所以这个地方两个平台的差异性就出来了。</p><p>在<code>main</code>进程里创建该窗口的时候，主要代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> createSettingWindow = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> options = &#123;</span><br><span class="line">    height: <span class="number">450</span>,</span><br><span class="line">    width: <span class="number">800</span>,</span><br><span class="line">    show: <span class="literal">false</span>, <span class="comment">// 当window创建的时候不用打开</span></span><br><span class="line">    center: <span class="literal">true</span>,</span><br><span class="line">    fullscreenable: <span class="literal">false</span>,</span><br><span class="line">    resizable: <span class="literal">false</span>,</span><br><span class="line">    title: <span class="string">'PicGo'</span>,</span><br><span class="line">    vibrancy: <span class="string">'ultra-dark'</span>, <span class="comment">// 窗口模糊的样式</span></span><br><span class="line">    transparent: <span class="literal">true</span>,</span><br><span class="line">    titleBarStyle: <span class="string">'hidden'</span>, <span class="comment">// title-bar的样式——隐藏顶部栏的横条，把操作按钮嵌入窗口</span></span><br><span class="line">    webPreferences: &#123;</span><br><span class="line">      backgroundThrottling: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (process.platform === <span class="string">'win32'</span>) &#123; <span class="comment">// 如果平台是win32，也即windows</span></span><br><span class="line">    options.show = <span class="literal">true</span> <span class="comment">// 当window创建的时候打开</span></span><br><span class="line">    options.frame = <span class="literal">false</span> <span class="comment">// 创建一个frameless窗口，详情：https://electronjs.org/docs/api/frameless-window</span></span><br><span class="line">    options.backgroundColor = <span class="string">'#3f3c37'</span></span><br><span class="line">  &#125;</span><br><span class="line">  settingWindow = <span class="keyword">new</span> BrowserWindow(options)</span><br><span class="line"></span><br><span class="line">  settingWindow.loadURL(settingWinURL)</span><br><span class="line"></span><br><span class="line">  settingWindow.on(<span class="string">'closed'</span>, () =&gt; &#123;</span><br><span class="line">    settingWindow = <span class="literal">null</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要的工具是通过<code>process.platform</code>来判断不同的平台。当前可能的值有：</p><ul><li>‘aix’</li><li>‘darwin’</li><li>‘freebsd’</li><li>‘linux’</li><li>‘openbsd’</li><li>‘sunos’</li><li>‘win32’</li></ul><p>在这里我们基本上只需要关心<code>darwin</code>（macOS）、<code>win32</code>（windows）、<code>linux</code>（Linux）这三个平台即可。注意，由于electron的对于<code>renderer</code>进程的加持，在<code>renderer</code>进程里也能直接使用<code>process.platform</code>来判断当前的操作系统。这是一个很方便的特性。</p><p>针对windows平台，由于采用了<a href="https://electronjs.org/docs/api/frameless-window" target="_blank" rel="noopener">frameless-window</a>，所以我们需要手动「绘制」顶部的缩放和关闭按钮，并配上相应的事件来模拟真实的按钮。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"fake-title-bar"</span>&gt;</span></span><br><span class="line">  PicGo - &#123;&#123; version &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"handle-bar"</span> <span class="attr">v-if</span>=<span class="string">"process.platform === 'win32'"</span>&gt;</span><span class="comment">&lt;!-- 如果是windows平台 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"el-icon-minus"</span> @<span class="attr">click</span>=<span class="string">"minimizeWindow"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"el-icon-close"</span> @<span class="attr">click</span>=<span class="string">"closeWindow"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>相应的事件如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">minimizeWindow () &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">window</span> = BrowserWindow.getFocusedWindow()</span><br><span class="line">  <span class="built_in">window</span>.minimize()</span><br><span class="line">&#125;,</span><br><span class="line">closeWindow () &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">window</span> = BrowserWindow.getFocusedWindow()</span><br><span class="line">  <span class="built_in">window</span>.close()</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>简单来说就是调用了<code>BrowserWindow</code>的方法来获取当前激活的窗口，然后再对这个窗口进行缩小或关闭的操作。其实也不难对吧！</p><h3 id="任务栏图标交互"><a href="#任务栏图标交互" class="headerlink" title="任务栏图标交互"></a>任务栏图标交互</h3><p>针对不同的平台，我对PicGo的任务栏图标交互也有所区别。对于macOS而言，点击顶部菜单栏的时候会弹出一个小窗口：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fma907llb5j20m30ed46a" alt=""></p><p>由于macOS的顶部栏图标可以接受拖拽事件，所以就针对macOS的顶部栏制作了顶部栏图标对应的小窗口。让大部分操作不经过主窗口也能实现。而对于windows而言，没有顶部栏，取而代之的是位于底部栏的右侧的任务栏，通常点击任务栏里的图标就会把应用的主窗口调出来。所以为了迎合不同平台的操作习惯，我对于这个地方也做了相应的兼容性适配：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">tray.on(<span class="string">'click'</span>, () =&gt; &#123; <span class="comment">// 不管是顶部栏的图标还是任务栏的图标都是Tray组件生成的</span></span><br><span class="line">  <span class="keyword">if</span> (process.platform === <span class="string">'darwin'</span>) &#123; <span class="comment">// 如果是macOS平台</span></span><br><span class="line">    <span class="keyword">let</span> img = clipboard.readImage()</span><br><span class="line">    <span class="keyword">let</span> obj = []</span><br><span class="line">    <span class="keyword">if</span> (!img.isEmpty()) &#123;</span><br><span class="line">      <span class="comment">// 从剪贴板来的图片默认转为png</span></span><br><span class="line">      <span class="keyword">const</span> imgUrl = <span class="string">'data:image/png;base64,'</span> + Buffer.from(img.toPNG(), <span class="string">'binary'</span>).toString(<span class="string">'base64'</span>)</span><br><span class="line">      obj.push(&#123;</span><br><span class="line">        width: img.getSize().width,</span><br><span class="line">        height: img.getSize().height,</span><br><span class="line">        imgUrl</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    toggleWindow() <span class="comment">// 打开小窗口</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">window</span>.webContents.send(<span class="string">'clipboardFiles'</span>, obj)</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.hide()</span><br><span class="line">    <span class="keyword">if</span> (settingWindow === <span class="literal">null</span>) &#123; <span class="comment">// 如果主窗口未创建</span></span><br><span class="line">      createSettingWindow() <span class="comment">// 创建</span></span><br><span class="line">      settingWindow.show() <span class="comment">// 并打开</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      settingWindow.show() <span class="comment">// 如果已存在，打开</span></span><br><span class="line">      settingWindow.focus() <span class="comment">// 并激活</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="窗口关闭与应用退出"><a href="#窗口关闭与应用退出" class="headerlink" title="窗口关闭与应用退出"></a>窗口关闭与应用退出</h3><p>在windows平台上，通常我们把应用的窗口都关了之后也就默认把这个应用给退出了。而如果在macOS系统上却不是这样。我们把应用的窗口关闭了，但是并非完全退出这个应用。所以为了实现这个操作习惯，我们也可以增加一个情况判断：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.on(<span class="string">'window-all-closed'</span>, () =&gt; &#123; <span class="comment">// 当窗口都被关闭了</span></span><br><span class="line">  <span class="keyword">if</span> (process.platform !== <span class="string">'darwin'</span>) &#123; <span class="comment">// 如果不是macOS</span></span><br><span class="line">    app.quit() <span class="comment">// 应用退出</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文简要地讲述了electron应用在跨平台开发的时候的一些注意事项。可能很多人会觉得奇怪我为啥把这个章节单独拎出来讲。很多时候我们只关注于应用的开发过程，把应用的功能实现是很多情况下的「终极」目标。然而真实情况是，应用的功能实现只是「基本」目标。一个应用要给用户使用的话必然不仅要考虑到应用的功能，还必须考虑用户的使用习惯。要站在用户的角度来做应用。而不是做自嗨型的应用。所以这篇文章也希望能够帮助想要开发electron应用的你。</p><p>本文很多都是我在开发<code>PicGo</code>的时候碰到的问题、踩的坑。也许文中简单的几句话背后就是我无数次的查阅和调试。希望这篇文章能够给你的<code>electron-vue</code>开发带来一些启发。文中相关的代码，你都可以在<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a>的项目仓库里找到，欢迎star~如果本文能够给你带来帮助，那么将是我最开心的地方。如果喜欢，欢迎关注我的<a href="https://molunerfinn.com">博客</a>以及本系列文章的后续进展。</p><blockquote><p><strong>注：文中的图片除未特地说明之外均属于我个人作品，需要转载请私信</strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前段时间，我用&lt;a href=&quot;https://github.com/SimulatedGREG/electron-vue&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;electron-vue&lt;/a&gt;开发了一款跨平台（目前支持Mac和Windows）的免费开源的图床上传应用——&lt;a href=&quot;https://github.com/Molunerfinn/PicGo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PicGo&lt;/a&gt;，在开发过程中踩了不少的坑，不仅来自应用的业务逻辑本身，也来自electron本身。在开发这个应用过程中，我学了不少的东西。因为我也是从0开始学习electron，所以很多经历应该也能给初学、想学electron开发的同学们一些启发和指示。故而写一份Electron的开发实战经历，用最贴近实际工程项目开发的角度来阐述。希望能帮助到大家。&lt;/p&gt;&lt;p&gt;预计将会从几篇系列文章或方面来展开：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-1/&quot;&gt;electron-vue入门&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-2/&quot;&gt;Main进程和Renderer进程的简单开发&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-3/&quot;&gt;引入基于Lodash的JSON database——lowdb&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-4/&quot;&gt;跨平台的一些兼容措施&lt;/a&gt;&lt;/li&gt;&lt;li&gt;通过CI发布以及更新的方式&lt;/li&gt;&lt;li&gt;…（想到再写）&lt;/li&gt;&lt;/ol&gt;&lt;h2 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h2&gt;&lt;p&gt;&lt;code&gt;PicGo&lt;/code&gt;是采用&lt;code&gt;electron-vue&lt;/code&gt;开发的，所以如果你会&lt;code&gt;vue&lt;/code&gt;，那么跟着一起来学习将会比较快。如果你的技术栈是其他的诸如&lt;code&gt;react&lt;/code&gt;、&lt;code&gt;angular&lt;/code&gt;，那么纯按照本教程虽然在render端（可以理解为页面）的构建可能学习到的东西不多，不过在main端（electron的主进程）应该还是能学习到相应的知识的。&lt;/p&gt;&lt;p&gt;如果之前的文章没阅读的朋友可以先从之前的文章跟着看。&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="https://molunerfinn.com/categories/Web/"/>
    
      <category term="开发" scheme="https://molunerfinn.com/categories/Web/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="前端" scheme="https://molunerfinn.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Vue" scheme="https://molunerfinn.com/tags/Vue/"/>
    
      <category term="Electron" scheme="https://molunerfinn.com/tags/Electron/"/>
    
      <category term="Electron-vue" scheme="https://molunerfinn.com/tags/Electron-vue/"/>
    
  </entry>
  
  <entry>
    <title>hexo-theme-melody v1.5 supports slides &amp; iframe</title>
    <link href="https://molunerfinn.com/slide-support/"/>
    <id>https://molunerfinn.com/slide-support/</id>
    <published>2018-03-06T19:57:52.000Z</published>
    <updated>2018-04-27T08:26:51.717Z</updated>
    
    <content type="html"><![CDATA[<h2 id="hexo-theme-melody-v1-5"><a href="#hexo-theme-melody-v1-5" class="headerlink" title="hexo-theme-melody v1.5"></a>hexo-theme-melody <small>v1.5</small></h2><p>Supports iframe &amp; slides. You can use a layout called <code>slides</code> to enabled the slides layout.</p><p>Also you can add a <code>iframe</code> front-matter with the <code>slides</code> layout in your <code>md</code> file to enable the iframe page.</p><p>===</p><h2 id="Steps"><a href="#Steps" class="headerlink" title="Steps"></a>Steps</h2><h3 id="1-Add-a-slides-page"><a href="#1-Add-a-slides-page" class="headerlink" title="1. Add a slides page"></a>1. Add a slides page</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo new page slides</span><br><span class="line"><span class="built_in">cd</span> ./<span class="built_in">source</span>/slides</span><br></pre></td></tr></table></figure><p>===</p><h3 id="2-Add-the-layout-type"><a href="#2-Add-the-layout-type" class="headerlink" title="2. Add the layout type"></a>2. Add the layout type</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim index.md</span><br></pre></td></tr></table></figure><p>Add a type called <code>slides</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">slides</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2018</span><span class="bullet">-03</span><span class="bullet">-06</span> <span class="number">20</span><span class="string">:24:48</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">slides</span></span><br></pre></td></tr></table></figure><p>===</p><h3 id="3-Modified-the-melody-yml"><a href="#3-Modified-the-melody-yml" class="headerlink" title="3. Modified the melody.yml"></a>3. Modified the melody.yml</h3><p>Add slides default config:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">slide:</span></span><br><span class="line"><span class="attr">  separator:</span> <span class="string">whatever</span> <span class="string">you</span> <span class="string">like</span></span><br><span class="line"><span class="attr">  separator_vertical:</span> <span class="string">whatever</span> <span class="string">you</span> <span class="string">like</span></span><br><span class="line"><span class="attr">  charset:</span> <span class="string">utf-8</span></span><br><span class="line"><span class="attr">  theme:</span> <span class="string">black</span></span><br><span class="line"><span class="attr">  mouseWheel:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  transition:</span> <span class="string">slide</span></span><br><span class="line"><span class="attr">  transitionSpeed:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">  parallaxBackgroundImage:</span> <span class="string">''</span></span><br><span class="line"><span class="attr">  parallaxBackgroundSize:</span> <span class="string">''</span></span><br><span class="line"><span class="attr">  parallaxBackgroundHorizontal:</span> <span class="literal">null</span></span><br><span class="line"><span class="attr">  parallaxBackgroundVertical:</span> <span class="literal">null</span></span><br></pre></td></tr></table></figure><blockquote><p>See reveal.js <a href="https://github.com/hakimel/reveal.js#configuration" target="_blank" rel="noopener">config</a></p></blockquote><p>===</p><h3 id="4-Write-a-md-file-with-slides-layout"><a href="#4-Write-a-md-file-with-slides-layout" class="headerlink" title="4. Write a md file with slides layout"></a>4. Write a md file with slides layout</h3><p>In <code>_posts</code> folder, add a <code>md</code> file.</p><p>For example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">title: hexo-theme-melody v1.5 supports iframe &amp; slides</span><br><span class="line">date: 2018-03-06 19:57:52</span><br><span class="line">layout: slides</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">// balalala...</span><br></pre></td></tr></table></figure><p>Then you will get a post of slides type.</p><p>===</p><h2 id="Slides-layout-with-iframe"><a href="#Slides-layout-with-iframe" class="headerlink" title="Slides layout with iframe"></a>Slides layout with iframe</h2><p>If you want to add a website whatever you like within an iframe, try this:</p><p>In <code>_posts</code> folder, add a <code>md</code> file.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">title: hexo-theme-melody v1.5 supports iframe &amp; slides</span><br><span class="line">date: 2018-03-06 19:57:52</span><br><span class="line">layout: slides</span><br><span class="line">iframe: https://the-url-whatever-you-like</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>Then you will get a post of iframe.</p><p>===</p><h2 id="Configurate-single-slides-in-md"><a href="#Configurate-single-slides-in-md" class="headerlink" title="Configurate single slides in md"></a>Configurate single slides in md</h2><p>The slides config in <code>meldoy.yml</code> can change whole slides page.</p><p>But if you set the config in the md file, it will effect the single page.</p><p>==</p><p>For example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">title: hexo-theme-melody v1.5 supports iframe &amp; slides</span><br><span class="line">date: 2018-03-06 19:57:52</span><br><span class="line">layout: slides</span><br><span class="line">slide:</span><br><span class="line">  theme: white</span><br><span class="line">  transition: zoom</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">// balalala...</span><br></pre></td></tr></table></figure><p>===</p><h1 id="Enjoy"><a href="#Enjoy" class="headerlink" title="Enjoy!"></a>Enjoy!</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;hexo-theme-melody-v1-5&quot;&gt;&lt;a href=&quot;#hexo-theme-melody-v1-5&quot; class=&quot;headerlink&quot; title=&quot;hexo-theme-melody v1.5&quot;&gt;&lt;/a&gt;hexo-theme-melody &lt;s
      
    
    </summary>
    
      <category term="Web" scheme="https://molunerfinn.com/categories/Web/"/>
    
      <category term="开发" scheme="https://molunerfinn.com/categories/Web/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="hexo" scheme="https://molunerfinn.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>用新版的Chrome把PWA网站添加到桌面，获得媲美原生应用的体验</title>
    <link href="https://molunerfinn.com/PC-Chrome-PWA/"/>
    <id>https://molunerfinn.com/PC-Chrome-PWA/</id>
    <published>2018-03-03T16:12:00.000Z</published>
    <updated>2018-04-27T08:26:51.709Z</updated>
    
    <content type="html"><![CDATA[<p><strong>2018.03.06 更新：</strong>非PWA网站也能通过独立窗口而非浏览器打开。具体看「注意事项」。</p><h2 id="PWA是什么"><a href="#PWA是什么" class="headerlink" title="PWA是什么"></a>PWA是什么</h2><p>引用自<a href="http://harttle.land/2017/01/28/pwa-explore.html" target="_blank" rel="noopener">Harttle.Land</a>的说法：</p><blockquote><p><a href="https://developers.google.com/web/progressive-web-apps/" target="_blank" rel="noopener">PWA</a>(Progressive Web Apps)是 Google 最近在提的一种 Web App 形态 （或者如 Wikipedia 所称的“软件开发方法”）。 Harttle 能找到的关于 PWA 最早的一篇文章是 2015年6月 Alex Russell 的一篇博客： <a href="https://infrequently.org/2015/06/progressive-apps-escaping-tabs-without-losing-our-soul/" target="_blank" rel="noopener">Progressive apps escaping tabs without losing our soul</a>， <strong>让 Web App 从标签页跳出来，同时保持 Web 的灵魂。</strong></p></blockquote><blockquote><p>如 Alex 所述，PWA 意图让 Web 在保留其本质（开放平台、易于访问、可索引）的同时， 在离线、交互、通知等方面达到类似 App 的用户体验。按 <a href="https://developers.google.com/web/progressive-web-apps/" target="_blank" rel="noopener">Google 官方的解释</a> PWA 具有这些特性：Reliable, Fast, Engaging。</p></blockquote><p>它比原生应用更轻量，但是却比现有的Web APP的功能更加丰富。最大也是最关键的区别是它能够脱离浏览器的「束缚」（虽然依然是基于浏览器的技术），能够把PWA网站添加到你的桌面上，不管是PC操作系统还是手机操作系统，类似于一个原生应用一样，并且拥有媲美原生应用的体验。</p><p>它也能拥有原生APP应用一般的启动闪屏，它也能像原生APP应用一般能有消息推送——不过要知道，它源自Web，通常只有传统APP的体积的十分之一甚至更小。它不用等待下载安装的时间，打开网页的时候就已经「下载」并且「安装」完毕。</p><p>要想体验这项技术，如果你是安卓用户，那最新版的Chrome已经支持；如果你是iOS用户，可以等待3月份的11.3版本更新；如果你是PC电脑用户，那么来看看怎么在电脑上也体验体验PWA吧。</p><a id="more"></a><h2 id="配置Chrome"><a href="#配置Chrome" class="headerlink" title="配置Chrome"></a>配置Chrome</h2><p>首先更新你的Chrome版本到64或以上。</p><p>然后在地址栏输入<code>chrome://flags</code>，找到<code>Desktop PWAs</code>的选项将其<code>Enabled</code>了，然后Chrome会提示你重启浏览器。</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fozgv6nxloj20l7050q37" alt=""></p><p>重启浏览器后，PWA添加到桌面的特性就已经具备了。</p><h2 id="将PWA网站添加到桌面"><a href="#将PWA网站添加到桌面" class="headerlink" title="将PWA网站添加到桌面"></a>将PWA网站添加到桌面</h2><p>我这里使用的是我的<a href="https://molunerfinn.com">博客</a>（基于自己写的<a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener">hexo-theme-melody</a>主题搭建的）。打开网站，然后在浏览器右侧找到设置的按钮。接下去我针对Windows平台和macOS平台做分开讲解。</p><h3 id="Windows平台"><a href="#Windows平台" class="headerlink" title="Windows平台"></a>Windows平台</h3><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1foznbd9gcdj20x10iw4mx" alt=""></p><p>Windows平台找到<code>添加到桌面</code>这个按钮，点击，然后会出现一个确认框：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1foznebsdhvj20w50gwhba" alt=""></p><p>点击添加。然后你就可以在桌面上看到相应的图标：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fozng6ajhhj20bq09hwj9" alt=""></p><p>双击打开：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1foznhijnsdj20q30gjx1u" alt=""></p><p>你会发现打开了一个没有浏览器痕迹的网页，或者说是个应用——这就是PWA了。PWA支持离线启动技术，即使在没网的情况下也能启动应用。不过在需要网络条件下才能发送的请求依然需要网络环境。</p><h3 id="macOS平台"><a href="#macOS平台" class="headerlink" title="macOS平台"></a>macOS平台</h3><p>相对于Windows平台比较简单的操作，macOS平台的操作相对有点绕弯，不过也大致相同。macOS的Chrome无法一次性就把PWA应用添加到桌面。需要先把PWA网站生成一个app应用，然后你再手动把这个app应用以快捷方式复制到桌面。</p><p>接下来是具体步骤：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fozny8dva4j20zk0m81kx" alt=""></p><p>打开一个PWA网站，此处依然以我的<a href="https://molunerfinn.com">博客</a>作为例子，然后再右侧找到配置菜单，下拉选中<code>添加到“应用”文件夹</code>。然后等待几秒钟，会出现一个对话框：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fozo1ww7ubj20zj0cnx29" alt=""></p><p>此时这个PWA应用已经生成完毕了。我们点击添加。之后你就可以在你的应用列表看到它了：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fozo2gf2xij20zk0m8qcm" alt=""></p><p>不过如果你要在你的桌面上添加这个应用的话，还需要找到这个app的位置，一般是在<code>/Users/你的用户名/Applications/Chrome\ Apps.localized/</code>这个文件夹下。用finder打开：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fozo545tmij20h50470tp" alt=""></p><p>然后选中这个应用，按住<code>alt+command</code>键把它拖拽到桌面上，就会生成一个快捷方式啦。这个方法也同样适用于其他应用。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>如果是非PWA应用，也会有<code>添加到桌面</code>或者<code>添加到应用文件夹</code>的选项。不过当你双击打开它们的时候依然会调用Chrome浏览器去打开，跟以前的书签的作用无差别。</p><p><strong>不过</strong>，依然可以通过一个小操作来实现。感谢@<a href="https://weibo.com/5319395630" target="_blank" rel="noopener">RiiSan</a>指出我原文的错误。</p><p>前置步骤跟之前说的一样，然后打开<code>chrome://apps</code>，找到你制作的应用，然后右键，选择<code>在窗口中打开</code>。那么就能获得跟PWA应用单独窗口的类似体验。不过它是不具备PWA离线打开的能力哦，只是纯粹的一个网页通过独立窗口打开而已。</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fp32grp8nmj21ns0s8k4a" alt=""></p><p>目前<code>Desktop PWAs</code>还是实验性的功能，所以有可能出现不稳定的情况，依照自己的情况作出决定~</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>就目前来说，我能想到的比较理想的使用条件是，在一些功能性网站支持PWA的情况下，是不用再去下它们的桌面客户端了，直接通过PWA添加到桌面，就能像使用原生应用一样使用它们啦。比如推特，比如Medium等。</p><p>下面给出一个别人总结的PWA网站列表，可以去体验一波~</p><p><a href="https://github.com/hemanth/awesome-pwa" target="_blank" rel="noopener">https://github.com/hemanth/awesome-pwa</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;2018.03.06 更新：&lt;/strong&gt;非PWA网站也能通过独立窗口而非浏览器打开。具体看「注意事项」。&lt;/p&gt;&lt;h2 id=&quot;PWA是什么&quot;&gt;&lt;a href=&quot;#PWA是什么&quot; class=&quot;headerlink&quot; title=&quot;PWA是什么&quot;&gt;&lt;/a&gt;PWA是什么&lt;/h2&gt;&lt;p&gt;引用自&lt;a href=&quot;http://harttle.land/2017/01/28/pwa-explore.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Harttle.Land&lt;/a&gt;的说法：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://developers.google.com/web/progressive-web-apps/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PWA&lt;/a&gt;(Progressive Web Apps)是 Google 最近在提的一种 Web App 形态 （或者如 Wikipedia 所称的“软件开发方法”）。 Harttle 能找到的关于 PWA 最早的一篇文章是 2015年6月 Alex Russell 的一篇博客： &lt;a href=&quot;https://infrequently.org/2015/06/progressive-apps-escaping-tabs-without-losing-our-soul/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Progressive apps escaping tabs without losing our soul&lt;/a&gt;， &lt;strong&gt;让 Web App 从标签页跳出来，同时保持 Web 的灵魂。&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;如 Alex 所述，PWA 意图让 Web 在保留其本质（开放平台、易于访问、可索引）的同时， 在离线、交互、通知等方面达到类似 App 的用户体验。按 &lt;a href=&quot;https://developers.google.com/web/progressive-web-apps/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Google 官方的解释&lt;/a&gt; PWA 具有这些特性：Reliable, Fast, Engaging。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;它比原生应用更轻量，但是却比现有的Web APP的功能更加丰富。最大也是最关键的区别是它能够脱离浏览器的「束缚」（虽然依然是基于浏览器的技术），能够把PWA网站添加到你的桌面上，不管是PC操作系统还是手机操作系统，类似于一个原生应用一样，并且拥有媲美原生应用的体验。&lt;/p&gt;&lt;p&gt;它也能拥有原生APP应用一般的启动闪屏，它也能像原生APP应用一般能有消息推送——不过要知道，它源自Web，通常只有传统APP的体积的十分之一甚至更小。它不用等待下载安装的时间，打开网页的时候就已经「下载」并且「安装」完毕。&lt;/p&gt;&lt;p&gt;要想体验这项技术，如果你是安卓用户，那最新版的Chrome已经支持；如果你是iOS用户，可以等待3月份的11.3版本更新；如果你是PC电脑用户，那么来看看怎么在电脑上也体验体验PWA吧。&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="https://molunerfinn.com/categories/Web/"/>
    
      <category term="开发" scheme="https://molunerfinn.com/categories/Web/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="前端" scheme="https://molunerfinn.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="PWA" scheme="https://molunerfinn.com/tags/PWA/"/>
    
  </entry>
  
  <entry>
    <title>Electron-vue开发实战2——引入基于Lodash的JSON数据库lowdb</title>
    <link href="https://molunerfinn.com/electron-vue-3/"/>
    <id>https://molunerfinn.com/electron-vue-3/</id>
    <published>2018-02-12T21:04:00.000Z</published>
    <updated>2018-04-27T08:26:51.713Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间，我用<a href="https://github.com/SimulatedGREG/electron-vue" target="_blank" rel="noopener">electron-vue</a>开发了一款跨平台（目前支持Mac和Windows）的免费开源的图床上传应用——<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a>，在开发过程中踩了不少的坑，不仅来自应用的业务逻辑本身，也来自electron本身。在开发这个应用过程中，我学了不少的东西。因为我也是从0开始学习electron，所以很多经历应该也能给初学、想学electron开发的同学们一些启发和指示。故而写一份Electron的开发实战经历，用最贴近实际工程项目开发的角度来阐述。希望能帮助到大家。</p><p>预计将会从几篇系列文章或方面来展开：</p><ol><li><a href="https://molunerfinn.com/electron-vue-1/">electron-vue入门</a></li><li><a href="https://molunerfinn.com/electron-vue-2/">Main进程和Renderer进程的简单开发</a></li><li><a href="https://molunerfinn.com/electron-vue-3/">引入基于Lodash的JSON database——lowdb</a></li><li>跨平台的一些兼容措施</li><li>通过CI发布以及更新的方式</li><li>…（想到再写）</li></ol><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p><code>PicGo</code>是采用<code>electron-vue</code>开发的，所以如果你会<code>vue</code>，那么跟着一起来学习将会比较快。如果你的技术栈是其他的诸如<code>react</code>、<code>angular</code>，那么纯按照本教程虽然在render端（可以理解为页面）的构建可能学习到的东西不多，不过在main端（electron的主进程）应该还是能学习到相应的知识的。</p><p>如果之前的文章没阅读的朋友可以先从之前的文章跟着看。</p><a id="more"></a><h2 id="数据持久化存储的必要性"><a href="#数据持久化存储的必要性" class="headerlink" title="数据持久化存储的必要性"></a>数据持久化存储的必要性</h2><p>不像平时很多人写的一些demo，就是请求一下api然后把web页面展示出来就了事了。electron应用毕竟是个桌面级应用，如果思维还留在纯web开发的思路上，那么也就失去了用electron的意义了吧。</p><p>数据持久化存储实际上对于后端很熟悉。通常是指的是把内存里的数据以不同的存储模型存储到磁盘上，在需要的时候再从存储模型里读取读入内存中的整个流程。这里面的存储模型通常就是我们熟悉的数据库。说到数据库，很多人会想到MySQL，Mongodb，SQLite等等。常见的这些数据库都是Server-Client模式的，需要启动服务端——通常我们装的就是这个。但是你一般很少见到叫别人装个桌面软件的同时，叫别人配数据库的吧。</p><p>因为有些数据我们必须在本地存下来，方便下次使用的时候读取。而对于electron来说，既然让用户装MySQL、Mongodb是不太优雅的解决办法的话，那么如果能用其他方式，将数据存到本地而不用用户操心如何存储的，对我们和用户来说都是一件好事。</p><h2 id="纯JavaScript数据库的选择"><a href="#纯JavaScript数据库的选择" class="headerlink" title="纯JavaScript数据库的选择"></a>纯JavaScript数据库的选择</h2><p>既然是JS技术栈的，于是我就找了一些纯JavaScript实现的数据库。经过初步筛选，我找到如下两个：</p><ol><li><a href="https://github.com/louischatriot/nedb" target="_blank" rel="noopener">nedb</a> 7800star（2018-02-12）</li><li><a href="https://github.com/typicode/lowdb" target="_blank" rel="noopener">lowdb</a> 7269star（2018-02-12）</li></ol><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>其中就目前来看，nedb用的更为广泛，star数更多（截止2018-02-12），而且有很多讲到nedb和electron配合使用的文章。不过，nedb已经有快两年没有维护了，而且原生不支持Promise，采用的是异步回调（虽然可以通过第三方插件实现Promise）。</p><p>lowdb是用JSON为基本存储结构基于lodash开发的，有lodash的加持，用起来很顺手。优势在于它在持续的维护，有不少好用的插件。并且很关键的是同步操作，采用链式调用的写法，写起来有种jQuery的感觉。再者，用JSON存储的数据，不管是调用还是备份都很方便，这也是让我很喜欢的一点。</p><p>综上，PicGo采用的是lowdb。</p><h2 id="lowdb的初始化"><a href="#lowdb的初始化" class="headerlink" title="lowdb的初始化"></a>lowdb的初始化</h2><p>由于electron给main进程和renderer进程都置入了Node的<code>fs</code>模块，所以我们可以很方便的在两端都使用跟<code>fs</code>相关的操作。而lowdb本质上就是通过<code>fs</code>来读写JSON文件实现的，正好符合我们的要求。所以根据官方给出的文档，我们首先先初始化一下。</p><p><strong>为了操作<code>fs</code>更方便，不妨安装一个<a href="https://github.com/jprichardson/node-fs-extra" target="_blank" rel="noopener">fs-extra</a>。</strong></p><p>创建一个<code>datastore.js</code>文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Datastore <span class="keyword">from</span> <span class="string">'lowdb'</span></span><br><span class="line"><span class="keyword">import</span> FileSync <span class="keyword">from</span> <span class="string">'lowdb/adapters/FileSync'</span></span><br><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">'path'</span></span><br><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">'fs-extra'</span></span><br><span class="line"><span class="keyword">import</span> &#123; app &#125; <span class="keyword">from</span> <span class="string">'electron'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> STORE_PATH = app.getPath(<span class="string">'userData'</span>) <span class="comment">// 获取electron应用的用户目录</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> adapter = <span class="keyword">new</span> FileSync(path.join(STORE_PATH, <span class="string">'/data.json'</span>)) <span class="comment">// 初始化lowdb读写的json文件名以及存储路径</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> db = Datastore(adapter) <span class="comment">// lowdb接管该文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> db <span class="comment">// 暴露出去</span></span><br></pre></td></tr></table></figure><p>接着我们在main进程和renderer进程里就可以这样引入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> db <span class="keyword">from</span> <span class="string">'../datastore'</span> <span class="comment">// 取决于你的datastore.js的位置</span></span><br></pre></td></tr></table></figure><h3 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h3><p>如果仅仅是上面的基本操作，那么这篇文章未免也太简单了。关于electron引入lowdb的踩坑之路现在才开始。</p><h4 id="1-renderer进程要使用remote模块"><a href="#1-renderer进程要使用remote模块" class="headerlink" title="1. renderer进程要使用remote模块"></a>1. renderer进程要使用remote模块</h4><p>首先由上面的初始化能明显看到一个问题。<code>app</code>模块是main进程里特有的，renderer进程应该使用<code>remote.app</code>模块。所以上面的代码在<code>renderer</code>进程里会报错。</p><p>因此第一次修改，使其既能跑在main进程也能跑在renderer进程：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Datastore <span class="keyword">from</span> <span class="string">'lowdb'</span></span><br><span class="line"><span class="keyword">import</span> FileSync <span class="keyword">from</span> <span class="string">'lowdb/adapters/FileSync'</span></span><br><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">'path'</span></span><br><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">'fs-extra'</span></span><br><span class="line"><span class="keyword">import</span> &#123; app, remote &#125; <span class="keyword">from</span> <span class="string">'electron'</span> <span class="comment">// 引入remote模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> APP = process.type === <span class="string">'renderer'</span> ? remote.app : app <span class="comment">// 根据process.type来分辨在哪种模式使用哪种模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> STORE_PATH = APP.getPath(<span class="string">'userData'</span>) <span class="comment">// 获取electron应用的用户目录</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> adapter = <span class="keyword">new</span> FileSync(path.join(STORE_PATH, <span class="string">'/data.json'</span>)) <span class="comment">// 初始化lowdb读写的json文件名以及存储路径</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> db = Datastore(adapter) <span class="comment">// lowdb接管该文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> db <span class="comment">// 暴露出去</span></span><br></pre></td></tr></table></figure><h4 id="2-开发模式和生产模式初始化路径问题"><a href="#2-开发模式和生产模式初始化路径问题" class="headerlink" title="2. 开发模式和生产模式初始化路径问题"></a>2. 开发模式和生产模式初始化路径问题</h4><p>在开发模式的时候，通过<code>APP.getPath(&#39;userData&#39;)</code>获取到的路径形如：<code>/Users/molunerfinn/Library/Application Support/Electron</code>（macOS下）。这个是一个已经自动创建好的路径。所以在开发模式的时候，初始化路径是已经存在的。</p><p>然而在生产模式下不是这样。生产模式下，第一次打开应用的过程中，<code>APP.getPath(&#39;userData&#39;)</code>获取的路径并未创建，而<code>datastore.js</code>却已经被加载。所以这个时候初始化路径并不存在。用户在第一次打开应用的时候就会遇到如下报错：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fodwgwq9k6j20nc176dov" alt=""></p><p>所以我们必须在<code>datastore.js</code>里做一次路径是否存在的判断：</p><blockquote><p>此处的fs是来自fs-extra模块</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (process.type !== <span class="string">'renderer'</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!fs.pathExistsSync(STORE_PATH)) &#123; <span class="comment">// 如果不存在路径</span></span><br><span class="line">    fs.mkdirpSync(STORE_PATH) <span class="comment">// 就创建</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-初始化数据"><a href="#3-初始化数据" class="headerlink" title="3. 初始化数据"></a>3. 初始化数据</h4><p>因为有的时候我们需要预先指定数据库的基本结构，比如是个数组，这样我们就初始化为<code>[]</code>。如果是个Object，有具体值，就指定为具体值。而初始化数据结构不应该在每次对数据读写的时候来判断，应该在数据库一开始创建的时候就初始化，所以写在<code>datastore.js</code>里是合适的。</p><p>比如我要初始化上传列表应该是一个数组，具体如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!db.has(<span class="string">'uploaded'</span>).value()) &#123; <span class="comment">// 先判断该值存不存在</span></span><br><span class="line">  db.set(<span class="string">'uploaded'</span>, []).write() <span class="comment">// 不存在就创建</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-唯一标识的id字段"><a href="#4-唯一标识的id字段" class="headerlink" title="4. 唯一标识的id字段"></a>4. 唯一标识的id字段</h4><p>用过MySQL的人大多都会在表里初始化一个自增的id字段作为数据的唯一标识。而lowdb虽然无法很方便地创建一个自增的id字段，但是通过<a href="https://github.com/typicode/lodash-id" target="_blank" rel="noopener">lodash-id</a>这个插件可以很方便地为每个新增的数据自动加上一个唯一标识的id字段。</p><p>形如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"height"</span>: <span class="number">514</span>,</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"weibo"</span>,</span><br><span class="line">  <span class="attr">"width"</span>: <span class="number">514</span>,</span><br><span class="line">  <span class="attr">"id"</span>: <span class="string">"7f247aa7-ffeb-4bb1-87f1-a0d69824ec78"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化也很方便：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">import</span> LodashId <span class="keyword">from</span> <span class="string">'lodash-id'</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> db = Datastore(adapter)</span><br><span class="line">db._.mixin(LodashId) <span class="comment">// 通过._mixin()引入</span></span><br></pre></td></tr></table></figure><h3 id="初始化完整代码"><a href="#初始化完整代码" class="headerlink" title="初始化完整代码"></a>初始化完整代码</h3><p>通过上述的踩坑，PicGo的初始化代码如下，仅供参考：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Datastore <span class="keyword">from</span> <span class="string">'lowdb'</span></span><br><span class="line"><span class="keyword">import</span> LodashId <span class="keyword">from</span> <span class="string">'lodash-id'</span></span><br><span class="line"><span class="keyword">import</span> FileSync <span class="keyword">from</span> <span class="string">'lowdb/adapters/FileSync'</span></span><br><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">'path'</span></span><br><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">'fs-extra'</span></span><br><span class="line"><span class="keyword">import</span> &#123; remote, app &#125; <span class="keyword">from</span> <span class="string">'electron'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> APP = process.type === <span class="string">'renderer'</span> ? remote.app : app</span><br><span class="line"><span class="keyword">const</span> STORE_PATH = APP.getPath(<span class="string">'userData'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (process.type !== <span class="string">'renderer'</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!fs.pathExistsSync(STORE_PATH)) &#123;</span><br><span class="line">    fs.mkdirpSync(STORE_PATH)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> adapter = <span class="keyword">new</span> FileSync(path.join(STORE_PATH, <span class="string">'/data.json'</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> db = Datastore(adapter)</span><br><span class="line">db._.mixin(LodashId)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!db.has(<span class="string">'uploaded'</span>).value()) &#123;</span><br><span class="line">  db.set(<span class="string">'uploaded'</span>, []).write()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!db.has(<span class="string">'picBed'</span>).value()) &#123;</span><br><span class="line">  db.set(<span class="string">'picBed'</span>, &#123;</span><br><span class="line">    current: <span class="string">'weibo'</span></span><br><span class="line">  &#125;).write()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!db.has(<span class="string">'shortKey'</span>).value()) &#123;</span><br><span class="line">  db.set(<span class="string">'shortKey'</span>, &#123;</span><br><span class="line">    upload: <span class="string">'CommandOrControl+Shift+P'</span></span><br><span class="line">  &#125;).write()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> db</span><br></pre></td></tr></table></figure><h2 id="lowdb的基本操作"><a href="#lowdb的基本操作" class="headerlink" title="lowdb的基本操作"></a>lowdb的基本操作</h2><p>数据库的基本操作无非就是CURD。</p><blockquote><p>它代表创建（Create）、更新（Update）、读取（Retrieve）和删除（Delete）操作。</p></blockquote><p>下面介绍lowdb的基本使用方法。</p><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>主要通过<code>set()</code>或者<code>defaults()</code>方法。其中<code>defaults()</code>专门针对空JSON文件进行初始化。（不过用set也是可以实现类似的，如上一小节说到的初始化）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.defaults(&#123; <span class="attr">posts</span>: [], <span class="attr">user</span>: &#123;&#125;, <span class="attr">count</span>: <span class="number">0</span> &#125;)</span><br><span class="line">  .write() <span class="comment">// 一定要显式调用write方法将数据存入JSON</span></span><br></pre></td></tr></table></figure><p><strong>注意任何写的操作，都必须显式的使用<code>write()</code>方法来保存。</strong></p><h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.get(<span class="string">'posts'</span>).value() <span class="comment">// []</span></span><br></pre></td></tr></table></figure><p>当然还可以用lodash的一些方法来查询你的JSON。</p><p>比如<code>find()</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.get(<span class="string">'posts'</span>)</span><br><span class="line">  .find(&#123; <span class="attr">id</span>: <span class="number">1</span> &#125;)</span><br><span class="line">  .value()</span><br></pre></td></tr></table></figure><p><strong>注意任何读的操作，都必须显式使用<code>value()</code>方法来获取值。</strong></p><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>通过不同的方法对不同的结构来更新。</p><p>比如针对对象就用赋值，针对数组就用<code>push()</code>或者<code>insert()</code>（lowdb-id提供的方法）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.get(<span class="string">'posts'</span>).insert(&#123; <span class="comment">// 对数组进行insert操作</span></span><br><span class="line">  title: <span class="string">'xxx'</span>,</span><br><span class="line">  content: <span class="string">'xxxx'</span></span><br><span class="line">&#125;).write()</span><br></pre></td></tr></table></figure><p>针对对象可以直接用<code>set()</code>来更新：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.set(<span class="string">'user.name'</span>, <span class="string">'typicode'</span>) <span class="comment">// 通过set方法来对对象操作</span></span><br><span class="line">  .write()</span><br></pre></td></tr></table></figure><p>还可以这么写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.set(<span class="string">'user'</span>, &#123;</span><br><span class="line">  name: <span class="string">'typicode'</span></span><br><span class="line">&#125;).write()</span><br></pre></td></tr></table></figure><p>很灵活对吧。</p><p>针对原有的数据进行更新的可以用update。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.update(<span class="string">'count'</span>, n =&gt; n + <span class="number">1</span>) <span class="comment">// update方法使用已存在的值来操作</span></span><br><span class="line">  .write()</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>可以通过<code>remove()</code>方法删除一个符合条件的项：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.get(<span class="string">'posts'</span>)</span><br><span class="line">  .remove(&#123; <span class="attr">title</span>: <span class="string">'low!'</span> &#125;)</span><br><span class="line">  .write()</span><br></pre></td></tr></table></figure><p>可以通过<code>unset</code>来删除一个属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.unset(<span class="string">'user.name'</span>)</span><br><span class="line">  .write()</span><br></pre></td></tr></table></figure><p>还可以通过<code>lodash-id</code>提供的<code>removeById()</code>来删除指定id的项：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.get(<span class="string">'posts'</span>)</span><br><span class="line">  .removeById(id)</span><br><span class="line">  .write()</span><br></pre></td></tr></table></figure><h2 id="lowdb实际使用的坑"><a href="#lowdb实际使用的坑" class="headerlink" title="lowdb实际使用的坑"></a>lowdb实际使用的坑</h2><p>lowdb在使用的过程中会遇到一个大坑在于，如果就按照基本操作，那么有可能出现我在<code>main</code>进程里存入的值，在<code>renderer</code>进程里读不到。</p><p>为啥？因为直接引用的<code>db</code>实际上只是那个时刻在内存里的数据。lowdb在使用过程中会把JSON数据读入内存中。只有在需要写操作的时候才会将新的数据写入磁盘。</p><p>main进程和renderer进程拿到的db都是应用打开时所读取的。在没有额外处理的情况下，在main进程拿到的内存里的db，和renderer拿到的内存里的db不是同一个db，也就是所谓的不是一个db的两份引用，而是一个db的两份拷贝。main进程对其进行的操作，renderer进程是不知道的。换句话说，main进程对db进行了任何读写操作，renderer拿到的db依然是当初应用打开时所读取的db。所以就会遇到main进程更新了数据，而renderer进程依然无法拿到新的数据。</p><p>那有没有办法解决呢？有的。就是有点麻烦。那就是在所有的db操作的最开始，都重新读取一遍db的最新状态：</p><p>比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.read().get(<span class="string">'xxx'</span>).value()</span><br><span class="line"></span><br><span class="line">db.read().set(<span class="string">'xxx'</span>, <span class="string">'xxx'</span>)</span><br></pre></td></tr></table></figure><p>强制在每个db操作前，都通过read()刷新一遍内存区，这样就能保证拿到的数据都是最新的啦。</p><h2 id="Vue里使用lowdb的便捷方法"><a href="#Vue里使用lowdb的便捷方法" class="headerlink" title="Vue里使用lowdb的便捷方法"></a>Vue里使用lowdb的便捷方法</h2><p>类似于很多人会在Vue里把axios挂在vue的原型链上一样，我们也可以用类似的方法来方便我们在Vue里使用lowdb。</p><p>打开Vue项目的入口文件，通常是<code>main.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">import</span> db <span class="keyword">from</span> <span class="string">'../datastore'</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">Vue.prototype.$db = db</span><br></pre></td></tr></table></figure><p>这样我们就可以在项目里，用<code>this.$db</code>的方法来使用lowdb啦。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文详细地介绍了lowdb以及lowdb在electron里的使用。很多都是我在开发<code>PicGo</code>的时候碰到的问题、踩的坑。也许文中简单的几句话背后就是我无数次的查阅和调试。希望这篇文章能够给你的<code>electron-vue</code>开发带来一些启发。文中相关的代码，你都可以在<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a>的项目仓库里找到。如果本文能够给你带来帮助，那么将是我最开心的地方。如果喜欢，欢迎关注我的<a href="https://molunerfinn.com">博客</a>以及本系列文章的后续进展。</p><blockquote><p><strong>注：文中的图片除未特地说明之外均属于我个人作品，需要转载请私信</strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前段时间，我用&lt;a href=&quot;https://github.com/SimulatedGREG/electron-vue&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;electron-vue&lt;/a&gt;开发了一款跨平台（目前支持Mac和Windows）的免费开源的图床上传应用——&lt;a href=&quot;https://github.com/Molunerfinn/PicGo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PicGo&lt;/a&gt;，在开发过程中踩了不少的坑，不仅来自应用的业务逻辑本身，也来自electron本身。在开发这个应用过程中，我学了不少的东西。因为我也是从0开始学习electron，所以很多经历应该也能给初学、想学electron开发的同学们一些启发和指示。故而写一份Electron的开发实战经历，用最贴近实际工程项目开发的角度来阐述。希望能帮助到大家。&lt;/p&gt;&lt;p&gt;预计将会从几篇系列文章或方面来展开：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-1/&quot;&gt;electron-vue入门&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-2/&quot;&gt;Main进程和Renderer进程的简单开发&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-3/&quot;&gt;引入基于Lodash的JSON database——lowdb&lt;/a&gt;&lt;/li&gt;&lt;li&gt;跨平台的一些兼容措施&lt;/li&gt;&lt;li&gt;通过CI发布以及更新的方式&lt;/li&gt;&lt;li&gt;…（想到再写）&lt;/li&gt;&lt;/ol&gt;&lt;h2 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h2&gt;&lt;p&gt;&lt;code&gt;PicGo&lt;/code&gt;是采用&lt;code&gt;electron-vue&lt;/code&gt;开发的，所以如果你会&lt;code&gt;vue&lt;/code&gt;，那么跟着一起来学习将会比较快。如果你的技术栈是其他的诸如&lt;code&gt;react&lt;/code&gt;、&lt;code&gt;angular&lt;/code&gt;，那么纯按照本教程虽然在render端（可以理解为页面）的构建可能学习到的东西不多，不过在main端（electron的主进程）应该还是能学习到相应的知识的。&lt;/p&gt;&lt;p&gt;如果之前的文章没阅读的朋友可以先从之前的文章跟着看。&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="https://molunerfinn.com/categories/Web/"/>
    
      <category term="开发" scheme="https://molunerfinn.com/categories/Web/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="前端" scheme="https://molunerfinn.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Vue" scheme="https://molunerfinn.com/tags/Vue/"/>
    
      <category term="Electron" scheme="https://molunerfinn.com/tags/Electron/"/>
    
      <category term="Electron-vue" scheme="https://molunerfinn.com/tags/Electron-vue/"/>
    
  </entry>
  
  <entry>
    <title>Electron-vue开发实战1——Main进程和Renderer进程的简单开发</title>
    <link href="https://molunerfinn.com/electron-vue-2/"/>
    <id>https://molunerfinn.com/electron-vue-2/</id>
    <published>2018-01-17T10:55:00.000Z</published>
    <updated>2018-04-27T08:26:51.713Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间，我用<a href="https://github.com/SimulatedGREG/electron-vue" target="_blank" rel="noopener">electron-vue</a>开发了一款跨平台（目前支持Mac和Windows）的免费开源的图床上传应用——<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a>，在开发过程中踩了不少的坑，不仅来自应用的业务逻辑本身，也来自electron本身。在开发这个应用过程中，我学了不少的东西。因为我也是从0开始学习electron，所以很多经历应该也能给初学、想学electron开发的同学们一些启发和指示。故而写一份Electron的开发实战经历，用最贴近实际工程项目开发的角度来阐述。希望能帮助到大家。</p><p>预计将会从几篇系列文章或方面来展开：</p><ol><li><a href="https://molunerfinn.com/electron-vue-1/">electron-vue入门</a></li><li><a href="https://molunerfinn.com/electron-vue-2/">Main进程和Renderer进程的简单开发</a></li><li>引入基于Lodash的json database——lowdb</li><li>跨平台的一些兼容措施</li><li>通过CI发布以及更新的方式</li><li>…（想到再写）</li></ol><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p><code>PicGo</code>是采用<code>electron-vue</code>开发的，所以如果你会<code>vue</code>，那么跟着一起来学习将会比较快。如果你的技术栈是其他的诸如<code>react</code>、<code>angular</code>，那么纯按照本教程虽然在render端（可以理解为页面）的构建可能学习到的东西不多，不过在main端（electron的主进程）应该还是能学习到相应的知识的。</p><p>如果之前的文章没阅读的朋友可以先从之前的文章跟着看。</p><a id="more"></a><h2 id="Main进程和Renderer进程的基本认识"><a href="#Main进程和Renderer进程的基本认识" class="headerlink" title="Main进程和Renderer进程的基本认识"></a>Main进程和Renderer进程的基本认识</h2><p>从上一篇文章结尾部分我们运行成功的一个electron-vue的<a href="https://molunerfinn.com/electron-vue-1/#electron-vue%E5%AE%89%E8%A3%85">DEMO</a>来直观看看这两个进程的粗浅认识：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fnh28jgs8nj20ms098wge" alt=""></p><p>可以看到Main进程管理的是这个app窗口（<a href="https://electronjs.org/docs/api/browser-window" target="_blank" rel="noopener">BrowserWindow</a>），而Renderer进程负责的就是我们熟悉的页面UI渲染。不过实际上，它们远远不仅如此。下面一张图能够把它们所支持、管理的electron或者原生的模块大致列出来：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fnhcn82n7sj21wu1fmn6v" alt="main &amp; renderer process tree"></p><blockquote><p>图中列出来的大部分模块都是我们会在开发过程中用到的。</p></blockquote><p>它们有各自的模块，也有共有的模块比如<code>clipboard</code>等。还有一部分是Main进程里的模块，不过可以通过<code>remote</code>模块，让renderer进程也能使用。比如<code>Menu</code>比如<code>shell</code>等。</p><p>了解一下哪些模块在哪些进程里，哪些模块可以通过<code>remote</code>模块让renderer进程也能使用是有必要的，这样我们后续开发的时候才能正确的使用。</p><p>上面的模块可能有些从名字里并不能看出作用是啥，没关系，后续的内容会慢慢涉及。</p><h2 id="Main进程开发"><a href="#Main进程开发" class="headerlink" title="Main进程开发"></a>Main进程开发</h2><p>上面说到了Main进程一个显著的作用就是创建app的窗口。我们来看看这个是怎么实现的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; app, BrowserWindow &#125; <span class="keyword">from</span> <span class="string">'electron'</span> <span class="comment">// 从electron引入app和BrowserWindow</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mainWindow</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> winURL = process.env.NODE_ENV === <span class="string">'development'</span></span><br><span class="line">  ? <span class="string">`http://localhost:9080`</span> <span class="comment">// 开发模式的话走webpack-dev-server的url</span></span><br><span class="line">  : <span class="string">`file://<span class="subst">$&#123;__dirname&#125;</span>/index.html`</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createWindow</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 创建窗口</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Initial window options</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  mainWindow = <span class="keyword">new</span> BrowserWindow(&#123;</span><br><span class="line">    height: <span class="number">563</span>,</span><br><span class="line">    useContentSize: <span class="literal">true</span>,</span><br><span class="line">    width: <span class="number">1000</span></span><br><span class="line">  &#125;) <span class="comment">// 创建一个窗口</span></span><br><span class="line"></span><br><span class="line">  mainWindow.loadURL(winURL) <span class="comment">// 加载窗口的URL -&gt; 来自renderer进程的页面</span></span><br><span class="line"></span><br><span class="line">  mainWindow.on(<span class="string">'closed'</span>, () =&gt; &#123;</span><br><span class="line">    mainWindow = <span class="literal">null</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.on(<span class="string">'ready'</span>, createWindow) <span class="comment">// app准备好的时候创建窗口</span></span><br></pre></td></tr></table></figure><p>暂且先不管渲染进程里的页面长什么样，在app准备好的时候打开一个窗口只需要调用一个创建<code>BrowserWindow</code>的方法即可。</p><p>main进程里的开发有点当年写<code>jQuery</code>的样子，比较多的是事件驱动型的写法。</p><h3 id="app"><a href="#app" class="headerlink" title="app"></a>app</h3><p>首先需要注意的是<a href="https://electronjs.org/docs/api/app" target="_blank" rel="noopener">app</a>的模块。这个模块是electron应用的骨架。它掌管着整个应用的生命周期钩子，以及很多其他事件钩子。</p><p>app的常用生命周期钩子如下：</p><ul><li><code>will-finish-launching</code> 在应用完成基本启动进程之后触发</li><li><code>ready</code> 当electron完成初始化后触发</li><li><code>window-all-closed</code> 所有窗口都关闭的时候触发，在windows和linux里，所有窗口都退出的时候<strong>通常</strong>是应用退出的时候</li><li><code>before-quit</code> 退出应用之前的时候触发</li><li><code>will-quit</code> 即将退出应用的时候触发</li><li><code>quit</code> 应用退出的时候触发</li></ul><p>而我们通常会在<code>ready</code>的时候执行创建应用窗口、创建应用菜单、创建应用快捷键等初始化操作。而在<code>will-quit</code>或者<code>quit</code>的时候执行一些清空操作，比如解绑应用快捷键。</p><p>特别的，在非<code>macOS</code>的系统下，通常一个应用的所有窗口都退出的时候，也是这个应用退出之时。所以可以配合<code>window-all-closed</code>这个钩子来实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.on(<span class="string">'window-all-closed'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (process.platform !== <span class="string">'darwin'</span>) &#123; <span class="comment">// 当操作系统不是darwin（macOS）的话</span></span><br><span class="line">    app.quit() <span class="comment">// 退出应用</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>除了上面说的生命周期钩子之外，还有一些常用的事件钩子：</p><ul><li><code>active</code>（仅macOS）当应用处于激活状态时</li><li><code>browser-window-created</code> 当一个BrowserWindow被创建的时候</li><li><code>browser-window-focus</code> 当一个BrowserWindow处于激活状态的时候</li></ul><p>这些钩子需要配合一些具体场景来做出具体的操作。比如当一个BrowserWindow处于激活状态的时候修改窗口的title值。</p><p>当然，app这个模块除了上述的一些事件钩子之外，还有一些很常用的方法：</p><ul><li><code>app.quit()</code> 用于退出应用</li><li><code>app.getPath(name)</code> 用于获取一些系统目录，对于存放应用的配置文件等很有用</li><li><code>app.focus()</code> 用于激活应用，不同系统激活逻辑<a href="https://electronjs.org/docs/api/app#appfocus" target="_blank" rel="noopener">不一样</a></li></ul><p>这些事件和方法都是怎么知道的呢？当然是<a href="https://electronjs.org/docs/" target="_blank" rel="noopener">官方文档</a>了。不过并不需要一开始就通读一遍官方的api文档。官方的api文档更多的作用是用来查阅，当你要开发到某个功能的时候再去查它能否有对应的api、怎么使用。</p><h3 id="BrowserWindow"><a href="#BrowserWindow" class="headerlink" title="BrowserWindow"></a>BrowserWindow</h3><p>BrowserWindow模块用于创建最常见的应用窗口。对于不同系统，创建的窗口的默认样式也不太一样。下面来看看macOS和windows的窗口在外观上的区别：</p><p>mac版的</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fncs5yv0qdj21jk0wi44h" alt=""></p><p>windows版的</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fnhdibuabmj20rq0h2whl" alt=""></p><p>可以看到二者在窗口顶部的操作区（最小化、最大化、关闭）和标题的位置以及菜单的位置还是有明显的不同的。它们跟系统原生的窗口是一致的。不过如果你想要美化一下也是没问题的。比如：</p><p>mac版的PicGo</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fnhdaimi40j218g0p0dic" alt="picgo-mac"></p><p>和windows的PicGo</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fnhdb9mj1uj20m80ci3yz" alt="picgo-windows"></p><p>其中mac版用了系统的操作区，而windows则没有用系统的操作区，而是用图标模拟的。不过同样的地方是都未使用系统默认的<code>titlebar</code>。这个之后会结合<code>renderer</code>进程来说。</p><p>让我们来看看创建一个BrowserWindow的常用配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="built_in">window</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createWindow</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">window</span> = <span class="keyword">new</span> BrowserWindow(&#123;</span><br><span class="line">    height: <span class="number">900</span>, <span class="comment">// 高</span></span><br><span class="line">    width: <span class="number">400</span>, <span class="comment">// 宽</span></span><br><span class="line">    show: <span class="literal">false</span>, <span class="comment">// 创建后是否显示</span></span><br><span class="line">    frame: <span class="literal">false</span>, <span class="comment">// 是否创建frameless窗口</span></span><br><span class="line">    fullscreenable: <span class="literal">false</span>, <span class="comment">// 是否允许全屏</span></span><br><span class="line">    center: <span class="literal">true</span>, <span class="comment">// 是否出现在屏幕居中的位置</span></span><br><span class="line">    backgroundColor: <span class="string">'#fff'</span> <span class="comment">// 背景色，用于transparent和frameless窗口</span></span><br><span class="line">    titleBarStyle: <span class="string">'xxx'</span> <span class="comment">// 标题栏的样式，有hidden、hiddenInset、customButtonsOnHover等</span></span><br><span class="line">    resizable: <span class="literal">false</span>, <span class="comment">// 是否允许拉伸大小</span></span><br><span class="line">    transparent: <span class="literal">true</span>, <span class="comment">// 是否是透明窗口（仅macOS）</span></span><br><span class="line">    vibrancy: <span class="string">'ultra-dark'</span>, <span class="comment">// 窗口模糊的样式（仅macOS）</span></span><br><span class="line">    webPreferences: &#123;</span><br><span class="line">      backgroundThrottling: <span class="literal">false</span> <span class="comment">// 当页面被置于非激活窗口的时候是否停止动画和计时器</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... 以及其他可选配置</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">window</span>.loadURL(url)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">window</span>.on(<span class="string">'closed'</span>, () =&gt; &#123; <span class="built_in">window</span> = <span class="literal">null</span> &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>窗口的长宽自然不必说，需要指定。其中需要注意的几个比较重要的就是，<code>frame</code>这个选项，默认是<code>true</code>。如果选择了<code>false</code>则会创建一个<code>frameless</code><a href="https://electronjs.org/docs/api/frameless-window" target="_blank" rel="noopener">窗口</a>，创建一个没有顶部工具栏、没有border的窗口。这个也是我们在windows系统下自定义顶部栏的基础。</p><p>像上述PicGo的主窗口的配置，就是通过如下的配置实现的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> createSettingWindow = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> options = &#123;</span><br><span class="line">    height: <span class="number">450</span>,</span><br><span class="line">    width: <span class="number">800</span>,</span><br><span class="line">    show: <span class="literal">false</span>,</span><br><span class="line">    frame: <span class="literal">true</span>,</span><br><span class="line">    center: <span class="literal">true</span>,</span><br><span class="line">    fullscreenable: <span class="literal">false</span>,</span><br><span class="line">    resizable: <span class="literal">false</span>,</span><br><span class="line">    title: <span class="string">'PicGo'</span>,</span><br><span class="line">    vibrancy: <span class="string">'ultra-dark'</span>,</span><br><span class="line">    transparent: <span class="literal">true</span>,</span><br><span class="line">    titleBarStyle: <span class="string">'hidden'</span>,</span><br><span class="line">    webPreferences: &#123;</span><br><span class="line">      backgroundThrottling: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (process.platform === <span class="string">'win32'</span>) &#123; <span class="comment">// 针对windows平台做出不同的配置</span></span><br><span class="line">    options.show = <span class="literal">true</span> <span class="comment">// 创建即展示</span></span><br><span class="line">    options.frame = <span class="literal">false</span> <span class="comment">// 创建一个frameless窗口</span></span><br><span class="line">    options.backgroundColor = <span class="string">'#3f3c37'</span> <span class="comment">// 背景色</span></span><br><span class="line">  &#125;</span><br><span class="line">  settingWindow = <span class="keyword">new</span> BrowserWindow(options)</span><br><span class="line"></span><br><span class="line">  settingWindow.loadURL(settingWinURL)</span><br><span class="line"></span><br><span class="line">  settingWindow.on(<span class="string">'closed'</span>, () =&gt; &#123;</span><br><span class="line">    settingWindow = <span class="literal">null</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟<code>app</code>模块一样，<code>BrowserWindow</code>也有很多常用的事件钩子：</p><ul><li><code>closed</code> 当窗口被关闭的时候</li><li><code>focus</code> 当窗口被激活的时候</li><li><code>show</code> 当窗口展示的时候</li><li><code>hide</code> 当窗口被隐藏的时候</li><li><code>maxmize</code> 当窗口最大化时</li><li><code>minimize</code> 当窗口最小化时</li><li><code>...</code></li></ul><p>当然，也依然有很多实用的方法：</p><ul><li><code>BrowserWindow.getFocusedWindow()</code> [静态方法]获取激活的窗口</li><li><code>win.close()</code> [实例方法，下同]关闭窗口</li><li><code>win.focus()</code> 激活窗口</li><li><code>win.show()</code> 显示窗口</li><li><code>win.hide()</code> 隐藏窗口</li><li><code>win.maximize()</code> 最大化窗口</li><li><code>win.minimize()</code> 最小化窗口</li><li><code>win.restore()</code> 从最小化窗口恢复</li><li><code>...</code></li></ul><p>针对不同的业务逻辑你需要对窗口进行不一样的操作。这个需要跟你的项目需求相匹配。比如上述说到的，windows的顶部的操作区（放大、缩小、关闭按钮）就可以通过icon模拟+实例方法来实现。</p><h3 id="Tray"><a href="#Tray" class="headerlink" title="Tray"></a>Tray</h3><p>一开始看这个名字你可能并不知道这个是个什么东西。可以把它理解为不同系统的任务栏里的图标组件吧。</p><p>比如在macOS里，<code>Tray</code>配合上图标之后就是顶部栏里的应用图标了：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fnijxxj5gkj215i01at9b" alt=""></p><p>比如在windows里，<code>Tray</code>配合上图标之后就是windows右下角的应用图标了：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fnijzo4hgbj20gl016a9z" alt=""></p><p>需要注意的是，windows和macOS里，图标的大小都是<code>16*16</code>px。macOS下顶部栏的图标通常都是走<code>黑白</code>路线，所以可以为两种系统分别准备不同的图标。<code>PicGo</code>里<code>Tray</code>的生成代码大致如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createTray</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> menubarPic = process.platform === <span class="string">'darwin'</span> ? <span class="string">`<span class="subst">$&#123;__static&#125;</span>/menubar.png`</span> : <span class="string">`<span class="subst">$&#123;__static&#125;</span>/menubar-nodarwin.png`</span></span><br><span class="line">  tray = <span class="keyword">new</span> Tray(menubarPic) <span class="comment">// 指定图片的路径</span></span><br><span class="line">  <span class="comment">// ... 其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意上述代码里有一个<code>${__static}</code>的变量。该变量是<code>electron-vue</code>为我们暴露出来的项目根目录下的<code>static</code>文件夹的路径。通过这个路径，在开发和生产阶段都能很好的定位你的静态资源所在的目录。是个很方便的变量。</p><p>当然<code>Tray</code>并不只是一个图标而无其他作用了。Tray支持很多有用的事件。其中最关键的两个是<code>click</code>和<code>right-click</code>。分别对应鼠标左键点击和鼠标右键点击事件。</p><h4 id="鼠标左键点击事件"><a href="#鼠标左键点击事件" class="headerlink" title="鼠标左键点击事件"></a>鼠标左键点击事件</h4><ul><li>在macOS系统下，鼠标左键点击Tray的icon可能会出现配置菜单，也有可能会出现应用窗口。</li><li>在windows下，鼠标左键点击Tray的icon通常会出现应用的窗口。</li></ul><h4 id="鼠标右键点击事件"><a href="#鼠标右键点击事件" class="headerlink" title="鼠标右键点击事件"></a>鼠标右键点击事件</h4><ul><li>在macOS系统下，鼠标右键点击Tray的icon通常会出现配置菜单。</li><li>在windows系统下，同上。</li></ul><p>所以需要我们去适配不同操作系统下用户的操作习惯。</p><p>对应于PicGo而言，在macOS系统下左键点击会出现一个menubar的小窗口，右键点击会出现配置菜单。而在windows下，左键点击会直接出现主窗口，（因为在windows下无小窗口的必要），右键点击会出现配置菜单。它们在PicGo里的实现如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createTray</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> menubarPic = process.platform === <span class="string">'darwin'</span> ? <span class="string">`<span class="subst">$&#123;__static&#125;</span>/menubar.png`</span> : <span class="string">`<span class="subst">$&#123;__static&#125;</span>/menubar-nodarwin.png`</span></span><br><span class="line">  tray = <span class="keyword">new</span> Tray(menubarPic)</span><br><span class="line">  <span class="keyword">const</span> contextMenu = <span class="comment">// ...菜单</span></span><br><span class="line">  tray.on(<span class="string">'right-click'</span>, () =&gt; &#123; <span class="comment">// 右键点击</span></span><br><span class="line">    <span class="built_in">window</span>.hide() <span class="comment">// 隐藏小窗口</span></span><br><span class="line">    tray.popUpContextMenu(contextMenu) <span class="comment">// 打开菜单</span></span><br><span class="line">  &#125;)</span><br><span class="line">  tray.on(<span class="string">'click'</span>, () =&gt; &#123; <span class="comment">// 左键点击</span></span><br><span class="line">    <span class="keyword">if</span> (process.platform === <span class="string">'darwin'</span>) &#123; <span class="comment">// 如果是macOS</span></span><br><span class="line">      toggleWindow() <span class="comment">// 打开或关闭小窗口</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果是windows</span></span><br><span class="line">      <span class="built_in">window</span>.hide() <span class="comment">// 隐藏小窗口</span></span><br><span class="line">      <span class="keyword">if</span> (settingWindow === <span class="literal">null</span>) &#123; <span class="comment">// 如果主窗口不存在就创建一个</span></span><br><span class="line">        createSettingWindow()</span><br><span class="line">        settingWindow.show()</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果主窗口在，就显示并激活</span></span><br><span class="line">        settingWindow.show()</span><br><span class="line">        settingWindow.focus()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于macOS而言，Tray还有一个很棒的特性——可以拖拽文件到Tray的icon上，会触发如下事件：</p><ul><li><code>drop</code> 当任何东西拖拽到icon上时</li><li><code>drop-files</code> 当文件被拖拽到icon上时</li><li><code>drop-text</code> 当文本被拖拽到icon上时</li><li><code>drop-enter</code> 当刚拖拽到icon上时</li><li><code>drop-leave</code> 当拖拽事件离开icon时</li><li><code>drop-end</code> 当拖拽事件结束时</li></ul><p>就像PicGo实现的拖拽图片到Tray的icon上时实现图片上传的功能，就是用到了上述的一些事件：</p><p><img src="https://user-images.githubusercontent.com/12621342/34242310-b5056510-e655-11e7-8568-60ffd4f71910.gif" alt=""></p><p>尤其注意到在拖拽上的时候和拖拽结束后的时候icon是不一样的。在PicGo里是这样实现的，很简单：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tray.on(<span class="string">'drag-enter'</span>, () =&gt; &#123;</span><br><span class="line">  tray.setImage(<span class="string">`<span class="subst">$&#123;__static&#125;</span>/upload.png`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">tray.on(<span class="string">'drag-end'</span>, () =&gt; &#123;</span><br><span class="line">  tray.setImage(<span class="string">`<span class="subst">$&#123;__static&#125;</span>/menubar.png`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>而<code>Tray</code>另一个重要的作用就是开启菜单项。这个将结合下一节<code>Menu</code>一起说明。</p><h3 id="Menu"><a href="#Menu" class="headerlink" title="Menu"></a>Menu</h3><p>electron威力强大的Menu组件，既能够生成系统菜单项，也能实现绑定应用常用快捷键的功能。</p><p>先来看看什么是系统菜单项：</p><blockquote><p>macOS</p></blockquote><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fnisjmm1f9j213m074wln" alt=""></p><blockquote><p>windows</p></blockquote><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fnisory5p4j215c0pen3z" alt=""></p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fnislgodz9j204k047mx8" alt=""></p><p>主要分两种。</p><ul><li>第一种是app的菜单。对于macOS来说就是顶部栏左侧区域的菜单项。对于windows而言就是一个窗口的标题栏下方的菜单区。</li><li>第二种是类似于右键菜单的菜单。</li></ul><p>第一种菜单可以通过<code>Menu.setApplicationMenu()</code>来实现。</p><p>第二种菜单可以通过两个步骤来展示：</p><p><strong>1.</strong> 创建菜单：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> contextMenu = Menu.buildFromTemplate([...])</span><br></pre></td></tr></table></figure><p><strong>2.</strong> 展示菜单：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tray.on(<span class="string">'right-click'</span>, () =&gt; &#123; <span class="comment">// 右键点击tray的时候</span></span><br><span class="line">  tray.popUpContextMenu(contextMenu) <span class="comment">// 弹出菜单</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里我们只介绍了<code>Menu</code>本身。其实组成<code>Menu</code>的是一个一个的<code>MenuItem</code>。它们有很多类型：</p><ol><li>normal</li><li>separator</li><li>submenu</li><li>checkbox</li><li>radio</li></ol><p>以及很多角色：</p><ol><li>quit</li><li>copy</li><li>redo</li><li>undo</li><li>minimize</li><li>close</li><li>reload</li><li>…</li></ol><p>通常来说，配置的菜单项基本从类型里来组合。比如PicGo的菜单项：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fnivun40bij20fg082wgo" alt=""></p><p>这里面就有normal、submenu、checkbox和radio四种类型。其中默认是normal。</p><p>角色的话通常对应的是一些常见的行为。比如<code>quit</code>是退出app，比如<code>minimize</code>是最小化，比如<code>copy</code>是复制。不过需要注意的是，如果你没有在创建app菜单里指定这些操作的快捷键的话，那么一些常见的快捷操作就无法在你的app里使用了。比如<code>ctrl+c</code>或者<code>command+c</code>复制这个操作，如果你没有通过<code>Menu.setApplicationMenu()</code>来设定这个快捷键的话，那么在你的electron应用里就无法执行复制的操作了。PicGo在早期版本里也犯了这个<a href="">错误</a>。当时的问题是我在开发模式下是没有问题的，但是在生产模式下就无法进行复制粘贴操作。后来查了一下原因，发现原来在开发模式下，electron会置入默认的一些快捷操作菜单，如图：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fnjcaoo0btj20pg0fcah1" alt=""></p><p>所以在生产模式如果我没有置入这些快捷键的话，使用者就无法使用了。<strong>这个是大坑</strong>。</p><p>说了这么多，来看看生成app的菜单的代码长啥样：</p><blockquote><p>注意，如果在开发模式下直接只使用如下快捷键的话，一些调试快捷键比如<code>F12</code>或者<code>command+shift+i</code>打开控制台的操作就无法使用了。所以在开发模式下不需要创建这些快捷键菜单。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> createMenu = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'development'</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> template = [&#123;</span><br><span class="line">      label: <span class="string">'Edit'</span>,</span><br><span class="line">      submenu: [</span><br><span class="line">        &#123; <span class="attr">label</span>: <span class="string">'Undo'</span>, <span class="attr">accelerator</span>: <span class="string">'CmdOrCtrl+Z'</span>, <span class="attr">selector</span>: <span class="string">'undo:'</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">label</span>: <span class="string">'Redo'</span>, <span class="attr">accelerator</span>: <span class="string">'Shift+CmdOrCtrl+Z'</span>, <span class="attr">selector</span>: <span class="string">'redo:'</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">type</span>: <span class="string">'separator'</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">label</span>: <span class="string">'Cut'</span>, <span class="attr">accelerator</span>: <span class="string">'CmdOrCtrl+X'</span>, <span class="attr">selector</span>: <span class="string">'cut:'</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">label</span>: <span class="string">'Copy'</span>, <span class="attr">accelerator</span>: <span class="string">'CmdOrCtrl+C'</span>, <span class="attr">selector</span>: <span class="string">'copy:'</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">label</span>: <span class="string">'Paste'</span>, <span class="attr">accelerator</span>: <span class="string">'CmdOrCtrl+V'</span>, <span class="attr">selector</span>: <span class="string">'paste:'</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">label</span>: <span class="string">'Select All'</span>, <span class="attr">accelerator</span>: <span class="string">'CmdOrCtrl+A'</span>, <span class="attr">selector</span>: <span class="string">'selectAll:'</span> &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          label: <span class="string">'Quit'</span>,</span><br><span class="line">          accelerator: <span class="string">'CmdOrCtrl+Q'</span>,</span><br><span class="line">          click () &#123;</span><br><span class="line">            app.quit()</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;]</span><br><span class="line">    menu = Menu.buildFromTemplate(template)</span><br><span class="line">    Menu.setApplicationMenu(menu)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过<code>accelerator</code>指定你想要的快捷键。诸如<code>Shift</code>、<code>Ctrl</code>、<code>Cmd</code>等键位缩写。如果是组合键，就加上<code>+</code>。尤其注意到，因为macOS和windows键位的差异，所以有一个很好用的键位缩写<code>CmdOrCtrl</code>，即如果是在macOS上就是<code>Cmd</code>，在windows上就是<code>Ctrl</code>。</p><p>然后再来看看Tray的“右键”菜单的生成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> contextMenu = Menu.buildFromTemplate([</span><br><span class="line">   &#123;</span><br><span class="line">     label: <span class="string">'关于'</span>,</span><br><span class="line">     click () &#123;</span><br><span class="line">       dialog.showMessageBox(&#123;</span><br><span class="line">         title: <span class="string">'PicGo'</span>,</span><br><span class="line">         message: <span class="string">'PicGo'</span>,</span><br><span class="line">         detail: <span class="string">`Version: <span class="subst">$&#123;pkg.version&#125;</span>\nAuthor: Molunerfinn\nGithub: https://github.com/Molunerfinn/PicGo`</span></span><br><span class="line">       &#125;)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">     label: <span class="string">'打开详细窗口'</span>,</span><br><span class="line">     click () &#123;</span><br><span class="line">       <span class="keyword">if</span> (settingWindow === <span class="literal">null</span>) &#123;</span><br><span class="line">         createSettingWindow()</span><br><span class="line">         settingWindow.show()</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         settingWindow.show()</span><br><span class="line">         settingWindow.focus()</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">     label: <span class="string">'选择默认图床'</span>,</span><br><span class="line">     type: <span class="string">'submenu'</span>,</span><br><span class="line">     submenu: [</span><br><span class="line">       &#123;</span><br><span class="line">         label: <span class="string">'微博图床'</span>,</span><br><span class="line">         type: <span class="string">'radio'</span>,</span><br><span class="line">         checked: db.read().get(<span class="string">'picBed.current'</span>).value() === <span class="string">'weibo'</span>,</span><br><span class="line">         click () &#123;</span><br><span class="line">           db.read().set(<span class="string">'picBed.current'</span>, <span class="string">'weibo'</span>)</span><br><span class="line">             .write()</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;,</span><br><span class="line">       &#123;</span><br><span class="line">         label: <span class="string">'七牛图床'</span>,</span><br><span class="line">         type: <span class="string">'radio'</span>,</span><br><span class="line">         checked: db.read().get(<span class="string">'picBed.current'</span>).value() === <span class="string">'qiniu'</span>,</span><br><span class="line">         click () &#123;</span><br><span class="line">           db.read().set(<span class="string">'picBed.current'</span>, <span class="string">'qiniu'</span>)</span><br><span class="line">             .write()</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;,</span><br><span class="line">       &#123;</span><br><span class="line">         label: <span class="string">'腾讯云COS'</span>,</span><br><span class="line">         type: <span class="string">'radio'</span>,</span><br><span class="line">         checked: db.read().get(<span class="string">'picBed.current'</span>).value() === <span class="string">'tcyun'</span>,</span><br><span class="line">         click () &#123;</span><br><span class="line">           db.read().set(<span class="string">'picBed.current'</span>, <span class="string">'tcyun'</span>)</span><br><span class="line">             .write()</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;,</span><br><span class="line">       &#123;</span><br><span class="line">         label: <span class="string">'又拍云图床'</span>,</span><br><span class="line">         type: <span class="string">'radio'</span>,</span><br><span class="line">         checked: db.read().get(<span class="string">'picBed.current'</span>).value() === <span class="string">'upyun'</span>,</span><br><span class="line">         click () &#123;</span><br><span class="line">           db.read().set(<span class="string">'picBed.current'</span>, <span class="string">'upyun'</span>)</span><br><span class="line">             .write()</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     ]</span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">     label: <span class="string">'打开更新助手'</span>,</span><br><span class="line">     type: <span class="string">'checkbox'</span>,</span><br><span class="line">     checked: db.get(<span class="string">'picBed.showUpdateTip'</span>).value(),</span><br><span class="line">     click () &#123;</span><br><span class="line">       <span class="keyword">const</span> value = db.read().get(<span class="string">'picBed.showUpdateTip'</span>).value()</span><br><span class="line">       db.read().set(<span class="string">'picBed.showUpdateTip'</span>, !value).write()</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">     role: <span class="string">'quit'</span>,</span><br><span class="line">     label: <span class="string">'退出'</span></span><br><span class="line">   &#125;</span><br><span class="line"> ])</span><br><span class="line"></span><br><span class="line"> tray.on(<span class="string">'right-click'</span>, () =&gt; &#123;</span><br><span class="line">   tray.popUpContextMenu(contextMenu)</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure><p>注意，菜单项的点击事件可以直接通过<code>click</code>属性来指定。上面我们是先通过了<code>Menu.buildFromTemplate()</code>这个方法创建了菜单，然后再在右键点击<code>Tray</code>图标的时候将其弹（PopUp)出来。</p><p>当然也有其他构建菜单的方法。可以通过Menu实例的<code>append</code>方法来加入<code>Menu Item</code>。如下例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> menu = <span class="keyword">new</span> Menu()</span><br><span class="line">menu.append(<span class="keyword">new</span> MenuItem(&#123; <span class="attr">label</span>: <span class="string">'Cut'</span>, <span class="attr">accelerator</span>: <span class="string">'CmdOrCtrl+X'</span> &#125;))</span><br><span class="line">menu.append(<span class="keyword">new</span> MenuItem(&#123; <span class="attr">type</span>: <span class="string">'separator'</span> &#125;)) <span class="comment">// 分割线</span></span><br><span class="line">menu.append(<span class="keyword">new</span> MenuItem(&#123; <span class="attr">label</span>: <span class="string">'Helper'</span>, <span class="attr">type</span>: <span class="string">'checkbox'</span>, <span class="attr">checked</span>: <span class="literal">true</span> &#125;))</span><br></pre></td></tr></table></figure><p>基本上有了上述的几个基本模块，我们的一个应用的骨架是基本搭建好了，拥有窗口、任务栏应用图标和菜单项。其他的Main进程的模块，并不是必须的，当会用到的时候将在之后的文章里逐步提及。下一节我们将来看renderer进程的开发。</p><h2 id="Renderer进程开发"><a href="#Renderer进程开发" class="headerlink" title="Renderer进程开发"></a>Renderer进程开发</h2><p>对于<code>electron-vue</code>而言，renderer进程其实大部分就是在写我们平时常写的前端页面罢了。不过相对于平时在浏览器里写的页面，在electron里写页面的时候你还能用到不少非浏览器端的模块，比如<code>fs</code>，比如electron通过<code>remote</code>模块暴露给renderer进程的模块。接下去我们来看看renderer进程有哪些需要注意的地方。</p><h3 id="请使用Hash模式"><a href="#请使用Hash模式" class="headerlink" title="请使用Hash模式"></a>请使用Hash模式</h3><p>往常我们在写Vue的时候都比较喜欢开启路由的<code>history</code>模式，因为这样在浏览器的地址栏上看起来比较好看——没有hash的<code>#</code>号，就如同请求后端的url一般。然而需要注意的是，<code>history</code>模式需要后端服务器的支持。</p><p>可能很多朋友平时开发的时候没有感觉，那是因为vue-cli里在开发模式下启动的<code>webpack-dev-server</code>帮你实现了服务端的<code>history-fallback</code>的特性。所以在实际部署的时候，至少都需要在你的web服务器程序诸如<code>nginx</code>、<code>apache</code>等配置相关的规则，让前端路由返回给<code>vue-router</code>去处理。</p><p>而electron里也是如此。在开发模式下，由于使用的是<code>webpack-dev-server</code>开启的服务器，所以<code>BrowserWindow</code>加载的是来自于类似<code></code><a href="http://localhost:9080`这样的地址的页面。而在生产模式下，却是使用的`file://`的协议，比如`file://${__dirname}/index.html`来指定窗口加载的页面。" target="_blank" rel="noopener">http://localhost:9080`这样的地址的页面。而在生产模式下，却是使用的`file://`的协议，比如`file://${__dirname}/index.html`来指定窗口加载的页面。</a></p><p>因此，从上面的表述你也能明白了。假如我有一个子路由地址为<code>child</code>。如果不启用Hash模式，在开发模式下没啥问题，<code>http://localhost:9080/child</code>，但是在生产模式下，<code>file://${__dirname}/index.html/child</code>却是无法匹配的一条路径。因此在electron下，<code>vue-router</code>请不要使用<code>history</code>模式，而使用默认的<code>hash</code>模式。</p><p>那么上面的问题就迎刃而解，变为<code>file://${__dirname}/index.html#child</code>即可。</p><p>PicGo里加载的页面路由规则如下，从中你也能看出我使用的是<code>hash</code>模式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> winURL = process.env.NODE_ENV === <span class="string">'development'</span></span><br><span class="line">  ? <span class="string">`http://localhost:9080`</span></span><br><span class="line">  : <span class="string">`file://<span class="subst">$&#123;__dirname&#125;</span>/index.html`</span></span><br><span class="line"><span class="keyword">const</span> settingWinURL = process.env.NODE_ENV === <span class="string">'development'</span></span><br><span class="line">  ? <span class="string">`http://localhost:9080/#setting/upload`</span></span><br><span class="line">  : <span class="string">`file://<span class="subst">$&#123;__dirname&#125;</span>/index.html#setting/upload`</span></span><br></pre></td></tr></table></figure><h3 id="实现自己的titlebar"><a href="#实现自己的titlebar" class="headerlink" title="实现自己的titlebar"></a>实现自己的titlebar</h3><p>在上面讲<code>BrowserWindow</code>的时候，我说到有时为了应用的美观，并不想让我们的应用窗口采用系统默认的<code>titlebar</code>，而想用自己写的来实现。这样的话就在创建你的<code>BrowserWindow</code>的配置里加上一句</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">titleBarStyle: <span class="string">'hidden'</span></span><br></pre></td></tr></table></figure><p>这样就行了。然后你就可以自行在renderer进程的页面里模拟一个顶部的<code>titlebar</code>了，比如上面提到的<code>PicGo</code>的<code>titlebar</code>的样子。实际上代码也很简单：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"fake-title-bar"</span>&gt;</span></span><br><span class="line">  PicGo - &#123;&#123; version &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"handle-bar"</span> <span class="attr">v-if</span>=<span class="string">"os === 'win32'"</span>&gt;</span> <span class="comment">&lt;!-- 如果是windows系统 就加上模拟的操作按钮--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"el-icon-minus"</span> @<span class="attr">click</span>=<span class="string">"minimizeWindow"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"el-icon-close"</span> @<span class="attr">click</span>=<span class="string">"closeWindow"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后把这个titlebar的position置顶即可。</p><p>不过在平时的使用中，我们要注意，一般我们鼠标按住titlebar的时候是可以拖动窗口的。但是如果我们在不加可拖拽的属性之前，我们自己写的titlebar是不具备这样的特性的。要加上这个特性也很简单：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.fake-title-bar</span> &#123;</span><br><span class="line">  -webkit-app-region drag</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只需一条CSS，即可让你的titlebar可以拖拽。</p><p>不过在windows下，操作区的按钮（缩小、放大、关闭）长按应该是不能拖拽的，所以还需要：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.handle-bar</span> &#123;</span><br><span class="line">  -webkit-app-region no-drag</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变成<code>no-drag</code>，这样就实现了我们自己生成应用的titlebar了。</p><h3 id="drag-amp-drop的避免"><a href="#drag-amp-drop的避免" class="headerlink" title="drag&amp;drop的避免"></a>drag&amp;drop的避免</h3><p>通常我们用Chrome的时候，有个特性是比如你往Chrome里拖入一个pdf，它就会自动用内置的pdf阅读器打开。你往Chrome里拖入一张图片，它就会打开这张图片。由于我们的electron应用的<code>BrowserWindow</code>其实内部也是一个浏览器，所以这样的特性依然存在。而这也是很多人没有注意的地方。也就是当你开发完一个electron应用之后，往里拖入一张图片，一个pdf等等，如果不是一个可拖拽区域（比如PicGo的上传区），那么它就不应该打开这张图、这个pdf，而是将其排除在外。</p><p>所以我们将在全局监听<code>drag</code>和<code>drop</code>事件，当用户拖入一个文件但是又不是拖入可拖拽区域的时候，应该将其屏蔽掉。因为所有的页面都应该要有这样的特性，所以我写了一个vue的<code>mixin</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    <span class="keyword">this</span>.disableDragEvent()</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    disableDragEvent () &#123;</span><br><span class="line">      <span class="built_in">window</span>.addEventListener(<span class="string">'dragenter'</span>, <span class="keyword">this</span>.disableDrag, <span class="literal">false</span>)</span><br><span class="line">      <span class="built_in">window</span>.addEventListener(<span class="string">'dragover'</span>, <span class="keyword">this</span>.disableDrag)</span><br><span class="line">      <span class="built_in">window</span>.addEventListener(<span class="string">'drop'</span>, <span class="keyword">this</span>.disableDrag)</span><br><span class="line">    &#125;,</span><br><span class="line">    disableDrag (e) &#123;</span><br><span class="line">      <span class="keyword">const</span> dropzone = <span class="built_in">document</span>.getElementById(<span class="string">'upload-area'</span>) <span class="comment">// 这个是可拖拽的上传区</span></span><br><span class="line">      <span class="keyword">if</span> (dropzone === <span class="literal">null</span> || !dropzone.contains(e.target)) &#123;</span><br><span class="line">        e.preventDefault()</span><br><span class="line">        e.dataTransfer.effectAllowed = <span class="string">'none'</span></span><br><span class="line">        e.dataTransfer.dropEffect = <span class="string">'none'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeDestroy () &#123;</span><br><span class="line">    <span class="built_in">window</span>.removeEventListener(<span class="string">'dragenter'</span>, <span class="keyword">this</span>.disableDrag, <span class="literal">false</span>)</span><br><span class="line">    <span class="built_in">window</span>.removeEventListener(<span class="string">'dragover'</span>, <span class="keyword">this</span>.disableDrag)</span><br><span class="line">    <span class="built_in">window</span>.removeEventListener(<span class="string">'drop'</span>, <span class="keyword">this</span>.disableDrag)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在全局引入这个mixin即可。</p><h3 id="remote模块的使用"><a href="#remote模块的使用" class="headerlink" title="remote模块的使用"></a>remote模块的使用</h3><p>remote模块是electron为了让一些原本在Main进程里运行的模块也能在renderer进程里运行而创建的。以下说几个我们会用到的。</p><p>在<code>electron-vue</code>里内置了<code>vue-electron</code>这个模块，可以在vue里很方便的使用诸如<code>this.$electron.remote.xxx</code>来使用remote的模块。</p><h4 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h4><p><code>shell</code>模块的官方说明是：<code>Manage files and URLs using their default applications.</code>也就是使用文件或者URL的默认应用。通常我们可以用其让默认图片应用打开一张图片、让默认浏览器打开一个url。</p><p>如果我们想在renderer进程里点击一个按钮然后在默认浏览器里打开一个url的话就可以这样：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"openURL"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="undefined">    methods: &#123;</span></span><br><span class="line"><span class="undefined">      openURL () &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.$electron.remote.shell.openExternal(<span class="string">'https://github.com/Molunerfinn/PicGo'</span>)</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>是不是很方便？</p><p>更多详细的shell的用法可以参考<a href="https://electronjs.org/docs/api/shell" target="_blank" rel="noopener">文档</a>。</p><h4 id="dialog"><a href="#dialog" class="headerlink" title="dialog"></a>dialog</h4><p>有的时候我们会有打开原生的对话框的需求。比如<code>PicGo</code>的版本信息：</p><blockquote><p>macOS</p></blockquote><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fnje5uvnlrj20nc08kq3d" alt=""></p><blockquote><p>windows</p></blockquote><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fnje4njzafj20a60543yd" alt=""></p><p>这个时候就可以通过<code>dialog</code>这个模块来实现了。逻辑跟上面一样也是点击一个按钮打开一个dialog：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">openDialog () &#123;</span><br><span class="line">  <span class="keyword">this</span>.$electron.remote.dialog.showMessageBox(&#123;</span><br><span class="line">    title: <span class="string">'PicGo'</span>,</span><br><span class="line">    message: <span class="string">'PicGo'</span>,</span><br><span class="line">    detail: <span class="string">`Version: <span class="subst">$&#123;pkg.version&#125;</span>\nAuthor: Molunerfinn\nGithub: https://github.com/Molunerfinn/PicGo`</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多详细的dialog的用法可以参考<a href="https://electronjs.org/docs/api/dialog" target="_blank" rel="noopener">文档</a>。</p><h4 id="Menu和BrowserWindow的应用"><a href="#Menu和BrowserWindow的应用" class="headerlink" title="Menu和BrowserWindow的应用"></a>Menu和BrowserWindow的应用</h4><p>使用<code>Menu</code>可能很多人能够理解。但是为什么要使用<code>BrowserWindow</code>呢？因为需要定位你打开<code>Menu</code>的窗口。</p><p>在PicGo里，有一个点击按钮打开Menu的操作，大致如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">buildMenu () &#123;</span><br><span class="line">    <span class="keyword">const</span> template = [...]</span><br><span class="line">    <span class="keyword">this</span>.menu = Menu.buildFromTemplate(template)</span><br><span class="line">  &#125;,</span><br><span class="line">  openDialog () &#123;</span><br><span class="line">    <span class="keyword">this</span>.menu.popup(remote.getCurrentWindow) <span class="comment">// 获取当前打开Menu的窗口</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里的<code>menu.popup</code>就需要你指定一下打开这个menu的窗口。它将自动定位你点击的位置而弹出。</p><h3 id="main进程和renderer进程的通信"><a href="#main进程和renderer进程的通信" class="headerlink" title="main进程和renderer进程的通信"></a>main进程和renderer进程的通信</h3><p>在Vue里，如果是非父子组件通信，很常用的是通过<code>Bus Event</code>来实现的。而electron里的不同进程间的通信其实也很类似，是通过<code>ipcMain</code>和<code>ipcRenderer</code>来实现的。其中<code>ipcMain</code>是在<code>main</code>进程里使用的，而<code>ipcRenderer</code>是在<code>renderer</code>进程里使用的。</p><h4 id="ipcMain和ipcRenderer"><a href="#ipcMain和ipcRenderer" class="headerlink" title="ipcMain和ipcRenderer"></a>ipcMain和ipcRenderer</h4><p>官网的例子其实很简洁明了了，我放出来：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In main process.</span></span><br><span class="line"><span class="keyword">const</span> &#123;ipcMain&#125; = <span class="built_in">require</span>(<span class="string">'electron'</span>)</span><br><span class="line">ipcMain.on(<span class="string">'asynchronous-message'</span>, (event, arg) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arg)  <span class="comment">// prints "ping"</span></span><br><span class="line">  event.sender.send(<span class="string">'asynchronous-reply'</span>, <span class="string">'pong'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">ipcMain.on(<span class="string">'synchronous-message'</span>, (event, arg) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arg)  <span class="comment">// prints "ping"</span></span><br><span class="line">  event.returnValue = <span class="string">'pong'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In renderer process (web page).</span></span><br><span class="line"><span class="keyword">const</span> &#123;ipcRenderer&#125; = <span class="built_in">require</span>(<span class="string">'electron'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(ipcRenderer.sendSync(<span class="string">'synchronous-message'</span>, <span class="string">'ping'</span>)) <span class="comment">// prints "pong"</span></span><br><span class="line"></span><br><span class="line">ipcRenderer.on(<span class="string">'asynchronous-reply'</span>, (event, arg) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arg) <span class="comment">// prints "pong"</span></span><br><span class="line">&#125;)</span><br><span class="line">ipcRenderer.send(<span class="string">'asynchronous-message'</span>, <span class="string">'ping'</span>)</span><br></pre></td></tr></table></figure><p>其中<code>ipcMain</code>只有监听来自<code>ipcRenderer</code>的某个事件后才能返回给<code>ipcRenderer</code>值。而<code>ipcRenderer</code>既可以收，也可以发。</p><p>那么问题就来了，如何让<code>ipcMain</code>主动发送消息呢？或者说让main进程主动发送消息给<code>ipcRenderer</code>。</p><p>首先要明确的是，<code>ipcMain</code>无法主动发消息给<code>ipcRenderer</code>。因为ipcMain只有<code>.on()</code>方法没有<code>.send()</code>的方法。所以只能用其他方法来实现。有办法么？有的，用<code>webContents</code>。</p><h4 id="webContents"><a href="#webContents" class="headerlink" title="webContents"></a>webContents</h4><p><code>webContents</code>其实是<code>BrowserWindow</code>实例的一个属性。也就是如果我们需要在<code>main</code>进程里给某个窗口某个页面发送消息，则必须通过<code>win.webContents.send()</code>方法来发送。</p><p>代码大致如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In main process</span></span><br><span class="line"><span class="keyword">let</span> win = <span class="keyword">new</span> BrowserWindow(&#123;...&#125;)</span><br><span class="line">win.webContents.send(<span class="string">'img-files'</span>, imgs)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In renderer process</span></span><br><span class="line">ipcRenderer.on(<span class="string">'img-files'</span>, (event, files) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(files)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>所以必须指定要发送的窗口，才能将信息准确送达。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文详细地讲述了electron里<code>Main</code>进程和<code>Renderer</code>进程的基础知识和开发相关。很多都是我在开发<code>PicGo</code>的时候碰到的问题、踩的坑。也许文中简单的几句话背后就是我无数次的查阅和调试。内容相比第一篇多了不少，希望这篇文章能够给你的<code>electron-vue</code>开发带来一些启发。文中相关的代码，你都可以在<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a>的项目仓库里找到。希望本文能够给你带来帮助，这是我最开心的地方。如果喜欢，欢迎关注我的博客以及本系列文章的后续进展。</p><blockquote><p><strong>注：文中的图片除未特地说明之外均属于我个人作品，需要转载请私信</strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前段时间，我用&lt;a href=&quot;https://github.com/SimulatedGREG/electron-vue&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;electron-vue&lt;/a&gt;开发了一款跨平台（目前支持Mac和Windows）的免费开源的图床上传应用——&lt;a href=&quot;https://github.com/Molunerfinn/PicGo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PicGo&lt;/a&gt;，在开发过程中踩了不少的坑，不仅来自应用的业务逻辑本身，也来自electron本身。在开发这个应用过程中，我学了不少的东西。因为我也是从0开始学习electron，所以很多经历应该也能给初学、想学electron开发的同学们一些启发和指示。故而写一份Electron的开发实战经历，用最贴近实际工程项目开发的角度来阐述。希望能帮助到大家。&lt;/p&gt;&lt;p&gt;预计将会从几篇系列文章或方面来展开：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-1/&quot;&gt;electron-vue入门&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-2/&quot;&gt;Main进程和Renderer进程的简单开发&lt;/a&gt;&lt;/li&gt;&lt;li&gt;引入基于Lodash的json database——lowdb&lt;/li&gt;&lt;li&gt;跨平台的一些兼容措施&lt;/li&gt;&lt;li&gt;通过CI发布以及更新的方式&lt;/li&gt;&lt;li&gt;…（想到再写）&lt;/li&gt;&lt;/ol&gt;&lt;h2 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h2&gt;&lt;p&gt;&lt;code&gt;PicGo&lt;/code&gt;是采用&lt;code&gt;electron-vue&lt;/code&gt;开发的，所以如果你会&lt;code&gt;vue&lt;/code&gt;，那么跟着一起来学习将会比较快。如果你的技术栈是其他的诸如&lt;code&gt;react&lt;/code&gt;、&lt;code&gt;angular&lt;/code&gt;，那么纯按照本教程虽然在render端（可以理解为页面）的构建可能学习到的东西不多，不过在main端（electron的主进程）应该还是能学习到相应的知识的。&lt;/p&gt;&lt;p&gt;如果之前的文章没阅读的朋友可以先从之前的文章跟着看。&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="https://molunerfinn.com/categories/Web/"/>
    
      <category term="开发" scheme="https://molunerfinn.com/categories/Web/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="前端" scheme="https://molunerfinn.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Vue" scheme="https://molunerfinn.com/tags/Vue/"/>
    
      <category term="Electron" scheme="https://molunerfinn.com/tags/Electron/"/>
    
      <category term="Electron-vue" scheme="https://molunerfinn.com/tags/Electron-vue/"/>
    
  </entry>
  
  <entry>
    <title>Electron-vue开发实战0——Electron-vue入门</title>
    <link href="https://molunerfinn.com/electron-vue-1/"/>
    <id>https://molunerfinn.com/electron-vue-1/</id>
    <published>2018-01-11T17:30:00.000Z</published>
    <updated>2018-04-27T08:26:51.713Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间，我用<a href="https://github.com/SimulatedGREG/electron-vue" target="_blank" rel="noopener">electron-vue</a>开发了一款跨平台（目前支持Mac和Windows）的免费开源的图床上传应用——<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a>，在开发过程中踩了不少的坑，不仅来自应用的业务逻辑本身，也来自electron本身。在开发这个应用过程中，我学了不少的东西。因为我也是从0开始学习electron，所以很多经历应该也能给初学、想学electron开发的同学们一些启发和指示。故而写一份Electron的开发实战经历，用最贴近实际工程项目开发的角度来阐述。希望能帮助到大家。</p><p>预计将会从几篇系列文章或方面来展开：</p><ol><li><a href="https://molunerfinn.com/electron-vue-1/">electron-vue入门</a></li><li><a href="https://molunerfinn.com/electron-vue-2/">Main进程和Renderer进程的简单开发</a></li><li>引入基于Lodash的json database——lowdb</li><li>跨平台的一些兼容措施</li><li>通过CI发布以及更新的方式</li><li>…（想到再写）</li></ol><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p><code>PicGo</code>是采用<code>electron-vue</code>开发的，所以如果你会<code>vue</code>，那么跟着一起来学习将会比较快。如果你的技术栈是其他的诸如<code>react</code>、<code>angular</code>，那么纯按照本教程虽然在render端（可以理解为页面）的构建可能学习到的东西不多，不过在main端（electron的主进程）应该还是能学习到相应的知识的。</p><a id="more"></a><h2 id="Electron简要介绍"><a href="#Electron简要介绍" class="headerlink" title="Electron简要介绍"></a>Electron简要介绍</h2><p>一开始学习electron的时候，我被官网文档密密麻麻的概念所镇住了：</p><p><img src="https://ws1.sinaimg.cn/mw690/8700af19ly1fncsj44xlhj21xy3e8x1g" alt=""></p><p>概念太多，没有办法一下子接受。所以我自己学习完electron开发后，做了一张图。来看看图理解一下什么是<code>electron</code>，以及它包括了啥：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fncq342rk8j20cs0d63zd" alt=""></p><h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><p>electron由Node.js+Chromium+Native APIs构成。你可以理解成，它是一个得到了Node.js和基于不同平台的Native APIs加强的Chromium浏览器，可以用来开发跨平台的桌面级应用。</p><p>它的开发主要涉及到两个进程的协作——Main（主）进程和Renderer（渲染）进程。简单的理解两个进程的作用：</p><ol><li>Main进程主要通过Node.js、Chromium和Native APIs来实现一些系统以及底层的操作，比如创建系统级别的菜单，操作剪贴板，创建APP的窗口等。</li><li>Renderer进程主要通过Chromium来实现APP的图形界面——就是平时我们熟悉的前端开发的部分，不过得到了electron给予的加强，一些Node的模块（比如fs）和一些在Main进程里能用的东西（比如Clipboard）也能在Render进程里使用。</li><li>Main进程和Renderer进程通过<code>ipcMain</code>和<code>ipcRenderer</code>来进行通信。通过事件监听和事件派发来实现两个进程通信，从而实现Main或者Renderer进程里不能实现的某些功能。</li></ol><h3 id="进一步介绍"><a href="#进一步介绍" class="headerlink" title="进一步介绍"></a>进一步介绍</h3><p>说完了electron的组成和需要我们开发的部分，来说说它的优缺点。</p><p>优点：</p><ol><li>从上述介绍可以发现，除了不同平台Native APIs不同以外，Node.js和Chromium都是跨平台的工具，这也为electron生来就能做跨平台的应用开发打下基础。</li><li>开发图形界面前所未有的容易——比起C#\QT\MFC等传统图形界面开发技术，通过前端的图形化界面开发明显更加容易和方便。得益于Chromium，这种开发模式得以实现。</li><li>成熟的社区、活跃的核心团队，大部分electron相关的问题你可以在社区、github issues、Stack Overflow里得到答案。开发的障碍进一步降低。</li></ol><p>缺点：</p><ol><li>应用体积过大。由于内部包装了Chromium和Node.js，使得打包体积（使用<code>electron-builder</code>）在mac上至少是45M+起步，在windows上稍微好一点，不过也要35M+起步。不过相比早期打包体积100M+起步来说，已经好了不少。不过解压后安装依然是100M+起步。</li><li>受限于Node.js和Native APIs的一些支持度的问题，它依然有所局限。一些功能依然无法实现。比如无法获取在系统文件夹里选中的文件，而必须调用web的File或者node的fs接口才可以访问系统文件。</li><li>应用性能依旧是个问题。所以做轻量级应用没问题，重量级应用尤其是CPU密集型应用的话很是问题。</li></ol><h2 id="electron-vue的简要介绍"><a href="#electron-vue的简要介绍" class="headerlink" title="electron-vue的简要介绍"></a>electron-vue的简要介绍</h2><p>由于我自己是Vue的技术栈，所以就想在electron里使用vue。而vue只是在renderer进程里使用的框架，不涉及到main进程。如下图：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fncpxesazgj20dy08kwf1" alt=""></p><blockquote><p>因此react、angluar以及其他的前端开发框架同样适用。</p></blockquote><p>不过想要做到把vue和electron结合起来并不是一件特别容易的事。为了方便开发，我使用的是<a href="https://github.com/SimulatedGREG/electron-vue" target="_blank" rel="noopener">electron-vue</a>，这个是开发者<a href="https://github.com/SimulatedGREG" target="_blank" rel="noopener">SimulatedGREG</a>参考vue-cli的webpack模板骨架搭建的electron和vue结合的开发脚手架。由于我对于<code>vue-cli</code>非常熟悉，所以上手<code>electron-vue</code>非常容易。相比很多其他的教程或者其他electron+前端开发框架的组装方案，<code>electron-vue</code>给我感觉最好的是如下：</p><ol><li>只有一个<code>package.json</code>。而大部分其他的项目结构依然在使用两个<code>package.json</code>来应对main进程和renderer进程的依赖库。</li><li>内建完整的vue全家桶，省去再次配置vue-router和vuex的一些初期操作。</li><li>内建完整的webpack开发、生产等配置，开发环境舒适。</li><li>内建完整的开发、构建等<code>npm scripts</code>，使用非常方便。</li><li>内建完整的Travis-ci、Appveyor配置脚本，只需少数修改就能做到利用CI自动构建的应用发布。</li><li>完善的文档，清晰的项目结构。</li></ol><p>大体的项目结构如下，根据选择的不同设置结构会有所不同：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">my-project</span><br><span class="line">├─ .electron-vue</span><br><span class="line">│  └─ &lt;build/development&gt;.js files</span><br><span class="line">├─ build</span><br><span class="line">│  └─ icons/</span><br><span class="line">├─ dist</span><br><span class="line">│  ├─ electron/</span><br><span class="line">│  └─ web/</span><br><span class="line">├─ node_modules/</span><br><span class="line">├─ src</span><br><span class="line">│  ├─ main <span class="comment"># 主进程</span></span><br><span class="line">│  │  ├─ index.dev.js</span><br><span class="line">│  │  └─ index.js</span><br><span class="line">│  ├─ renderer <span class="comment"># 渲染进程</span></span><br><span class="line">│  │  ├─ components/</span><br><span class="line">│  │  ├─ router/</span><br><span class="line">│  │  ├─ store/</span><br><span class="line">│  │  ├─ App.vue</span><br><span class="line">│  │  └─ main.js</span><br><span class="line">│  └─ index.ejs</span><br><span class="line">├─ static/</span><br><span class="line">├─ <span class="built_in">test</span></span><br><span class="line">│  ├─ e2e</span><br><span class="line">│  │  ├─ specs/</span><br><span class="line">│  │  ├─ index.js</span><br><span class="line">│  │  └─ utils.js</span><br><span class="line">│  ├─ unit</span><br><span class="line">│  │  ├─ specs/</span><br><span class="line">│  │  ├─ index.js</span><br><span class="line">│  │  └─ karma.config.js</span><br><span class="line">│  └─ .eslintrc</span><br><span class="line">├─ .babelrc</span><br><span class="line">├─ .eslintignore</span><br><span class="line">├─ .eslintrc.js</span><br><span class="line">├─ .gitignore</span><br><span class="line">├─ package.json</span><br><span class="line">└─ README.md</span><br></pre></td></tr></table></figure><p>可以看到我们主要关注的两个文件夹：<code>src/main</code>和<code>src/renderer</code>分别对应的是main进程和renderer进程。我们的开发大体上也是围绕这两个文件夹展开。</p><h2 id="electron-vue安装"><a href="#electron-vue安装" class="headerlink" title="electron-vue安装"></a>electron-vue安装</h2><p>参考<a href="https://github.com/SimulatedGREG/electron-vue" target="_blank" rel="noopener">electron-vue</a>官方的文档给出的说明，搭建electron-vue的脚手架非常方便，使用vue-cli来安装它的模板即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果你没有vue-cli的话需要全局安装</span></span><br><span class="line">npm install -g vue-cli</span><br><span class="line"><span class="comment"># 然后使用vue-cli来安装electron-vue的模板</span></span><br><span class="line">vue init simulatedgreg/electron-vue my-project</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line"><span class="built_in">cd</span> my-project</span><br><span class="line">yarn <span class="comment"># or npm install</span></span><br><span class="line"><span class="comment"># 进入开发模式</span></span><br><span class="line">yarn run dev <span class="comment"># or npm run dev</span></span><br></pre></td></tr></table></figure><p>如果你是windows用户，在安装期间遇到了关于<code>node-gyp</code>、C++库等方面的问题的话，请参考官方文档给出的<a href="https://simulatedgreg.gitbooks.io/electron-vue/content/en/getting_started.html#a-note-for-windows-users" target="_blank" rel="noopener">解决办法</a>。</p><p>如果上述都没有问题，那么你将会看到如下界面：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fncs5yv0qdj21jk0wi44h" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>作为开篇，内容不多。不过把东西说清楚是必须的。对于electron开发其实是有两种声音的：</p><ol><li>很简单，不过就是web开发换了个壳</li><li>很难，需要了解很多原生的概念，不知道要怎么入手</li></ol><p>其实从本文介绍完，你应该要有一个粗略的认识。electron的开发其实包括了两个部分，一个是main进程的相关开发，一个是renderer进程的相关开发。对于renderer进程的开发对于大多数前端开发人员来说不难。main进程的相关开发，如果你想要把electron的main进程的所以特性都学一遍、都用一遍，确实是需要不少时间的。不过如果是从需求出发，从工程本身的需要出发，那么只需要用到的时候再去学习即可。不过要对Node.js能做到的事有个概念——它并不是万能的。</p><p>下一篇文章将会正式开启electron的开发，如果你对此有兴趣不妨关注我的博客的进展。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前段时间，我用&lt;a href=&quot;https://github.com/SimulatedGREG/electron-vue&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;electron-vue&lt;/a&gt;开发了一款跨平台（目前支持Mac和Windows）的免费开源的图床上传应用——&lt;a href=&quot;https://github.com/Molunerfinn/PicGo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PicGo&lt;/a&gt;，在开发过程中踩了不少的坑，不仅来自应用的业务逻辑本身，也来自electron本身。在开发这个应用过程中，我学了不少的东西。因为我也是从0开始学习electron，所以很多经历应该也能给初学、想学electron开发的同学们一些启发和指示。故而写一份Electron的开发实战经历，用最贴近实际工程项目开发的角度来阐述。希望能帮助到大家。&lt;/p&gt;&lt;p&gt;预计将会从几篇系列文章或方面来展开：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-1/&quot;&gt;electron-vue入门&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-2/&quot;&gt;Main进程和Renderer进程的简单开发&lt;/a&gt;&lt;/li&gt;&lt;li&gt;引入基于Lodash的json database——lowdb&lt;/li&gt;&lt;li&gt;跨平台的一些兼容措施&lt;/li&gt;&lt;li&gt;通过CI发布以及更新的方式&lt;/li&gt;&lt;li&gt;…（想到再写）&lt;/li&gt;&lt;/ol&gt;&lt;h2 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h2&gt;&lt;p&gt;&lt;code&gt;PicGo&lt;/code&gt;是采用&lt;code&gt;electron-vue&lt;/code&gt;开发的，所以如果你会&lt;code&gt;vue&lt;/code&gt;，那么跟着一起来学习将会比较快。如果你的技术栈是其他的诸如&lt;code&gt;react&lt;/code&gt;、&lt;code&gt;angular&lt;/code&gt;，那么纯按照本教程虽然在render端（可以理解为页面）的构建可能学习到的东西不多，不过在main端（electron的主进程）应该还是能学习到相应的知识的。&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="https://molunerfinn.com/categories/Web/"/>
    
      <category term="开发" scheme="https://molunerfinn.com/categories/Web/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="前端" scheme="https://molunerfinn.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Vue" scheme="https://molunerfinn.com/tags/Vue/"/>
    
      <category term="Electron" scheme="https://molunerfinn.com/tags/Electron/"/>
    
      <category term="Electron-vue" scheme="https://molunerfinn.com/tags/Electron-vue/"/>
    
  </entry>
  
  <entry>
    <title>2017小结</title>
    <link href="https://molunerfinn.com/2017-summary/"/>
    <id>https://molunerfinn.com/2017-summary/</id>
    <published>2017-12-27T21:01:00.000Z</published>
    <updated>2018-04-27T08:26:51.709Z</updated>
    
    <content type="html"><![CDATA[<p>年末了，赶着刚考完两门考试，在最后4门考试来临之前抽空写一下今年的小结。</p><a id="more"></a><p>今年格外忙。忙完本科毕设，又马上投入了研究生实验室的搬砖生涯。跟去年一样，列个今年的学习成果清单：</p><h1 id="过去的一年"><a href="#过去的一年" class="headerlink" title="过去的一年"></a>过去的一年</h1><h2 id="技术成果"><a href="#技术成果" class="headerlink" title="技术成果"></a>技术成果</h2><p><strong>2017.03~2017.05.07</strong> 开坑学习Three.js，完成了一个简单的<a href="https://github.com/Molunerfinn/Gear-system" target="_blank" rel="noopener">机械装置展示平台</a>（我的本科毕设）【Three.js+dat.gui】</p><p><strong>2017.05.23~2017.07.15</strong> 基于vue2+koa2重构了<a href="https://fj.teamsz.xyz/" target="_blank" rel="noopener">福建北邮人服务系统</a>，这是我自己的项目。开始引入eslint（以前嫌麻烦233），以后的项目也一并引入。期间在手写一些常用Vue组件的时候学习了不少东西，写了一篇<a href="https://molunerfinn.com/vue-components/">Vue组件的三种调用方式</a>【Vue2+Koa2】</p><p><strong>2017.05.26</strong> 为了上面那个项目简单做了一个基于<code>stylus</code>的栅格系统css——<a href="https://github.com/Molunerfinn/Melody.css" target="_blank" rel="noopener">Melody.css</a>，用来快速做响应式开发。【stylus】</p><p><strong>2017.06.07</strong> 协助解决实验室Vue项目里webpack的Hot Reload速度太慢的问题，做了个webpack的开发模式的插件<a href="https://github.com/Molunerfinn/webpack-dev-compile-optimize" target="_blank" rel="noopener">webpack-dev-compile-optimize</a>提升热重载速度（只在自己内部项目测试过），同期总结了一篇基于<a href="https://molunerfinn.com/Webpack-Optimize/">vue-cli项目的webpack构建优化文章</a>。【webpack】</p><p><strong>2017.07.07</strong> 博客开启持久化构建，依赖于github-page，不过加上了https以及进入了HSTS列表。第一次接触了<a href="https://travis-ci.org/" target="_blank" rel="noopener">Travis-CI</a>，发表了一篇<a href="https://molunerfinn.com/hexo-travisci-https/">经验文</a>。【Travis-CI】</p><p><strong>2017.08.09</strong> 开坑<a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener">hexo-theme-melody</a>，写一个送给妹子的hexo主题，效果见<a href="https://molunerfinn.com">我博客</a>即是。【hexo hexo-theme】</p><p><strong>2017.10.09</strong> 写每周电影推荐的时候因为嫌弃获取电影信息步骤繁杂，于是改造了一下早期写的node小爬虫<a href="https://github.com/Molunerfinn/dbmovie-spider" target="_blank" rel="noopener">dbmovie-spider</a>支持读取命令行信息了。【node】</p><p><strong>2017.10.28</strong> 开始<a href="https://github.com/Molunerfinn/FE-Learning" target="_blank" rel="noopener">练习算法</a>，并借机学习TypeScript和前端测试（采用了Jest）。 不过后来一直有其他事压着，没有持续，等考完试要继续。【TypeScript Jest】</p><p><strong>2017.11.02</strong> 开坑<a href="https://github.com/Molunerfinn/vue-koa-demo" target="_blank" rel="noopener">vue-koa-demo</a>项目的前端测试。同期写了一篇<a href="https://molunerfinn.com/Use-Jest-To-Test-Vue-Koa/">Jest 全栈测试的经验</a>博客。【Jest】</p><p><strong>2017.11.18</strong> 开坑<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a>，学习electron的基本开发流程，边写边学。最终完成了一个我现在写博客贴图片时很方便的工具。并于12月中发布正式版，还上了少数派首页推荐。【electron】</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fmvr6uah8rj21z20vk7wh" alt=""></p><blockquote><p>PS，在掘金也发了一遍<a href="https://juejin.im/post/5a30e4755188256e7a06cc3e" target="_blank" rel="noopener">推荐</a>不过没有被推荐到首页T T</p></blockquote><p>之后应该会发几篇electron开发的文章。</p><p><strong>2017.11.30</strong> 抽空把vue-koa-demo的<a href="https://github.com/Molunerfinn/vue-koa-demo/tree/ssr" target="_blank" rel="noopener">ssr</a>版本做了一下。踩了一些ssr的坑。</p><p>对比去年给自己立的目标：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">**算法**</span><br><span class="line"></span><br><span class="line">**数据结构**</span><br><span class="line"></span><br><span class="line">**Three.js -&gt; 浏览器3D建模**</span><br><span class="line"></span><br><span class="line">**回归JS语言基础**</span><br><span class="line"></span><br><span class="line">**学会玩Webpack2**</span><br><span class="line"></span><br><span class="line">**持续的项目开源**</span><br><span class="line"></span><br><span class="line">**Python简单入门**</span><br></pre></td></tr></table></figure><p>感觉除了Python没怎么学之外(尴尬)，其他的目标大致都有所建树，算是完成地还不错吧！</p><h2 id="期望、目标"><a href="#期望、目标" class="headerlink" title="期望、目标"></a>期望、目标</h2><p>依然要写下2018年需要学习的东西：</p><ul><li>算法、数据结构</li><li>Parcel</li><li>TypeScript</li><li>Puppeteer自动化测试</li><li>PWA</li><li>给开源库提PR</li><li>github robot</li><li>如果可以，学习一下react</li></ul><h2 id="随笔"><a href="#随笔" class="headerlink" title="随笔"></a>随笔</h2><p>这一年来的前端的学习之路，收获还是不少的。比起去年来说，我自己觉得收获最大的就是在开源社区跟开发者、使用者的交流更多了。因为自己也有开源项目，所以很多时候一些情况也是第一次见：比如第一次遇到PR（开心不已），第一次给开源库提issue，第一次跟开发者讨论项目细节等等。今年还没有给开源库提过PR，所以明年的目标是来一个吧~</p><p>今年也是前端框架、库井喷的一年。各种新的技术涌现、较新的技术逐渐走向成熟、成熟的项目走向稳定。这种感觉似乎从我两年半前学习前端的时候就有了，不过今年真的特别强烈。也因此才有那篇流传甚广的《2017年学JavaScript是怎样的一种体验》。前端要学的东西太多了啊。不过我觉得虽然看似多，作为前端工程师，还是要有自己的大体学习路线。</p><p>我认为如今前端工程师应当分成两类，</p><ol><li>结合Node的偏向全栈的前端，他们更注重网站的访问优化、性能提升、毫秒级别的用户体验。</li><li>结合CSS\JS的偏向用户端特效的“纯”前端工程师。这部分的前端工程师通常来说必须要有自己的设计认知。</li></ol><p>很多优秀的前端工程师都是设计师出身。比如TJ，比如尤雨溪。但是却不是很常听说优秀的设计师是前端工程师出身。这就是因为现在很多学前端的人还是在认为自己能够写个页面、套个模板，厉害点的还原个页面就行了。殊不知，你要学习的不仅仅是前端配套的HTML\CSS\JS，你还需要知道结合了Nodejs后带来的一系列现代开发工具和工程化的流程。不再是只会用个bootstrap+jquery做个页面就完事的年代了。刀耕火种的年代已经过去，可是还是有人在抓着旧石器不放。</p><p>不过还是需要强调一下，基础真的很重要。我身边遇到太多半路“出家”，自愿也好，被迫也罢来学前端的同学，他们很多都是草草几天看完HTML\CSS\JS基础，然后就直接用上Vue、React来写项目了。连npm都不知道是什么东西的他们，很多时候写起前端来非常痛苦。前端不再是以前那样认为的是一门可以速成的技术了啊，现在而言，至少入门门槛高了不少。</p><p>前端圈还是太浮躁了点。还是沉下心来，好好钻研自己喜欢的技术吧。</p><p>另外，由于最近出现的诸如PWA、Electron、RN、微信小程序等由前端主导的新技术，很多人就说了“啊iOS开发要完啦”、“啊安卓开发要完啦”、“要转行前端啦”等，我觉得其实还没有必要恐慌到那个程度。诚然如今前端能做的事不少，但是局限性还是很强。PWA由于依赖高版本Chrome在一般安卓机器上体验依然不怎么样，想做出像原生一样的效果还是受限于机能，iOS就更别说了，虽然safari开始支持service worker，但支持PWA还有待时日；Electron虽然能开发跨端应用，不过还有很多的局限，比如应用体积实在大，比如无法获取外部当前鼠标选中的文件等等。所以对于新技术应该理性看待，自己亲手实践一下，而不应盲目从众。</p><h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><p><strong>今年的技术栈成长：</strong></p><ul><li>更加深入Vue的开发</li><li>开始学习Three.js</li><li>开始用上ESLint</li><li>开始学习TypeScript</li><li>开始使用前端测试（Jest）</li><li>开始学习Electron</li><li>开始练习算法</li><li>对前端工程化+自动化有更多的实践和体会</li><li>持续维护三个开源项目：<a href="https://github.com/Molunerfinn/vue-koa-demo" target="_blank" rel="noopener">vue-koa-demo</a>、<a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener">hexo-theme-melody</a>、<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a></li><li>学习持续集成</li></ul><p>希望我的2018年能够继续有所收获！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;年末了，赶着刚考完两门考试，在最后4门考试来临之前抽空写一下今年的小结。&lt;/p&gt;
    
    </summary>
    
      <category term="日志" scheme="https://molunerfinn.com/categories/%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="随笔" scheme="https://molunerfinn.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>一周一部好电影IV【WEEK186 一级恐惧】</title>
    <link href="https://molunerfinn.com/PerfectMoviePerWeek4/"/>
    <id>https://molunerfinn.com/PerfectMoviePerWeek4/</id>
    <published>2017-12-19T23:50:00.000Z</published>
    <updated>2018-04-27T08:26:51.713Z</updated>
    
    <content type="html"><![CDATA[<h3 id="2017-12-17-WEEK186-一级恐惧"><a href="#2017-12-17-WEEK186-一级恐惧" class="headerlink" title="2017-12-17 WEEK186 一级恐惧"></a>2017-12-17 WEEK186 一级恐惧</h3><p>一级恐惧——————————————Primal Fear<br><img src="https://img.piegg.cn/week186.jpg?imageslim" alt="一级恐惧" title="一级恐惧"></p><a id="more"></a><ul><li>导演：格里高利·霍布里特</li><li>主演：理查·基尔/劳拉·琳妮/约翰·马奥尼/阿尔法·伍达德/弗兰西斯·麦克多蒙德/爱德华·诺顿/特瑞·欧奎恩/安德鲁·布劳尔/斯蒂文·鲍尔/乔·斯帕诺/托尼·普拉纳/斯坦利·安德森/毛拉·蒂尔内/乔恩·塞达/瑞格·罗杰斯</li><li>片长：129 分钟</li><li>影 片类型：剧情/悬疑/惊悚/犯罪</li><li>豆 瓣评分：8.4/10(from88,522users)</li><li>IMDB评分：7.7/10(from146,891users)</li></ul><p>Hi，各位好久不见。本周给大家推荐的是一部96年的悬疑惊悚电影。你如果看过《搏击俱乐部》，一定不会忘记爱德华·诺顿饰演的杰克。而作为他的荧幕处女座，本片他虽然作为一个配角却已经技惊四座。当然主角的演技也不容忽视。可以说本片的一大亮点在于演员的精湛功力。</p><p>歌颂完演技，来说说这部片子的实质。本片讨论的核心就在于正义。何为正义？通常我们觉得某个案子里，A是好人，B是坏人。那么B就应该受到惩罚，A就是应该伸张正义。然而很多时候，好人坏人的界定却很模糊。在某些情况下，A可能是好人，但是在某些情况下A就有可能是坏人。所以世间万事并不能简单的来下定义。正义正是如此。本片探讨的正义，在不同的情形下有不同的理解。而本片最让人觉得恐惧，并且赞叹的地方莫过于结局。那是来自内心的恐惧，那是Primal Fear。非常有意思的一部电影，值得一看。</p><hr><h3 id="2017-12-12-WEEK185-不可饶恕"><a href="#2017-12-12-WEEK185-不可饶恕" class="headerlink" title="2017-12-12 WEEK185 不可饶恕"></a>2017-12-12 WEEK185 不可饶恕</h3><p>不可饶恕——————————————용서는 없다<br><img src="https://img.piegg.cn/week185.jpg?imageslim" alt="不可饶恕" title="不可饶恕"></p><!--more--><ul><li>导演：金亨俊</li><li>主演：薛耿求/韩惠珍/柳昇范</li><li>片长：125分钟</li><li>影 片类型：惊悚</li><li>豆 瓣评分：7.7/10(from28,231users)</li><li>IMDB评分：7.4/10(from3,799users)</li></ul><p>Hi，各位好久不见！今天（12月13日）是南京大屠杀80周年纪念日，国家公祭日，让我们先为当年遇难的同胞默哀。勿忘国耻！</p><p>本周给大家推荐的电影是来自韩国的《不可饶恕》。秉承了韩国惊悚、悬疑电影的一贯风格，这部电影从一开始就是比较吸引眼球的。不过与其他的悬疑电影不同的是，它的凶手很早就暴露在观众面前了。失去了这一重大悬念的话，电影还有可看的空间吗？有。它从一开始就铺下了“天罗地网”就等你掉进去。</p><p>老戏骨薛耿求的演技自然不必说。不过我觉得这部电影还是胜在了编剧和情节。尤其是结尾的逆天结局，对于大多数观众来说就是一记全垒打了。不过这部电影的硬伤也很严重。对于结局的不同理解都会暴露出不同的硬伤，这也是它比较遗憾的地方——不过能够有如此大胆构思的编剧也是绝了，毕竟它只是一部电影，不能完全用现实世界的条件去约束它。而片中透露出的复仇的火焰，比我当初看《老男孩》的时候有过之而无不及。好电影，值得一看！</p><hr><h3 id="2017-12-05-WEEK184-天才枪手"><a href="#2017-12-05-WEEK184-天才枪手" class="headerlink" title="2017-12-05 WEEK184 天才枪手"></a>2017-12-05 WEEK184 天才枪手</h3><p>天才枪手——————————————ฉลาดเกมส์โกง<br><img src="https://img.piegg.cn/week184.jpg?imageslim" alt="天才枪手" title="天才枪手"></p><!--more--><ul><li>导演：纳塔吾·彭皮里亚</li><li>主演：茱蒂蒙·琼查容苏因/查侬·散顶腾古/依莎亚·贺苏汪/披纳若·苏潘平佑/塔内·瓦拉库努娄/莎琳雷特·托马斯/伊戈·米基塔斯/帕辛·宽萨塔彭/萨哈贾克·波斯安吉特/坎嘉娜·维耐潘尼/育塔彭·瓦拉努科洛楚/诺帕瓦特·里基特王</li><li>片长：130分钟</li><li>影 片类型：剧情/悬疑/犯罪</li><li>豆 瓣评分：8.2/10(from192,362users)</li><li>IMDB评分：8.0/10(from4,424users)</li></ul><p>Hi，各位，好久不见！本期给大家推荐的是一部前段时间比较热门的一部泰国电影《天才枪手》。之前一直没时间看看它。本周拿出时间看完后，不禁赞叹，能把一部题材并不复杂的电影拍得如此吸引人真的超出了我的想象。</p><p>不管你看没看过这部电影，从中文翻译过来的片名里你也大概能知道本片在说的是什么。这是一部根据真实事件改编的电影（有趣的是，真实事件里的主人公是中国人，然而却被泰国导演拿去拍电影了），讲的就是我们从小到大或多或少都会接触的一个东西——考试作弊。我觉得从小到大，大大小小的考试、测验里，说自己没有做过弊的同学应该不多。所以在这部电影里，主角作弊的时候，不管是导演的拍摄手段还是气氛渲染，我觉得观众在看这部电影的过程中会不自主的把自己和主角联系在一起，所以那种紧迫感就油然而生了。</p><p>当然如果只是讲作弊的故事自然不够过瘾。本片里对于泰国的一些社会现象和人性的变化都做了自己理解的阐述。主角们的性格也各自有着鲜明的对比，几个演员的演技也比起国内同期的新生代演员来得更加成熟和有力。而影片里的插曲配乐也是难得的加分项。可能结局会让人有所失望，不过我觉得这个结局毕竟还是比较符合叙事和电影想要表达的思想——命运在自己手里，一切取决于我。好电影，值得一看。</p><hr><h3 id="2017-11-26-WEEK183-嘉年华"><a href="#2017-11-26-WEEK183-嘉年华" class="headerlink" title="2017-11-26 WEEK183 嘉年华"></a>2017-11-26 WEEK183 嘉年华</h3><p>嘉年华——————————————Angels Wear White<br><img src="https://img.piegg.cn/week183.jpg?imageslim" alt="嘉年华" title="嘉年华"></p><!--more--><ul><li>导演：文晏</li><li>主演：文淇/周美君/史可/耿乐/刘威葳/彭静/王栎鑫/李梦男</li><li>片长：107分钟</li><li>影 片类型：剧情</li><li>豆 瓣评分：8.6/10(from27,228users)</li><li>IMDB评分：7.2/10(from195users)</li></ul><p>Hi，各位好久不见。最近的一个月来，社会上发生了很多事，很多不是很好的事。不过这部电影能够过审，能够上映，却真的是一件最难得的事了。</p><p>相信很多人都看过《熔炉》这部韩国电影，这部取材自真实事件，优秀的剧本+实力派的演员演绎的电影，自是获得无数赞誉，并且对韩国社会产生了意义深远的影响。而很多人把《嘉年华》这部电影比作中国版的《熔炉》，但我觉得这是不对的。不是说《熔炉》不好，《熔炉》这部好电影也是我以前推荐过的。我觉得更难得的是，我们拍出了《熔炉》这个级别的电影，而不是中国版的它——是难得的，是进步，伟大的一步。</p><p>从剧情角度上来说，它可能不如《熔炉》“好看”。但我认为这部电影不是以“好看”“不好看”来鉴别的。它更多的是把这个社会对于幼童被性侵之后的种种态度，克制而坚决地表达了出来。它虽然是一部虚构的电影，但是它却时时刻刻能发生在我们的国家，我们的身边。</p><p>片名的中文是《嘉年华》。但是英文名却很有意思的是《Angels Wear White》（天使穿着白衣）。与熔炉绝望的结局不同的是，《嘉年华》给出的结局，是开放的。有可能变得更好，也有可能一直糟糕下去，不过它带给我们的思考却是延续的，至少希望还是有的。我们在指责影片中那些令人发指的人物的行径的同时，可曾想过，如果事情发生在我们的身边，我们是否依然只是操起键盘一阵轰炸，茶余饭后一阵笑谈，三日之后相忘于江湖呢？我一直说，从电影中反观社会。《熔炉》之后改变了韩国，而《嘉年华》之后呢？看着那寥寥无几的排片，少得可怜的宣传，我曾想过的一些波澜，看来还是无法在我们的社会中惊起一些水花。</p><p>我感动的是在观影中大家的安静，凝重和沉思。豆瓣上的一句话我看完，印象非常深刻但也非常痛心：“我们拍出了熔炉一样的电影，却没有熔炉一样的观众”。我希望这部电影应该是当下所有国人都应该观看的一部电影，因为，它真的是一部好电影。</p><hr><h3 id="2017-11-12-WEEK182-非常嫌疑犯"><a href="#2017-11-12-WEEK182-非常嫌疑犯" class="headerlink" title="2017-11-12 WEEK182 非常嫌疑犯"></a>2017-11-12 WEEK182 非常嫌疑犯</h3><p>非常嫌疑犯——————————————The Usual Suspects<br><img src="https://img.piegg.cn/week182.jpg?imageslim" alt="非常嫌疑犯" title="非常嫌疑犯"></p><!--more--><ul><li>导演：布莱恩·辛格</li><li>主演：史蒂芬·鲍德温/加布里埃尔·伯恩/本尼西奥·德尔·托罗/凯文·波拉克/凯文·史派西/查兹·帕尔明特瑞/皮特·波斯尔思韦特/苏茜·爱米斯/吉安卡罗·埃斯波西托/丹·哈达亚/保罗·巴特尔/卡尔·布瑞斯勒/菲力浦·西蒙/杰克·希勒/克里斯汀·艾斯布鲁克</li><li>片长：106分钟</li><li>影 片类型：剧情/悬疑/惊悚/犯罪</li><li>豆 瓣评分：8.6/10(from113,108users)</li><li>IMDB评分：8.6/10(from820,898users)</li></ul><p>Hi，各位好久不见~本周给大家带来的是一部比较早期的电影——1995年的《非常嫌疑犯》。作为一部悬疑片，我觉得他的前几分钟的铺垫做的真的特别好。好的悬疑电影自然是在给观众想尽办法地留坑，然后再给你来一记重拳。不过明显的地方就是，你能感觉到留坑了，或者可能留坑了。</p><p>这部电影则不一样，因为你是从一开始就被牵着鼻子走。而且得知真相的你还没来得及喘气之时，非常嫌疑犯已经扬长而去。不得不说凯文·史派西的演技在那个时候有已经是非常棒了。想感受一下被致命一击的恍然大悟，然后再由衷发出惊叹的话，这部电影不能错过。</p><hr><h3 id="2017-11-09-WEEK181-暧暧内含光"><a href="#2017-11-09-WEEK181-暧暧内含光" class="headerlink" title="2017-11-09 WEEK181 暧暧内含光"></a>2017-11-09 WEEK181 暧暧内含光</h3><p>暧暧内含光——————————————Eternal Sunshine of the Spotless Mind<br><img src="https://img.piegg.cn/week181.jpg?imageslim" alt="暧暧内含光" title="暧暧内含光"></p><!--more--><ul><li>导演：米歇尔·贡德里</li><li>主演：金·凯瑞/凯特·温丝莱特/伊利亚·伍德/克斯汀·邓斯特/汤姆斯·杰·瑞恩/马克·鲁弗洛/简·亚当斯/大卫·克罗斯/汤姆·威尔金森/Amir Ali Said/Brian Price/Paulie Litt</li><li>片长：108分钟</li><li>影 片类型：剧情/爱情/奇幻</li><li>豆 瓣评分：8.4/10(from140,391users)</li><li>IMDB评分：8.3/10(from741,540users)</li></ul><p>Hi，各位好久不见~本周给大家推荐的是来自美国的一部很有意思的电影。关于记忆和爱情，它给出了别样的思考。</p><p>这部电影可能一开始节奏有点慢有点怪。不过从一个时刻开始，这部电影就真的开始走向令人惊讶的地步了。情节猎奇，但是却一点也不狗血，相反很有内涵。我记得以前，曾听过一个我觉得很有感觉的说法。你可以抹去一个人的记忆，但是你却没有办法抹去对这个人的感觉。我觉得这句话用在这部电影里真的很合适。虽然是一部奇幻电影，但是带给我们的启迪却远超一部现实主义的电影。很多时候面对问题的时候我们很喜欢回避、逃避。但是很多时候直面问题反而能得到更好的效果。我们可以选择忘却一些东西，但是无法忘却曾经为此付出的时间和感情。</p><p>也许你需要的不过是鼓起勇气说一声“对不起”，不过是一句“我错了”，不过是一句“我爱你”。但是选择了忘记，选择了逃避，你就选择了失去。好电影，值得一看。</p><hr><h3 id="2017-11-01-WEEK180-沉静如海"><a href="#2017-11-01-WEEK180-沉静如海" class="headerlink" title="2017-11-01 WEEK180 沉静如海"></a>2017-11-01 WEEK180 沉静如海</h3><p>沉静如海——————————————Le silence de la mer<br><img src="https://img.piegg.cn/week180.jpg?imageslim" alt="沉静如海" title="沉静如海"></p><!--more--><ul><li>导演：皮埃尔·布特龙</li><li>主演：朱莉·德拉姆/米歇尔·加拉布吕/托马斯·儒阿特/玛丽·布奈尔/Timothée Ferrand/Jean-Baptiste Puech/Jorg Schnass/Jorn Cambreleng</li><li>片长：93分钟</li><li>影 片类型：剧情/爱情/战争</li><li>豆 瓣评分：9.0/10(from27,068users)</li><li>IMDB评分：8.0/10(from593users)</li></ul><p>Hi，各位好久不见~本周给大家推荐的又是一部冷门佳作，来自法国和比利时的《沉静如海》。这部电影对于追求大场面、曲折的剧情的朋友们来说不太合适。相反，很适合那种一个人在安静的环境下静静的观看的电影。</p><p>背景在德国占领法国之后。德国开始傀儡法国的政府。很多德国士兵、军官并没有固定的居所。在此背景下，有一个德国军官被安排到一个只有女孩和她爷爷相依为命的大房子，作为暂住。由于刚刚战败，所以很多法国人对于德国人并无好感。片中女孩和爷爷对于这个德国军官也是如此。沉默以对，冷眼相看。就在这种情况下，绅士风范的军官和沉默不语的爷孙俩形成了强烈的对比。</p><p>爱国之心让她无法和他谈话。然而脱去戎装的他，本质并不坏，甚至还很有风度。矛盾贯穿着全剧，不断地虐着观众的心。女孩对军官说的唯一一句话也竟然是最后一句话，被战争吞噬的情感，被海洋沉默的话语。伴随着终了流泪的钢琴声，好电影值得一看。</p><hr><h3 id="2017-10-22-WEEK179-北壁"><a href="#2017-10-22-WEEK179-北壁" class="headerlink" title="2017-10-22 WEEK179 北壁"></a>2017-10-22 WEEK179 北壁</h3><p>北壁——————————————Nordwand<br><img src="https://img.piegg.cn/week179.jpg?imageslim" alt="北壁" title="北壁"></p><!--more--><ul><li>导演：菲利普·施特尔茨尔</li><li>主演：本诺·菲尔曼/弗洛里安·卢卡斯/约翰娜·沃卡莱克/格奥尔格·弗里德里希/乌尔里希·图库尔/埃尔温·施泰因豪尔/布兰科·萨马罗夫斯基/汉斯彼得·米勒</li><li>片长：126分钟</li><li>影 片类型：剧情/历史/冒险/运动</li><li>豆 瓣评分：8.5/10(from7,142users)</li><li>IMDB评分：7.4/10(from12,501users)</li></ul><p>Hi，各位好久不见。本周给大家推荐的是一部来自德国的佳作《北壁》。讲述的是1936年奥运会前夕，德国发起的挑战阿尔卑斯山艾格峰北壁的活动。两个德国年轻人向着第一个征服艾格峰北壁的人的光辉荣誉就去了。当年在没有准确的气象预报、没有良好的攀爬装备、没有前人的经验下，向艾格峰北壁（死亡之壁）发起挑战是需要多大的勇气。</p><p>本片根据真实事件改编，见证了艾格峰登山史上最惨烈的一次攀登。影片将当年的恶劣气候、登山者的勇气和决心，毅力和绝望、救援队的无能和无力、观众的冷漠和人性淋漓尽致地展现在你的面前。情节一步一步走向高潮，而且越来越紧凑，让人有种完全沉浸的感觉。</p><p>“此刻我不是为了拍照”。当女主将此话撂下，惊得编辑无话可说之际，真的对于人性的黑暗有无比强烈的谴责。“我不行了。”话音落下，悬挂在半空之中的托尼，是那么的悲壮而伟大。好电影，值得一看。</p><hr><h3 id="2017-10-09-WEEK178-危楼愚夫"><a href="#2017-10-09-WEEK178-危楼愚夫" class="headerlink" title="2017-10-09 WEEK178 危楼愚夫"></a>2017-10-09 WEEK178 危楼愚夫</h3><p>危楼愚夫——————————————Дурак<br><img src="https://img.piegg.cn/week178.jpg?imageslim" alt="危楼愚夫" title="危楼愚夫"></p><!--more--><ul><li>导演：尤里·贝科夫</li><li>主演：阿尔焦姆·贝斯特罗夫/娜塔莉亚·苏尔科娃/尤里·楚里洛/鲍里斯·涅夫佐罗夫/基里尔·波卢欣/亚历山大·科尔舒诺夫/奥尔嘉·萨莫希纳/达里娅·莫罗兹/谢尔盖·阿尔齐巴舍夫/叶莲娜·维克托罗夫娜·帕诺娃/德米特里·库利奇科夫/伊利亚·伊萨耶夫/马克西姆·平斯克尔/柳博夫·鲁坚科/伊丽娜·尼齐纳/戈尔戴·科勃泽夫/彼得·巴兰切耶夫</li><li>片长：116分钟</li><li>影 片类型：剧情</li><li>豆 瓣评分：8.4/10(from20,095users)</li><li>IMDB评分：8.0/10(from5,844users)</li></ul><p>Hi，各位好久不见。由于国庆节给自己放了个假，所以推荐就姗姗来迟。本期给大家推荐的是一部来自俄罗斯的冷门佳片——《危楼愚夫》。</p><p>一座危楼，一群愚夫，一堆渣滓，一个“愚夫”。全片暗黑的色调预示着这并不是一部轻松欢快的电影。它是俄罗斯的一部反映社会现实题材的电影——从正常的角度来说，它是虚构的。但是从某个角度来说，它却是真真实实地在发生。</p><p>众人皆醉我独醒。有着一腔热血和正义感的季马，既无法撼动在执政的政府人士，也无法撼动生活在社会底层已久的愚夫。讽刺的意味处处充满了电影，人物的描写也是入木三分。正如电影里说的一句话：“我们一起像猪一样地活着，也会像猪一样得死，就是因为我们彼此什么都不是。”看完电影，心情真的十分沉重。这部电影真的看完特别难受，因为在很多情况下我们甚至也像电影里的愚夫一般。好电影，值得一看。</p><hr><h3 id="2017-10-01-WEEK177-出租车司机"><a href="#2017-10-01-WEEK177-出租车司机" class="headerlink" title="2017-10-01 WEEK177 出租车司机"></a>2017-10-01 WEEK177 出租车司机</h3><p>出租车司机——————————————택시 운전사<br><img src="https://img.piegg.cn/week177.jpg?imageslim" alt="出租车司机" title="出租车司机"></p><!--more--><ul><li>导演：张勋</li><li>主演：宋康昊/托马斯·克莱舒曼/柳海真/柳俊烈/朴赫权/崔奎华/李静恩/郑镇荣/严泰久/朴珉熙/李容怡/高昌锡/全慧珍/柳恩美/丹尼尔·乔伊·奥尔布赖特/柳泰浩/金正洙/郑锡勇/任赫順/高成焕/李率求/韩成勇/申淡秀/白仁权/徐贤宇/车顺裴/许政度/柳淳哲/洪万彪/韩根燮/柳善英/..</li><li>片长：137分钟</li><li>影 片类型：剧情/历史</li><li>豆 瓣评分：9.1/10(from25,777users)</li><li>IMDB评分：7.9/10(from818users)</li></ul><p>Hi，各位，好久不见。本周给大家推荐的是来自今年韩国大热的《出租车司机》。这个片名真的是太太太普通不过了，以至于我相信很多人都没有观看的欲望。不过这部改编自真实故事，主演是宋叔的电影，还是没有让我失望。我之前推荐过不少韩国的好电影，其中宋叔的《辩护人》、《杀人回忆》也是一等一的佳作。本片的历史背景是1980年光州事件，（《辩护人》的历史背景是1981年的釜林事件）。当初在看辩护人的时候就对光州事件有所提及。而也是那个时候我才对韩国的历史、政治、以及相关的电影所要传递的信息有所了解。</p><p>宋叔在辩护人里催人泪下的辩护，到《出租车司机》里，摇身一变成了让人又爱又心疼的出租车司机。他真的把一个生活在局外、社会底层的人的性格、神态、言语演活了。光州事件在韩国虽然早已解密，但是世人并不完全会了解、会体会。这部电影从一个小角度拍摄，让整件事件能够更让人印象深刻、让人更难以忘怀。韩国的很多好电影，都会对政府的一些作为做出自己的一番论述。本片也不例外，相信很多看完这部电影的人，就真的会觉得当今的社会真的是前人撒血挥泪而铸就的。</p><p>当然，我也一直在说，从韩国电影看中国社会。从他们的电影中我们能够窥探到很多我们社会里类似的东西。而韩国的电影敢于说真话，敢于拍真事。我也希望我们的祖国能够发展能够进步到哪一天，对于一些事情能够转变看法，能够开诚布公。我也不希望“他们有改变国家的电影，我们有改变电影的国家”这句话，一直存在。好电影，值得一看。</p><hr><h3 id="2017-09-24-WEEK176-赛德克·巴莱"><a href="#2017-09-24-WEEK176-赛德克·巴莱" class="headerlink" title="2017-09-24 WEEK176 赛德克·巴莱"></a>2017-09-24 WEEK176 赛德克·巴莱</h3><p>赛德克·巴莱——————————————賽德克·巴萊<br><img src="https://img.piegg.cn/week176.jpg?imageslim" alt="赛德克·巴莱" title="赛德克·巴莱"></p><!--more--><ul><li>导演：魏德圣</li><li>主演：林庆台/马志翔/安藤政信/河原萨布/徐诣帆/温岚/罗美玲/徐若瑄/游大庆/林源杰/..</li><li>片长：153分钟(中国大陆/国际版)</li><li>影 片类型：剧情/历史/战争</li><li>豆 瓣评分：8.7/10(from93,115users)</li><li>IMDB评分：7.5/10(from5,773users)</li></ul><p>Hi，各位，好久不见。本周给大家推荐的是一部来自台湾的电影——《赛德克·巴莱》。看这个名字就总觉得很像外国的名字。而实际上这个是台湾原住民的族名。这部电影讲述的历史应该是大多数人（包括我）并不知道的一段历史——马关条约签订后，在1930年10月，台湾的原住民对日本侵略者发起的反抗事件——雾社事件。</p><p>由于那段时间，台湾处于日本的统治之下，所以这段历史国人了解甚少。所以我也是看完电影之后特地去找了相关背景知识得以恶补。这部电影真的只能用两个字来形容——伟大。不光是历史本身伟大，也是因为导演拍的伟大。</p><p>这部电影有很多个版本，大陆公映的是删减过后的152分钟，而台湾上映的是上下两集《太阳旗》和《彩虹桥》，有4个多小时的内容。后面的这个版本讲述的故事更加完整而震撼。这部电影把整个雾社事件的来龙去脉讲述地非常清楚，对于原住民的生活、捕猎、习性等等的描述也是前所未有的。主演是赛德克族的后裔，此前并不是演员，但是却演绎了一个让人印象极其深刻的莫那鲁道。</p><p>原住民的反抗，其实并没有国家的概念，而是更纯粹的为了生存为了尊严为了祖灵。日本带去的“文明”，奴役不了自由的心。野蛮的骄傲，也许只是以卵击石，但是却足够分量，足够有力。这是一部史诗，这是一部很棒的电影，推荐一看。</p><hr><h3 id="2017-09-17-WEEK175-大卫·戈尔的一生"><a href="#2017-09-17-WEEK175-大卫·戈尔的一生" class="headerlink" title="2017-09-17 WEEK175 大卫·戈尔的一生"></a>2017-09-17 WEEK175 大卫·戈尔的一生</h3><p>大卫·戈尔的一生——————————————The Life of David Gale<br><img src="https://img.piegg.cn/week175.jpg?imageslim" alt="大卫·戈尔的一生" title="大卫·戈尔的一生"></p><!--more--><ul><li>导演：艾伦·帕克</li><li>主演：凯文·史派西/凯特·温丝莱特/劳拉·琳妮/加布里埃尔·曼/梅丽莎·麦卡西/罗娜·迈特拉/</li><li>片长：130 分钟</li><li>影 片类型：剧情/悬疑/犯罪</li><li>豆 瓣评分：8.7/10(from85,052users)</li><li>IMDB评分：7.6/10(from94,416users)</li></ul><p>Hi，各位好久不见。本周给大家推荐的是一部2003年的电影，来自美国的《大卫·戈尔的一生》。这是一部很震撼的电影。从一开始强烈的节奏就把观众带入了整个剧情中。片名说的是大卫的一生，而实际上并没有把大卫从小到大的一生都叙述了一遍，而是把他人生中最重要的部分摘取出来进行的叙述。</p><p>大卫一生致力于废除德州的死刑，并与一群志同道合的人为之奋斗。但是政府却并不领情。整部电影从大卫的叙述以及女记者态度的转变中，以及牛仔的全程贯穿，让我们得以一步步走入这个迷雾重重的事件。作为一部剧情片，它的表现也许不够好，三天的回忆不足以把一件大事说清楚。而作为一部悬疑、犯罪片，它的闪光点就不能忽视。以至于直到影片的最后，你觉得你可能猜出了结局，但是你肯定猜不到最后的最后。</p><p>很伟大。人为理想而奋斗，人因理想而伟大。好电影，值得一看。</p><hr><h3 id="2017-09-03-WEEK174-敦刻尔克"><a href="#2017-09-03-WEEK174-敦刻尔克" class="headerlink" title="2017-09-03 WEEK174 敦刻尔克"></a>2017-09-03 WEEK174 敦刻尔克</h3><p>敦刻尔克——————————————Dunkirk<br><img src="https://img.piegg.cn/week174.jpg?imageslim" alt="敦刻尔克" title="敦刻尔克"></p><!--more--><ul><li>导演：克里斯托弗·诺兰</li><li>主演：菲恩·怀特海德/汤姆·格林-卡尼/杰克·劳登/哈里·斯泰尔斯/阿纽林·巴纳德/汤姆·哈迪/马克·里朗斯/巴里·基奥干/基里安·墨菲/詹姆斯·达西/肯尼思·布拉纳/李·阿姆斯特朗/詹姆斯·布鲁尔/达米安·勃纳尔/布莱恩·威纳尔/哈利·理查森/艾略特·提特恩索/凯文·格思里/巴比·洛克伍德/米歇尔·贝尔/比利·豪尔/迈克尔·凯恩/约翰·诺兰/米兰达·诺兰/..</li><li>片长：107分钟</li><li>影 片类型：剧情/历史/战争</li><li>豆 瓣评分：8.6/10(from180,232users)</li><li>IMDB评分：8.4/10(from204,636users)</li></ul><p>Hi，各位好久不见。这连续三周都是推荐当下上映最热的电影，让我有点愧疚。不过这几周的电影真的都相当不错。</p><p>以前也说过，我喜欢上看电影是从看战争电影开始的，启蒙电影是《拯救大兵瑞恩》。也是从那个时候开始对战争史感兴趣。诺兰拍《敦刻尔克》这部电影是为了填补空白——不过在观众大多都知道历史的情况下，是拍成一部电影还是拍成一部纪录片就很考验诺兰的功力了。很显然诺兰选择了前者。敦刻尔克大撤退的发生，很重要的一点是得归功于希特勒著名的禁止装甲部队再前进的命令。这个命令让龟缩在敦刻尔克的英法联军能够有喘息之机，跨过英吉利海峡撤回英国。</p><p>而诺兰并没有遵循一条时间线的叙事方式，甚至没有交待太多敦刻尔克大撤退发生前的故事。切入点直接就是敦刻尔克的海滩，成批的等待救援的部队，以及德国空军的空袭。海陆空三线，三个空间；一周、一天、一小时，三个时间线；诺兰将这3个时空有机地结合在了一起。零碎的故事最好看的就是交汇的部分。而诺兰在交汇的部分设置的情节、音乐与气氛可以说让人窒息。不从战争局外人的角度来描写敦刻尔克，而是从普通人的视角去看待这次撤退。这种视角也是非常独特的。没有了解过历史的或者只是知道皮毛的话也许会对这部电影产生一些偏见。但是真正了解了历史再去看待这部电影的话，那么将是一部上等的佳作。</p><hr><h3 id="2017-08-27-WEEK173-遇见你之前"><a href="#2017-08-27-WEEK173-遇见你之前" class="headerlink" title="2017-08-27 WEEK173 遇见你之前"></a>2017-08-27 WEEK173 遇见你之前</h3><p>遇见你之前——————————————Me Before You<br><img src="https://img.piegg.cn/week173.jpg?imageslim" alt="遇见你之前" title="遇见你之前"></p><!--more--><ul><li>导演：西娅·夏罗克</li><li>主演：艾米莉亚·克拉克/山姆·克拉弗林/珍妮·麦克蒂尔/查尔斯·丹斯/布兰登·柯伊尔/珍娜·科尔曼/马修·刘易斯/本·劳埃德-休斯/凡妮莎·柯比/斯蒂芬·皮科克/马修·约翰·摩尔利/汉娜·弗林/</li><li>片长：110分钟</li><li>影 片类型：剧情/爱情</li><li>豆 瓣评分：7.5/10(from90,085users)</li><li>IMDB评分：7.4/10(from124,258users)</li></ul><p>Hi，各位好久不见~借着本周一是七夕的“东风”，给大家推荐一部爱情电影——《遇见你之前》。龙妈在这部电影里的面部表情堪称一绝。而男主也是从头帅到尾。但是与一般的爱情电影不同的地方是，它不只是依靠主演的高颜值和一些夸张的情节来博得观众的眼球——相反，它依靠的两个主演的演技，以及循序渐进的情节+并没有落入俗套的结局征服了观众。</p><p>影片里塑造的男主其实是十分难能可贵的一种人。正因为他这种性格，才会让人对他肃然起敬。在遇见女主之前，他的生活是多么的枯燥无味。而遇见了女主之后，他开始渐渐能够感受到生活的美好而去享受这种生活——不过这也从另外一个方面刺激了他脆弱的神经。</p><p>我们当然想着活下去是最好的结局，毕竟活着就有机会，活着就有希望。但是在某些情况下，这种绝对的理念也许并不适用于全部人。理解与尊重，互相扶持与关爱，则已是大爱。好的电影，值得一看。</p><hr><h3 id="2017-08-20-WEEK172-二十二"><a href="#2017-08-20-WEEK172-二十二" class="headerlink" title="2017-08-20 WEEK172 二十二"></a>2017-08-20 WEEK172 二十二</h3><p>二十二——————————————二十二<br><img src="https://img.piegg.cn/week172.jpg?imageslim" alt="二十二" title="二十二"></p><!--more--><ul><li>导演：郭柯</li><li>片长：99分钟(公映版)</li><li>影 片类型：纪录片</li><li>豆 瓣评分：8.9/10(from61,759users)</li><li>IMDB评分：8.5/10(from74users)</li></ul><p>Hi各位，好久不见。本周给大家推荐的，是当下口碑最高、呼声最大的一部纪录片《二十二》。不为别的，就为着这片名的数字如今只剩下八，而且将会逐渐更少。日本侵华期间对二十万中国妇女的蹂躏，兽行是不可抹去的历史。随着时间越来越长，当年受害的老人们也在逐渐老去。有人说，这部片揭露老人的伤疤，十恶不赦。然而，看完整部电影，你才能感受到导演的拍摄，很克制，但是很有感染力。</p><p>要在90多分钟内，诉说22个老人的故事，真的太难。但是从影片中我们真的能够感受到，这些老奶奶的生活态度普遍是乐观而开朗的。在不去回想那段历史的时候，也能看到她们嘴上最淳朴的笑容。</p><p>影片里还有很多其他帮助过、照顾过这些老人的社会人士，他们基本上都是发自内心的去做这些事——看了也是相当感动。</p><p>如果按照一部常规电影的视角来看这部纪录片，它没有什么情节，它没有什么高潮，它甚至“支离破碎”。但是，这部电影用最克制的力度，最朴实的角度，最尊敬的态度去给世人们呈现当前这些被称为慰安妇的受害者老人们的境况。这也是我第一部，全场安静的出奇，看到影片结尾，看完众筹名单，直到最后电影完全谢幕，观众才缓缓离场的电影。好电影，一定要去看。</p><hr><h3 id="2017-08-13-WEEK171-战狼2"><a href="#2017-08-13-WEEK171-战狼2" class="headerlink" title="2017-08-13 WEEK171 战狼2"></a>2017-08-13 WEEK171 战狼2</h3><p>战狼2——————————————战狼2<br><img src="https://img.piegg.cn/week171.jpg?imageslim" alt="战狼2" title="战狼2"></p><!--more--><ul><li>导演：吴京</li><li>主演：吴京/弗兰克·格里罗/吴刚/张翰/卢靖姗/丁海峰/淳于珊珊/余男/于谦/石兆琪/海蒂·玛尼梅可/奥列格·亚历山大罗维奇/阿隆·汤尼/泰勒·哈里斯/勃小龙/</li><li>片长：123分钟</li><li>影 片类型：动作/</li><li>豆 瓣评分：7.5/10(from300,880users)</li><li>IMDB评分：7.0/10(from1,262users)</li></ul><p>Hello各位，好久不见！这段时间事情比较多，所以暂时是两周一更。不过从下周开始就会恢复正常啦。</p><p>《战狼2》刚上映没多久我就去看啦。相信很多朋友也已经被这部国民热捧的现象级电影所吸引，去电影院看过啦。其实这篇推荐本应该两周前推出的，那个时候恰逢《战狼2》刚上映。</p><p>不过不管怎么说，不管你们看过没有我都还是要推荐一下这部电影——毕竟中国电影人好久没有像吴京这样拼的了。主旋律电影，去年上映的《湄公河行动》也收获了很多的赞誉——相比之下，相同点有很多：场景大、特效足、演员演技实力派、故事情节紧凑吸引人。战狼2也是一样，只不过它并不像湄公河行动一样是有事实依据，而是摘取一部分现实（中国11年撤侨事件）+自己改编合成的。中国的编剧在大部分情况下始终是比较薄弱的一环，战狼2其实也有一些薄弱的环节——但是它最成功的地方，在于塑造了一个中国式的孤胆英雄——这个在欧美大片中很容易看到的类似角色。吴京将这个中国式的孤单英雄演活了，演深刻了。从而让我们也知道了，原来国人的电影里也可以拥有这样酷、这样帅的英雄。</p><p>吴京更吸粉的地方在于他对于用人、用经费的诠释，让更多的观众路转粉，从而水涨船高地推动了这部电影高到惊人的票房。这部电影真的值得进电影院看，足够热血，足够好。</p><hr><h3 id="2017-07-16-WEEK170-月球"><a href="#2017-07-16-WEEK170-月球" class="headerlink" title="2017-07-16 WEEK170 月球"></a>2017-07-16 WEEK170 月球</h3><p>月球——————————————Moon<br><img src="https://img.piegg.cn/week170.jpg?imageslim" alt="月球" title="月球"></p><!--more--><ul><li>导演：邓肯·琼斯</li><li>主演：山姆·洛克威尔/凯文·史派西/多米妮克·麦克艾丽戈特/卡雅·斯考达里奥/本尼迪克特·王/马特·贝里/马尔科姆·斯图尔特/罗宾·查克/</li><li>片长：97 分钟</li><li>影 片类型：剧情/科幻/悬疑</li><li>豆 瓣评分：8.5/10(from133,219users)</li><li>IMDB评分：7.9/10(from279,893users)</li></ul><p>Hi，各位，好久不见，这段时间都是两周一更很抱歉，估计还要持续一次。下个月的时候就正常啦。<br>本周是一周一部好电影推荐的第170周。给大家推荐的事来自英国的《Moon》。名字真的非常简单。不过作为一部科幻电影，真的非常不简单。</p><p>世界观设定成，地球的清洁资源70%来自于月球上开采的清洁能源氦-3。不过令人诧异的是，在月球上负责开采、运送这种清洁能源的只有一个人，他的合同是3年。3年到期就可以回地球了。我们在影片中能看到月球生活的孤独与苦中作乐。</p><p>不过作为一部科幻片，前半段的平白无故毕竟让人有所乏味。于是这个时候本片把科幻的元素发扬了光大，让人不禁拍案叫绝。同时随着故事的推进，一桩丑陋的交易浮现在观众眼前。一点点让人对片中的男主感到揪心。而男主在剧中一人分饰两角的演技也真的是超棒。</p><p>美中不足的地方在于一些情节的转换过于戏剧化，而且有所欠妥。但是作为一部科幻电影，在结尾抛出的字眼，拷问着我们——为了自身利益是否就应该抛弃人性和良心呢？好电影，值得一看。</p><hr><h3 id="2017-07-09-WEEK169-夏日大作战"><a href="#2017-07-09-WEEK169-夏日大作战" class="headerlink" title="2017-07-09 WEEK169 夏日大作战"></a>2017-07-09 WEEK169 夏日大作战</h3><p>夏日大作战——————————————サマーウォーズ<br><img src="https://img.piegg.cn/week169.jpg?imageslim" alt="夏日大作战" title="夏日大作战"></p><!--more--><ul><li>导演：细田守</li><li>主演：神木隆之介/谷村美月/樱庭奈奈美/斋藤步/横川贵大/信泽三惠子/玉川纱己子/永井一郎/小林隆/清水优/田中要次/入山法子/板仓光隆/仲里依纱/富司纯子</li><li>片长：114分钟</li><li>影 片类型：喜剧/科幻/动画/冒险</li><li>豆 瓣评分：8.6/10(from100,022users)</li><li>IMDB评分：7.6/10(from19,018users)</li></ul><p>Hi，各位，好久不见，这段时间都是两周一更很抱歉，估计还要持续一次。下个月的时候就正常啦。<br>本周给大家推荐的一部轻松愉快的动画电影——《夏日大作战》。听起来就很欢快。</p><p>这是一个终有可能发生在我们身上的故事——随着计算机、网络、深度学习等等技术的不断发展，最终我们将会有一个独立于现实社会的虚拟社会。而在虚拟社会里发生的事却也最终会影响到现实社会。</p><p>其实这个故事在09年电影上映的时候，已经初见苗头。不过如今很多凤毛麟角已经出现了。虚拟货币的支付正在逐渐成为主流支付方式。越来越多的人在虚拟的游戏、社交中找到了在现实社会中找不到的成就感。细田守把一个可以拍成一部很好的真人电影搬到了动画世界中，但是依然处理的很好。亲情、友情、爱情的交汇；老一辈、年轻一辈处事的不同；虚拟世界的魅力与现实世界的美丽。一部动画电影的最后能够留下的是感动和温馨，其实已经是很大的成功。</p><p>茶余饭后不如抽个空看看，好电影，值得一看。</p><hr><h3 id="2017-07-02-WEEK168-黄海"><a href="#2017-07-02-WEEK168-黄海" class="headerlink" title="2017-07-02 WEEK168 黄海"></a>2017-07-02 WEEK168 黄海</h3><p>黄海——————————————황해<br><img src="https://img.piegg.cn/week168.jpg?imageslim" alt="黄海" title="黄海"></p><!--more--><ul><li>导演：罗泓轸</li><li>主演：河正宇/金允石/郑满植/李哲民 /李艾</li><li>片长：157分钟(韩国)</li><li>影 片类型：剧情/动作/犯罪</li><li>豆 瓣评分：8.4/10(from74,665users)</li><li>IMDB评分：7.4/10(from13,372users)</li></ul><p>Hi，各位，好久不见，由于这两周涉及毕业和搬迁事宜拖更了这么久实在抱歉。<br>本周给大家推荐的是一部来自韩国的电影《黄海》。这部电影里的中国元素不少，主要一个原因是主角河正宇是饰演一个中国朝鲜族的人。这部电影里，汉字、汉语在电影里也是随处可见。</p><p>明明打麻将经常输还是想靠打麻将赚点钱，明明可以好好工作赚点钱养家糊口却偏偏铤而走险。这部电影讲述了一个走投无路，除了执念什么都已经可以输得起的人，被逼入绝境从而铤而走险的故事。血腥、转折、诡计、绝望。河正宇在这部电影里炸裂的演技真的让人感到一丝凉意。</p><p>这部电影很多场景能够触动你的泪腺。我印象最深的就是久南扯下袜子绝望地包扎被流弹打中的手臂那令人心碎的哭泣和面容。但愿所有付出自己血汗的人们都能被世界宽容以待，但愿他们能够拥有自己的路，尊严地走下去。结尾有彩蛋，好的电影，值得一看。</p><hr><h3 id="2017-06-25-WEEK167-为你取名的那一天"><a href="#2017-06-25-WEEK167-为你取名的那一天" class="headerlink" title="2017-06-25 WEEK167 为你取名的那一天"></a>2017-06-25 WEEK167 为你取名的那一天</h3><p>为你取名的那一天——————————————犬に名前をつける日<br><img src="https://img.piegg.cn/week167.jpg?imageslim" alt="为你取名的那一天" title="为你取名的那一天"></p><!--more--><ul><li>导演：山田茜</li><li>主演：小林聪美/上川隆也/青山美乡</li><li>片长：107分钟</li><li>影 片类型：剧情</li><li>豆 瓣评分：8.4/10(from2,643users)</li><li>IMDB评分：7.0/10(from21users)</li></ul><p>Hi，各位，好久不见，由于这两周涉及毕业和搬迁事宜拖更了这么久实在抱歉。<br>本周给大家推荐的是一部来自日本的半纪录片式的电影《为你取名的那一天》。这部电影说实话，纪录片的感觉更重一些。它的魅力在于真实而感动。</p><p>这是一部讲述人和狗之间的故事的电影。它的制作跨了好多年，从311大地震到15年上映。导演是个爱狗的人士，在爱犬死去之后决定学习与狗有关的知识，并拍摄一部和狗有关的电影。日本的法律规定流浪狗要被收入专门的机构，一旦在一定期限内没有人认养，那么就处以安乐死。</p><p>电影里真实地记录了为了这些流浪狗的生存而奋斗的一群人，他们有的甚至为了它们放弃了很多东西，把救助、照顾它们视为一生的事业。还有很多鲜为人知的故事，也只有通过电影本身，你才能够感受到，很多时候我们养宠物，并不是做好了陪伴它们一生的决定。而这样是否对它们的生命来说是一种不负责任呢？既然责任这么重大，那么在认养宠物之前还是要好好考虑周到。这部电影的节奏比较慢，但是真实而感人，推荐一看。</p><hr><h3 id="2017-06-17-WEEK166-布达佩斯大饭店"><a href="#2017-06-17-WEEK166-布达佩斯大饭店" class="headerlink" title="2017-06-17 WEEK166 布达佩斯大饭店"></a>2017-06-17 WEEK166 布达佩斯大饭店</h3><p>布达佩斯大饭店——————————————The Grand Budapest Hotel<br><img src="https://img.piegg.cn/week166.jpg?imageslim" alt="布达佩斯大饭店" title="布达佩斯大饭店"></p><!--more--><ul><li>导演：韦斯·安德森</li><li>主演：拉尔夫·费因斯/托尼·雷沃罗利/艾德里安·布洛迪/威廉·达福/裘德·洛/爱德华·诺顿/西尔莎·罗南/蒂尔达·斯文顿/比尔·默瑞/蕾雅·赛杜/欧文·威尔逊/詹森·舒瓦兹曼/马修·阿马立克/F·默里·亚伯拉罕/汤姆·威尔金森/杰夫·高布伦/哈威·凯特尔</li><li>片长：100分钟</li><li>影 片类型：剧情/喜剧</li><li>豆 瓣评分：8.7/10(from286,815users)</li><li>IMDB评分：8.1/10(from534,539users)</li></ul><p>Hi，各位，好久不见~本周给大家推荐的是一部喜剧《布达佩斯大饭店》。喜剧给大家推荐的比较少，但是这部喜剧真的是吸引我从头看到尾完全无尿点。</p><p>这部电影第一个很显著的风格就是画面大小，只要是回顾的片段都是4:3的比例，而回忆的片段则是16:9（看完电影就知道这里的回顾和回忆的区别了）。看这部电影仿佛在看卡通片，色彩鲜艳、人物生动、剧情幽默而紧凑，动作夸张而搞笑。仿佛在看一部老电影，但是却别有一番韵味。全片以布达佩斯大饭店的前世今生作为主线，写了两代饭店经理的有趣的经历。一个饭店的兴衰，反映的是时代的更迭，历史的交替。影片的一些情节，偷窃、追杀、逃跑、越狱、通关等情节真的让人忍俊不禁，又感慨万分。</p><p>从古斯塔夫先生的身上你能看到一个真正的绅士，从Zero身上你能看到一个真正的忠实的门徒。而从整个布达佩斯大饭店，你可以看到旧时代的欧洲和新时代欧洲的变化。导演倾注的黑色幽默、思考都是值得你去观看的理由。好的电影，值得一看。</p><hr><h3 id="2017-06-11-WEEK165-一次别离"><a href="#2017-06-11-WEEK165-一次别离" class="headerlink" title="2017-06-11 WEEK165 一次别离"></a>2017-06-11 WEEK165 一次别离</h3><p>一次别离——————————————جدایی نادر از سیمین<br><img src="https://img.piegg.cn/week165.jpg?imageslim" alt="一次别离" title="一次别离"></p><!--more--><ul><li>导演：阿斯哈·法哈蒂</li><li>主演：佩曼·莫阿迪/蕾拉·哈塔米/萨瑞·巴亚特/沙哈布·侯赛尼/萨日娜·法哈蒂/梅里拉·扎雷伊/阿里-阿萨哈·萨哈巴齐/巴巴克·卡里米/吉米娅·侯赛伊妮/希尔·亚齐丹巴克什/萨哈巴努·佐哈多</li><li>片长：123分钟</li><li>影 片类型：剧情/家庭</li><li>豆 瓣评分：8.7/10(from123,108users)</li><li>IMDB评分：8.4/10(from166,080users)</li></ul><p>Hi，各位，好久不见~本周给大家推荐的是来自伊朗的《一次别离》。这部电影从侧面反映了伊朗的社会矛盾，而情节的生活化、戏剧化以及转折、结尾的点睛之笔都是这部电影的闪光之处。</p><p>从一部电影折射国家，通常这种话我会在一些韩国的电影里说。不过对于这部电影，这种话我也想说。两条线的交错，信仰和道德的冲突，诚实与爱的谎言的相悖，资产阶级和普通老百姓的相对。两边都有自己的苦衷，两边都有自己的坚持。出于爱，出于自己的信仰，坚持不肯放松，这样才让矛盾放大。其实我们没有办法去批判任何一方的行为，不管是护工和雇主的矛盾，还是父亲、女儿和母亲的矛盾，站在任何一方的角度，都是事出有因，都是有合理的考虑。</p><p>但是这样的矛盾才是最让人叹惋和揪心的。女儿为了父亲的撒谎，为了撒谎而流的泪；母亲为了女儿的奔走，争吵，为了父亲抵押房产，协调；父亲为了爷爷操碎了心；护工为了能养家糊口带着女儿远赴雇主家里护工，做着有可能违背信仰的工作；护工的丈夫为了争取公道不惜把自己逼到了底线；这一切，非常真实，而且动人。</p><p>伊朗的电影，比如之前推荐过的《推销员》也是相当不错。虽然不及印度的电影来得些许欢快，但是哪怕是一部手持拍摄的电影，也是别有一番韵味。好电影，值得一看。</p><hr><h3 id="2017-06-04-WEEK164-假如猫从世界上消失了"><a href="#2017-06-04-WEEK164-假如猫从世界上消失了" class="headerlink" title="2017-06-04 WEEK164 假如猫从世界上消失了"></a>2017-06-04 WEEK164 假如猫从世界上消失了</h3><p>假如猫从世界上消失了——————————————世界から猫が消えたなら<br><img src="https://img.piegg.cn/week164.jpg?imageslim" alt="假如猫从世界上消失了" title="假如猫从世界上消失了"></p><!--more--><ul><li>导演：永井聪</li><li>主演：佐藤健/宫崎葵/滨田岳/奥野瑛太/石井杏奈/奥田瑛二/原田美枝子</li><li>片长：103分钟</li><li>影 片类型：剧情/奇幻</li><li>豆 瓣评分：7.2/10(from14,430users)</li><li>IMDB评分：7.1/10(from1,031users)</li></ul><p>Hi，各位，好久不见，这周生病了没来得及更新，十分抱歉！</p><p>本周给大家推荐的是一部来自日本的《加入猫从世界上消失了》。这部标榜着“奇幻”和“剧情”，看似一部“狗血”的电影，实际上却把奇幻讲得很贴心，把剧情讲得很动人。这是一部讲述生命的意义，讲述爱情、友情、亲情的电影。如果一定要你选择某个东西消失于世界，从未诞生，从未有过，你会选择什么？这个世界到底会怎么样。</p><p>还有什么比生命更重要的东西么？如果活着的每天，你没有了友情，没有了爱情，没有了亲情，没有了周遭熟悉的一切，恐怕活着也是一种受罪吧？这部电影在描述的时候，不断抛出的一个观点便是，珍惜当下，珍惜你爱以及爱你的人吧。也许我们都有着或多或少的坎坷，不过还是有很多值得去体会去感受的美好，生活依然可以愉快的继续。直到面对死亡的时候，我们能够无悔地说我们来过这世上。假如猫从世界上消失了，有多少人会记得；假如你从世界上消失了，又有多少人会记得？风格清新的一部电影，值得一看。</p><hr><h3 id="2017-05-27-WEEK163-沃伦"><a href="#2017-05-27-WEEK163-沃伦" class="headerlink" title="2017-05-27 WEEK163 沃伦"></a>2017-05-27 WEEK163 沃伦</h3><p>沃伦——————————————Wołyń<br><img src="https://img.piegg.cn/week163.jpg?imageslim" alt="沃伦" title="沃伦"></p><!--more--><ul><li>导演：沃吉西奇·斯玛佐斯基</li><li>主演：米卡丽娜·拉巴克斯/阿尔卡迪乌什·雅库比克/沃西尔·沃西尔利克/阿德里安·扎仁巴/伊莎贝拉·库纳/杰克·布雷西亚克/玛丽亚·索博辛斯卡/奥列桑德·兹巴拉斯基/佛罗德米尔·普罗塔西尤克/奥列桑德·彻西洛夫/莱赫·德布里克/罗曼·斯勾勒斯基/扎卡尔杰斯斯·马斯齐因斯基/米哈尔·加多姆斯基/加布里埃拉·马斯卡拉/托马斯兹·萨普里克</li><li>片长：150分钟</li><li>影 片类型：剧情/历史/战争</li><li>豆 瓣评分：8.3/10(from3,341users)</li></ul><p>Hi，各位，好久不见，最近逢着放假一下子没抽出时间写推荐，真是抱歉~本期给大家推荐的是一部来自乌克兰、波兰的电影《沃伦》。又是一段鲜为人知的历史。</p><p>沃伦地区在二战前是波兰和乌克兰交界地带，隶属波兰管辖。但是波兰政府压迫这个地区的乌克兰人——乌克兰人和波兰人积怨已久，虽然可能大家生活在一起，是邻居是“朋友”。一切都在二战的到来之后改变了。</p><p>片头的一段话很震撼人心，“这里被屠杀了两次”。这里被屠杀了两次，是侵略者所为么？不是的，下手的，正是这片土地上的两个民族。其实还有一个民族——犹太人，不过他们就是被屠杀的那族。纳粹指示下犹太人被屠杀了一次；乌克兰起义军UPA屠杀了一遍波兰人。谁也想不到平日里生活在一起的邻居，下一秒就是拿起屠刀的凶手。</p><p>影片把那段历史演绎的太真实以致于你会觉得自己在看一部恐怖片——是的，有的时候恐惧是来自于真实的。主人公的遭遇，真的在很多时候你会感觉绝望，你会无助到流泪。动人以情，隐忍深思。好电影，值得一看。</p><hr><h3 id="2017-05-20-WEEK162-摔跤吧爸爸"><a href="#2017-05-20-WEEK162-摔跤吧爸爸" class="headerlink" title="2017-05-20 WEEK162 摔跤吧爸爸"></a>2017-05-20 WEEK162 摔跤吧爸爸</h3><p>摔跤吧爸爸——————————————Dangal<br><img src="https://img.piegg.cn/week162.jpg?imageslim" alt="摔跤吧爸爸" title="摔跤吧爸爸"></p><!--more--><ul><li>导演：涅提·蒂瓦里</li><li>主演：阿米尔·汗/法缇玛·萨那·纱卡/桑亚·玛荷塔/阿帕尔夏克提·库拉那/沙克希·坦沃/泽伊拉·沃西姆/苏哈妮·巴特纳格尔/里特维克·萨霍里/吉里什·库卡尼</li><li>片长：161分钟(印度)</li><li>影 片类型：剧情/传记/运动/</li><li>豆 瓣评分：9.2/10(from197,877users)</li><li>IMDB评分：8.8/10(from48,159users)</li></ul><p>Hi，各位，好久不见。本期给大家推荐的电影相必大家早已有所耳闻。不过作为豆瓣9.2、IMDB8.8的高分电影，我觉得还是有必要推荐给没有看过这部电影的朋友们。</p><p>这部电影最大的看点莫过于主演阿米尔·汗演绎的从年轻人-&gt;老年人的父亲形象。而且，为了配合影片拍摄，他先增肥增重，再花4个月减肥瘦下去；影片里出演摔跤比赛仅一分钟的成年二姐的演员，也为此接受了9个月的专业训练——不得不说，为了这部电影的拍摄，演员们，都是付出和牺牲了很多。这种敬业的精神也由衷让人敬佩。</p><p>影片的剧情相对于印度来说肯定是爱国主旋律电影——为国争光嘛。不过这部电影改编自印度的真实故事，却也让人为之惊叹。结合上印度的男权社会的大背景，这部电影的诞生以及评分如此之高也不足为虑了。我最欣赏影片里的一个场景就是，妈妈问爸爸，“她们这样以后有谁敢娶她们”。而爸爸的答曰：“她们以后会非常优秀，到时候就是她们来选择自己的另一半了。”这种思想在印度包办女儿婚姻的大背景下，是多么难能可贵。</p><p>总之，这部电影结合了亲情、爱国、热血等元素，某些场景也完全能够打动你的泪腺。这样一部好的电影，值得一看。</p><hr><h3 id="2017-05-15-WEEK161-龙虾"><a href="#2017-05-15-WEEK161-龙虾" class="headerlink" title="2017-05-15 WEEK161 龙虾"></a>2017-05-15 WEEK161 龙虾</h3><p>龙虾img——————————————The Lobster<br><img src="https://img.piegg.cn/week161.jpg?imageslim" alt="龙虾" title="龙虾"></p><!--more--><ul><li>导演：欧格斯·兰斯莫斯</li><li>主演：科林·法瑞尔/蕾切尔·薇兹/约翰·C·赖利/蕾雅·赛杜/奥利维娅·科尔曼/本·卫肖/亚里安妮·拉贝德/罗杰·阿什顿-格里菲斯/迈克尔·史麦利/杰西卡·巴登/阿戈利基·帕朴利亚</li><li>片长：118分钟</li><li>影 片类型：剧情/喜剧/爱情/科幻</li><li>豆 瓣评分：7.5/10(from55,064users)</li><li>IMDB评分：7.1/10(from120,758users)</li></ul><p>Hi，各位好久不见。抱歉这次的更新拖了几天。本周给大家推荐的是一部来自欧洲多国制片的电影《龙虾》。说实话，这部电影的分类是爱情、科幻的时候我觉得特别有意思。主要是这段时间也确实想推一部科幻的电影，结果正好遇到了这部电影。</p><p>但是与《星际穿越》的硬科幻不同的是，本片的科幻元素并不是所谓的硬科幻，相对的可以算是软科幻吧。不过在本片，这个元素虽然明地里出现地不多，但是实际上暗地里把整个故事背景都固定了。这个世界是个婚恋严格受到控制的世界——真正的单身者有罪的世界。看到这里肯定很多单身的朋友表示不服！哈哈。本片这种神奇的设定，还伴随着如果在酒店里的45天内没有脱单将会变成一种动物。而片名龙虾，便是男主如果没有在45天内脱单想要变成的动物。</p><p>全片充满着压抑的黑色幽默。极力催促脱单的酒店和视单身者为“天堂”的野外聚集地，其实都是两个极端。真正的爱情或者婚姻都不是通过这种方式来获得的。在一个人人都抱着脱单的念头的环境里也不一定能找到伴侣，而在一个每个人都自觉是单身者的地方却也可能产生爱情。矛盾与冲突，戏剧与暗讽。好电影，值得一看。</p><hr><h3 id="2017-05-07-WEEK160-卑劣的街头"><a href="#2017-05-07-WEEK160-卑劣的街头" class="headerlink" title="2017-05-07 WEEK160 卑劣的街头"></a>2017-05-07 WEEK160 卑劣的街头</h3><p>卑劣的街头——————————————비열한 거리<br><img src="https://img.piegg.cn/week160.jpg?imageslim" alt="卑劣的街头" title="卑劣的街头"></p><!--more--><ul><li>导演：庾河</li><li>主演：赵寅成/李宝英/千虎珍/南宫珉</li><li>片长：141 分钟(韩国)</li><li>影 片类型：动作/惊悚/犯罪</li><li>豆 瓣评分：7.8/10(from35,384users)</li><li>IMDB评分：7.4/10(from5,987users)</li></ul><p>Hi，各位，好久不见~本周给大家推荐的是来自韩国的《卑劣的街头》。这是一部讲述韩国黑帮的电影。但是又和纯粹的黑帮斗争，打打杀杀不同的是，它更加精致。</p><p>以主人公炳斗的视角，去感受他所认为的黑帮。“我这一辈子都不后悔加入黑帮。”他如是说。但是在重新遇见了喜欢了多年的女孩后，他的内心开始发生转变。“如果你愿意，我可以退出黑帮。”他的存在，并不是真正意义上的黑帮人。他讲求“一家人”，他讲求“要有黑帮精神，不然就是流氓”。他对于自己的朋友还是有一些怜悯，对于自己亲人更是刀子嘴豆腐心。</p><p>但是黑帮却不允许存在这种人。背叛与被背叛，爱与被爱，杀与被杀。所有的这一切，其实不过都是利益驱使。炳斗最终没能实现他的梦想，其实是他不是纯粹的黑帮，他的黑帮精神也不纯粹。但是他却更像一个人，一个有血有肉的人。本片的叙事结构也很奇特，在电影中拍电影，也给这部电影锦上添花了不少。好的电影，值得一看。</p><hr><h3 id="2017-05-01-WEEK159-K歌情人"><a href="#2017-05-01-WEEK159-K歌情人" class="headerlink" title="2017-05-01 WEEK159 K歌情人"></a>2017-05-01 WEEK159 K歌情人</h3><p>K歌情人——————————————Music and Lyrics<br><img src="https://img.piegg.cn/week159.jpg?imageslim" alt="K歌情人" title="K歌情人"></p><!--more--><ul><li>导演：马克·劳伦斯</li><li>主演：休·格兰特/德鲁·巴里摩尔/斯科特·波特/布拉德·加内特/海莉·贝内特</li><li>片长：96 分钟(美国)</li><li>影 片类型：喜剧/爱情/音乐</li><li>豆 瓣评分：7.5/10(from62,988users)</li><li>IMDB评分：6.5/10(from84,821users)</li></ul><p>Hi，各位，好久不见~五一假期不知各位去哪玩了呢？本周给大家推荐的是一部小清新的电影《K歌情人》，然而我更喜欢的译名是《词曲传情》233。以前我也推荐过主演休·格兰特的另一部跟爱情有关的电影《诺丁山》，同样也是简简单单的爱情，但是都有别样的味道。</p><p>这部电影由音乐起头，由音乐结束。短短1个半小时，浓缩了爱情的相识、爱恋、冲突、和好等一切能在爱情里找到的元素。你可能会说，哇这个好俗啊，大家不都是这个套路么。过气歌手+外行兼职作家，组合的词+曲却是本片中最大的亮点。可能辞藻不是多丰富、曲调不是多动人，但是1+1&gt;2的时候，却使得整首歌恰到好处地动人。爱情也是如此，两个外人看来并不是那么完美的人，但是结合在一起就是完美的爱情。一首歌有抑扬顿挫，爱情也会有甜蜜与挫折。关键是最后如何完美收尾，如何让余音更好地缭绕接下去的路。</p><p>本片的插曲《Way Back Into Love》好听！好电影+好音乐，值得一看~</p><hr><h3 id="2017-04-24-WEEK158-杰出公民"><a href="#2017-04-24-WEEK158-杰出公民" class="headerlink" title="2017-04-24 WEEK158 杰出公民"></a>2017-04-24 WEEK158 杰出公民</h3><p>杰出公民——————————————El Ciudadano Ilustre<br><img src="https://img.piegg.cn/week158.jpg?imageslim" alt="杰出公民" title="杰出公民"></p><!--more--><ul><li>导演：加斯顿·杜帕拉特马里亚诺·寇恩</li><li>主演：奥斯卡·马丁内兹/达迪·布列瓦/安德丽娅·弗里杰里奥/诺拉·纳瓦斯/曼努埃尔·维森特/马塞洛·丹德烈亚/贝伦·沙瓦纳/古斯塔沃·加尔松/朱利安·拉基尔·泰拉里尼/艾玛·里维拉/尼古拉斯·德·特蕾西/丹尼尔·卡尔吉曼/亚历克西斯·洛佩兹·科斯塔/莱昂纳多·穆里亚/佩德罗·罗斯</li><li>片长：118分钟</li><li>影 片类型：剧情/喜剧</li><li>豆 瓣评分：8.6/10(from5,818users)</li><li>IMDB评分：7.5/10(from1,932users)</li></ul><p>Hi，各位，好久不见~本周给大家推荐的是一部来自阿根廷和西班牙的电影，《杰出公民》。这是一部很具有现实意义的讽刺电影。</p><p>影片很有意思，采用章节来推进剧情。每一个章节承前启后，无缝衔接。也许没有它们，对整部电影也没有影响。但是有了它们之后，你可以看到电影的阶段以及这部电影最核心的部分——虚实结合。到底有多少情节是真实而有多少情节是虚构，这些都只能交给观众去咀嚼。</p><p>没有对比就没有伤害。村民的愚昧与作家的自大；村民的“不自由”和作家的“自由”；年轻时伙伴的“幸福的”一家和作家孤身一人至今等等的对比。当我们把村民和作家作为本片的两大部分区别对待的时候，你会发现这个小镇和作家结下的渊源真是数不清道不尽。</p><p>作家说的一句话我特别喜欢：“真相并不存在，只有解构和诠释。”这部电影也是一样，带着思辨去看它，你能看出很多东西。好电影值得一看。</p><hr><h3 id="2017-04-17-WEEK157-百万美元宝贝"><a href="#2017-04-17-WEEK157-百万美元宝贝" class="headerlink" title="2017-04-17 WEEK157 百万美元宝贝"></a>2017-04-17 WEEK157 百万美元宝贝</h3><p>百万美元宝贝——————————————Million Dollar Baby<br><img src="https://img.piegg.cn/week157.jpg?imageslim" alt="百万美元宝贝" title="百万美元宝贝"></p><!--more--><ul><li>导演：克林特·伊斯特伍德</li><li>主演：克林特·伊斯特伍德/希拉里·斯万克/摩根·弗里曼/杰伊·巴鲁切尔/麦克·柯尔特/露西娅 瑞科尔/布莱恩·F·奥博恩/安东尼·麦凯/玛格·马丁戴尔/瑞琪·琳德赫姆/迈克尔·佩纳/本尼托·马丁内斯/Bruce MacVittie/David Powledge/乔·达安格里奥</li><li>片长：132 分钟</li><li>影 片类型：剧情/运动</li><li>豆 瓣评分：8.5/10(from91,541users)</li><li>IMDB评分：8.1/10(from512,384users)</li></ul><p>Hi，各位，好久不见~本周给大家推荐的电影来自关注公众号的小伙伴的推荐。感谢推荐~这部电影真的很特别也真的很感动。</p><p>其实一开始看到这个名字的时候我还以为是部喜剧电影。但是直到简单看了简介，并且安静看完整部电影之后我才发现跟喜剧一点边的不沾。有人说这部是一部没有讲好的鸡汤电影——因为它的结局并不是很鸡汤。但是整天沉浸在鸡汤文里的人们，整天被各种励志各种成功文笼罩的我们（包括我），也许看过这部电影才会被拍醒吧。它讲的不是怎么去赢，它告诉了我们如何失败。影片的三个主要人物都是老戏骨，演绎的角色真是入木三分。没有华丽的剪辑，没有什么伏笔，一切就是按照时间一点点往前推进，但是一点点敲击你内心的软弱之处。</p><p>看到豆瓣的一些影评，深深引起了我的共鸣。也许你并不喜欢拳击这项运动，但是你无法阻止喜欢这项运动的人们。其实借这个有点暴力有点血腥的运动，也在向我们展示着，哪怕你胜利了也是会带着伤痛。其实生命从诞生开始就注定要走向死亡。但是这无法阻止你成为一个英雄。豆瓣影评里有一句话写得特别好：“如果她没输，这部电影就是一部普通的好莱坞美国梦。她输了，电影就赢了。”好电影，值得一看。</p><hr><h3 id="2017-04-09-WEEK156-悲惨世界"><a href="#2017-04-09-WEEK156-悲惨世界" class="headerlink" title="2017-04-09 WEEK156 悲惨世界"></a>2017-04-09 WEEK156 悲惨世界</h3><p>悲惨世界——————————————Les Misérables<br><img src="https://img.piegg.cn/week156.jpg?imageslim" alt="悲惨世界" title="悲惨世界"></p><!--more--><ul><li>导演：汤姆·霍珀</li><li>主演：休·杰克曼/罗素·克劳/安妮·海瑟薇/阿曼达·塞弗里德/埃迪·雷德梅恩/海伦娜·伯翰·卡特/萨莎·拜伦·科恩/萨曼莎·巴克斯/艾伦·特维特/康姆·威尔金森/伊莎贝尔·艾伦/丹尼尔·赫特斯通</li><li>片长：157分钟</li><li>影 片类型：剧情/爱情/音乐</li><li>豆 瓣评分：8.5/10(from201,904users)</li><li>IMDB评分：7.6/10(from255,650users)</li></ul><p>Hi，各位，好久不见~本周给大家推荐的电影是一部改编自雨果经典名著的《悲惨世界》。这部电影之前也有着非常出色的同名音乐剧。而改变成电影后，最大的亮点就是，几乎所有的台词都是唱出来的——动听也动人。看这部电影如同看一部多镜头音乐剧。</p><p>故事本身就是一个感人至深的故事。如果看过原著自不必说。没看过原著的，看完这部电影，也能领略到雨果这部巨著的震撼。不同的人物不同的遭遇不同的命运，奸邪、正义、争议之事、之人能让你感慨万分。本片的演员基本都是老戏骨，所以很多唱出来的台词，真的特别感人，有些场景甚至可以打动你的泪腺。剧情时间跨度之大、内容丰富之多、演员表演功力之足，音乐旋律动人之深都是你应该看看它的原因。好电影，值得一看。</p><hr><h3 id="2017-04-02-WEEK155-斯隆女士"><a href="#2017-04-02-WEEK155-斯隆女士" class="headerlink" title="2017-04-02 WEEK155 斯隆女士"></a>2017-04-02 WEEK155 斯隆女士</h3><p>斯隆女士——————————————Miss Sloane<br><img src="https://img.piegg.cn/week155.jpg?imageslim" alt="斯隆女士" title="斯隆女士"></p><!--more--><ul><li>导演：约翰·麦登</li><li>主演：杰西卡·查斯坦/古古·姆巴塔-劳/约翰·利特高/艾丽森·皮尔/迈克尔·斯图巴/马克·斯特朗/杰克·莱西/道格拉斯·史密斯/萨姆·沃特森/迪伦·贝克/恩尼斯·埃斯莫/梅格翰·法伊/亚历桑德拉·卡斯蒂略/凯尔·麦克/杰克·默里</li><li>片长：132分钟</li><li>影 片类型：剧情/惊悚/</li><li>豆 瓣评分：8.6/10(from7,763users)</li><li>IMDB评分：7.2/10(from11,696users)</li></ul><p>Hi，各位，又到了一周推荐一部好电影的时候啦。本周给大家推荐的是去年一部特别精致的“政治惊悚”电影《斯隆女士》。老实说这部电影一开始并没有吸引我的地方，不管是片名还是简介。不过惊讶于它的口碑，看完之后真心觉得是一部对得起评分的好电影。</p><p>本片的亮点有三：</p><ol><li><p>斯隆女士的表演够有力。从开始到结束，一个人串起了整部电影。铿锵有力的措辞，干净利落的动作，敏锐的洞察力以及近乎变态的求胜欲，让她当之无愧是本片的唯一核心。</p></li><li><p>剧本亮。本片的剧情一环接着一环，此起彼伏。双方阵营你来我往尽显尔虞我诈。见招拆招，剧情紧凑得让你缓不过来，直呼过瘾。</p></li><li><p>反转。这是本片争议最多的地方。说好的人说反转地漂亮，说不好的人说反转地太戏剧。我看来是真的反转地很棒。其实这样宣扬主旋律的反转既出乎意料又合情合理，我觉得很棒。</p></li></ol><p>PS：本片在很多关键地方的配乐也很赞。好电影，值得一看。</p><hr><h3 id="2017-03-25-WEEK154-看不见的客人"><a href="#2017-03-25-WEEK154-看不见的客人" class="headerlink" title="2017-03-25 WEEK154 看不见的客人"></a>2017-03-25 WEEK154 看不见的客人</h3><p>看不见的客人——————————————Contratiempo<br><img src="https://img.piegg.cn/week154.jpg?imageslim" alt="看不见的客人" title="看不见的客人"></p><!--more--><ul><li>导演：奥里奥尔·保罗</li><li>主演：马里奥·卡萨斯/阿娜·瓦格纳/何塞·科罗纳/芭芭拉·蓝妮/法兰西斯克·欧瑞拉/帕科·图斯/大卫·塞尔瓦斯/伊尼戈·加斯特西/珊·叶拉姆斯/马内尔·杜尔索/布兰卡·马丁内斯/佩雷·布拉索/乔迪·布鲁内特/鲍毕·冈塞莱斯/玛蒂娜·乌尔塔多</li><li>片长：106分钟</li><li>影 片类型：悬疑/惊悚/犯罪</li><li>豆 瓣评分：8.6/10(from7,419users)</li><li>IMDB评分：7.6/10(from1,559users)</li></ul><p>Hi，各位，好久不见~本期给大家推荐的是一部来自西班牙的悬疑电影《看不见的客人》。西班牙的一些悬疑电影一直以精致独特著称，本片也不例外。而且是少有的那种从片头到片尾一直能吸引你看下去的悬疑电影。</p><p>悬疑电影最好看的地方莫过于留下很多种在观众心中的坑然后再以精妙的手法把这些坑再给填上，让你心服口服。一开始的重重迷雾，一点点拨开；然后换一个角度开始反转；乃至最后峰回路转水落石出，一气呵成，特别给力！在一点点拨开迷雾的时候，人性的丑恶也在一点点地暴露出来。这种转变，顺带着推进剧情的发展、结局的改变，让你不禁拍手叫好，心悦诚服。</p><p>这部电影真的是看完会让你赞不绝口，好电影，值得一看。</p><hr><h3 id="2017-03-19-WEEK153-撞车"><a href="#2017-03-19-WEEK153-撞车" class="headerlink" title="2017-03-19 WEEK153 撞车"></a>2017-03-19 WEEK153 撞车</h3><p>撞车——————————————Crash<br><img src="https://img.piegg.cn/week153.jpg?imageslim" alt="撞车" title="撞车"></p><!--more--><ul><li>导演：保罗·哈吉斯</li><li>主演：桑德拉·布洛克/唐·钱德尔/马特·狄龙/布兰登·费舍/泰伦斯·霍华德/坦迪·牛顿/卢达克里斯/迈克尔·佩纳/珍妮弗·艾斯波西多/瑞恩·菲利普</li><li>片长：112分钟</li><li>影 片类型：剧情/犯罪</li><li>豆 瓣评分：8.6/10(from160,771users)</li><li>IMDB评分：7.8/10(from371,906users)</li></ul><p>Hi，各位好久不见~本期给大家推荐的是2004年的奥斯卡最佳电影《撞车》。这部电影的一个核心的主题是种族歧视，但是又不是纯粹的种族歧视——导演挖掘了这点，种族歧视归根结底，还是来自于人心。</p><p>除了影片的的核心主题比较容易触动人心之外，影片的编剧也是十分赞。多线叙事+“打乱”时空的布局，让你一点点走进影片描述的这么多人里。错综复杂的关系交织在一起，每个人都有着自己的难题，自己的信仰，自己的人生。没有绝对的是与非，没有绝对的善与恶。Crash，撞击的一瞬间，所有人的人生仿佛都经历了一次改变。有那么些人你认为罪不可赦，却做出让你能歌颂人间大爱的举动；有些人你认为一身正气，却做出让你无法理解的冲动之举。我们说种族歧视是美国社会里一个存在已久的问题，而导演将其赤裸裸得摆上荧幕了之后，又给其加上了一层遮羞布——遮住的不是影片里的人，遮住的是那些叫嚣着种族主义的带有种族歧视的那堆人。</p><p>大牌影星实力过硬，也给这部电影增色不少。好电影，值得一看。</p><hr><h3 id="2017-03-11-WEEK152-比海更深"><a href="#2017-03-11-WEEK152-比海更深" class="headerlink" title="2017-03-11 WEEK152 比海更深"></a>2017-03-11 WEEK152 比海更深</h3><p>比海更深——————————————海よりもまだ深く<br><img src="https://img.piegg.cn/week152.jpg?imageslim" alt="比海更深" title="比海更深"></p><!--more--><ul><li>导演：是枝裕和</li><li>主演：阿部宽/真木阳子/小林聪美/中川雅也/池松壮亮/桥爪功/树木希林/中村友理/高桥和也/小泽征悦/峰村理惠/古馆宽治/叶山奖之/吉泽太阳</li><li>片长：117分钟</li><li>影 片类型：剧情/家庭</li><li>豆 瓣评分：8.6/10(from29,854users)</li><li>IMDB评分：7.6/10(from1,941users)</li></ul><p>Hi，各位好久不见~本期给大家推荐的电影是来自日本的《比海更深》。比海更深的是什么，是情感。有人说本片很治愈，有人说本片很“毒”鸡汤，我觉得，本片很伤感。围绕着情感，本片讲述的故事很“无力”。每个角色都有自己的无奈，每个角色都有自己的迫不得已。</p><p>这部电影可以说没有什么高潮，平铺直叙着一家人的喜怒哀乐。这种淡淡的描述，日常的镜头切换，让我想到了另外一部名字里也有“海”字的《海街日记》。这种“日常番”的电影，看似平淡无奇，但是越看越有味道。金句频出，也是让我非常喜欢它的一个原因。“我的人生到底从哪开始不正常了”“我没有成为你想的那个人，真的很抱歉”。面对现实，我们总有一些无力感，却又不得不为之奋斗——可能不是为了自己，但是得为了别人。男主良多，就是一个只有自己独处的时候才会展示出孤独脆弱的一面的人，失魂落魄，没有什么积蓄。但是为了儿子却“出手大方”，毫不吝啬。跟前妻离婚却又一直关心着她的一举一动。年老的奶奶，住了40年的房子，“不争气”的儿子，屈服现实的前妻，油嘴滑舌的姐姐。。简单的镜头，三言两语，却勾勒的明明白白。让人看了感慨良多。</p><p>前路还长，还有多少坎坷没有遇到，还有多少失意没有感触。好在阳光正好，天空还蓝，大海还深。好电影，值得一看。</p><hr><h3 id="2017-03-05-WEEK151-推销员"><a href="#2017-03-05-WEEK151-推销员" class="headerlink" title="2017-03-05 WEEK151 推销员"></a>2017-03-05 WEEK151 推销员</h3><p>推销员——————————————فروشنده<br><img src="https://img.piegg.cn/week151.jpg?imageslim" alt="推销员" title="推销员"></p><!--more--><ul><li>导演：阿斯哈·法哈蒂</li><li>主演：沙哈布·侯赛尼/塔兰涅·阿里多斯蒂/巴巴克·卡里米/法里德·萨贾蒂·侯赛尼/米娜·沙达蒂</li><li>片长：125分钟</li><li>影 片类型：剧情/</li><li>豆 瓣评分：7.7/10(from4,394users)</li><li>IMDB评分：8.2/10(from13,585users)</li></ul><p>Hi，各位好久不见~本次给大家推荐的是一部来自伊朗的《推销员》。有可能大家有听过、看过《推销员之死》，而本片也借着《推销员之死》的名义，讲述了一个让人叹惋的故事。</p><p>本片关键词是——宽容。是的，听到这里你也能知道，这是一部讲述人性的电影。因为宽容让这个社会更加和谐有爱，因为宽容让人与人之间拥有更多对话的机会。男主角的愤怒，让这个悲伤的事件走向了不可挽回的地步，让他的婚姻步入了坟墓。压死骆驼的最后一根稻草往往是一根一意孤行的野草。受害者更多的是需要理解和陪伴。但是通常，我们周边的人却只能被愤怒所支配。这就是悲哀。所以哪怕受害者已经恢复已经原谅，我们还有可能悬崖勒不住马。</p><p>影片中穿插的几段《推销员之死》的话剧场景，都各有深意。人物关系逐渐清晰，人物性格逐渐完善。两位主演表演功力深厚，加之导演对全剧镜头、剧情力度把握得当，也难怪这部电影能够拿到奥斯卡最佳外语片。好电影，值得一看。</p><hr><h3 id="2017-02-19-WEEK150-血战钢锯岭"><a href="#2017-02-19-WEEK150-血战钢锯岭" class="headerlink" title="2017-02-19 WEEK150 血战钢锯岭"></a>2017-02-19 WEEK150 血战钢锯岭</h3><p>血战钢锯岭——————————————Der kommer en dag<br><img src="https://img.piegg.cn/WEEK150.jpg?imageslim" alt="血战钢锯岭" title="血战钢锯岭"></p><!--more--><ul><li>导演：梅尔·吉布森</li><li>主演：安德鲁·加菲尔德/萨姆·沃辛顿/文斯·沃恩/雨果·维文/卢克·布雷西/泰莉莎·帕尔墨/瑞切尔·格里菲斯/纳撒尼尔·布佐尼克/理查德·劳斯伯格/马特·纳夫莱/费拉斯·迪拉尼/瑞安·柯尔/卢克·佩格勒</li><li>片长：139分钟(中国大陆)</li><li>影 片类型：剧情/动作/传记/历史/战争</li><li>豆 瓣评分：8.7/10(from219,545users)</li><li>IMDB评分：8.3/10(from133,710users)</li></ul><p>Hi，各位好久不见~十分抱歉拖更到现在。这个月事情多，不过已经算是忙完一滩事了。</p><p>本周给大家推荐的电影，相信很多人都有听说甚至有去电影院看过。我是从看战争片开始喜欢上看电影的。我的第一部印象最深刻的战争片是《拯救大兵瑞恩》。由此走上了观影的道路。</p><p>这部电影最牛逼的地方有两个：1. 男主的经历简直牛逼。 2. 这居然是根据真实故事拍的，而且真实故事貌似更牛逼一点。 导演梅尔吉布森依旧宝刀未老，这场电影的特效、特写镜头是如此的逼真乃至让人深刻感到战争的恐怖。有人说，如果这部电影用3D放映，估计会看吐一堆人吧。</p><p>一部电影里最重要的是要有矛盾，有矛盾才有剧情，有剧情才能发展。这部电影的矛盾，小的来说是个人的信仰和一支枪的矛盾。大的来说是信仰与战争的矛盾。我特别喜欢豆瓣里有位影评人的一句话：“他的信仰无法改变战争，而战争却拿他看似最普通的信仰也无可奈何。”震撼，感动。好电影，值得推荐~</p><hr><h3 id="2017-02-11-WEEK149-海边的曼彻斯特"><a href="#2017-02-11-WEEK149-海边的曼彻斯特" class="headerlink" title="2017-02-11 WEEK149 海边的曼彻斯特"></a>2017-02-11 WEEK149 海边的曼彻斯特</h3><p>海边的曼彻斯特——————————————Der kommer en dag<br><img src="https://img.piegg.cn/week149.jpg?imageslim" alt="海边的曼彻斯特" title="海边的曼彻斯特"></p><!--more--><ul><li>导演：肯尼斯·罗纳根</li><li>主演：卡西·阿弗莱克/米歇尔·威廉姆斯/卢卡斯·赫奇斯/凯尔·钱德勒/卡拉·海沃德/泰特·多诺万/埃里卡·麦克德莫特/格瑞辰·摩尔/希瑟·伯恩斯/蜜西·雅格/斯蒂芬·亨德森/约什·汉密尔顿/卡洛琳·皮克曼/肖恩·菲茨吉本/肯尼斯·罗纳根/利亚姆·麦克尼尔/马修·布罗德里克/</li><li>片长：137分钟</li><li>影 片类型：剧情/</li><li>豆 瓣评分：8.6/10(from24,867users)</li><li>IMDB评分：8.2/10(from47,014users)</li></ul><p>Hi，各位，好久不见~新年事情多，中间拖更了一周实在抱歉~<br>本部电影是去年一部好评如潮的电影——这是一部几乎跟生活贴近到平行的电影。每天我们都能看到各种鸡汤、各种励志故事在四处传播。但是更多的时候，去读鸡汤的你往往过得并不“励志”。这部电影也是如此，没有鸡汤，甚至反鸡汤——打破我们所认知的屏幕“常规”，但是仔细想想，却是我们生活中无时无刻不在上演的故事。<br>你问我悲伤能有多悲伤，痛苦能有多痛苦。你问我有些人为什么会想着轻生，有些人为什么不能“走出来”？我觉得豆瓣短评里的一句话说的特别好：「那些劝我们向前看的朋友，不是所有人都可以和过去和解」。是的，有些事情就是无法通过时间，通过经历，通过环境而改变，有些伤疤就是无法随着岁月而抹平。主角卡西把那个失去了“灵魂”的男主演的惟妙惟肖，而现实中确实是有很多时候，心碎得无法愈合。没有鸡汤，不是一个美好的结局，但是确确实实是生活中的你我或者他。好电影，值得一看。</p><hr><h3 id="2017-01-29-WEEK148-总有一天"><a href="#2017-01-29-WEEK148-总有一天" class="headerlink" title="2017-01-29 WEEK148 总有一天"></a>2017-01-29 WEEK148 总有一天</h3><p>总有一天——————————————Der kommer en dag<br><img src="https://img.piegg.cn/week148.jpg?imageslim" alt="总有一天" title="总有一天"></p><!--more--><ul><li>导演：杰斯珀·W·尼尔森</li><li>主演：拉斯·米克尔森/苏菲·格拉宝/哈拉尔德·凯泽·赫尔曼/艾伯特·鲁德贝克·林哈特/劳里斯·斯科夫高·安德森/拉斯·兰特/索伦·希特-拉森/大卫·丹席克/松佳·里奇特/索比亚格·侯菲尔德/雅各布·B·恩格曼/</li><li>片长：110分钟</li><li>影 片类型：剧情/</li><li>豆 瓣评分：8.7/10(from8,721users)</li><li>IMDB评分：7.7/10(from688users)</li></ul><p>Hi，各位，好久不见。首先祝大家2017年，新年快乐！</p><p>作为2017年农历新年推荐的第一部电影，必然是质量上乘的。这部来自丹麦的电影，改编自真实故事，发人深省而又感人肺腑。</p><p>看这部电影的同时，可以联想国内类似的杨永信“电疗戒网瘾”的例子。只不过，杨永信是当代的例子，而本片里的情况出现在上世纪60年代的丹麦。无助，绝望，乃至内心扭曲。在故事发生的学校里，你可以看到一群“行尸走肉”般，被“驯服”的孩子。有苦说不出，反抗无力，孤立无助。在这种环境下，还要遭受禽兽老师的摧残，校长、助理的掌掴。而唯一带有良知的老师却也只是看不下去而辞职。一切似乎没有办法逆转，一切似乎都显得那么黑暗。</p><p>而两个小主人公却是从头至尾给本片注入了灵魂。注入了追求自由，敢于反抗，友善热心的灵魂。我最感动的一个画面是哥哥拿一个“私藏”的巧克力给弟弟吃的时候，弟弟只吃了一口就分给眼馋的同伴们——哪怕这些同伴前一秒还在奚落他。融入集体是不容易的，融入一个这样“黑暗”的集体更是不容易。不过是兄弟俩给这群孩子带去了希望，带去了光明。</p><p>总有一天，这到底是哪一天呢？不知道，但是虽然孩子们遭受了种种令人愤慨的折磨，总归是有正义降临的那天。这一天的风景是多么美，这一天的阳光是多么灿烂。也许此时此刻还有无数类似的孤儿院、学校有类似的情况，但是你不知道。没有亲身经历，你永远不知道，哪怕总有一天，你也不知道是哪一天。好电影，值得一看。</p><hr><h3 id="2017-01-19-WEEK147-攻壳机动队"><a href="#2017-01-19-WEEK147-攻壳机动队" class="headerlink" title="2017-01-19 WEEK147 攻壳机动队"></a>2017-01-19 WEEK147 攻壳机动队</h3><p>攻壳机动队——————————————攻殻機動隊<br><img src="https://img.piegg.cn/week147.jpg" alt="攻壳机动队" title="攻壳机动队"></p><!--more--><ul><li>导演：押井守</li><li>主演：田中敦子/大塚明夫/山寺宏一/大木民夫/家弓家正/仲野裕/</li><li>片长：83分钟</li><li>影 片类型：动作/科幻/动画/悬疑/</li><li>豆 瓣评分：8.9/10(from43,836users)</li><li>IMDB评分：8.0/10(from85,436users)</li></ul><p>Hi，各位，好久不见。本周给大家推荐的是一部很早以前的动画电影——《攻壳机动队》。相信不少人已经看过或者听过这部作品的名字。直到我自己22年后看到这部电影，真的觉得依然思想很伟大。</p><p>作为一部科幻动画电影，它将思考放在了现在都未达到的公元2029年。人类文明没有达到非常逆天的程度却也诞生了机器与灵魂结合的“人”，而在此之上，极具思辨的观点，灵魂和躯体之间到底有没有具体关系，灵魂能不能超脱躯体？自我意识的存在依赖于什么。。等等。</p><p>这部电影披着一层动画的壳，但是思考问题深度却远远超过壳本身。据说《黑客帝国》也深深收到它的影响，可想而知这部电影的伟大之处。而它的英文名也发人深省《Ghost in Shell》，躯壳下的灵魂。如果你是个喜爱烧脑的，喜欢思考这类高深哲学的人，那么它绝对是不容错过的。</p><hr><h3 id="2017-01-09-WEEK146-白日梦想家"><a href="#2017-01-09-WEEK146-白日梦想家" class="headerlink" title="2017-01-09 WEEK146 白日梦想家"></a>2017-01-09 WEEK146 白日梦想家</h3><p>白日梦想家——————————————The Secret Life of Walter Mitty<br><img src="https://img.piegg.cn/week146.jpg" alt="白日梦想家" title="白日梦想家"></p><!--more--><ul><li>导演：本·斯蒂勒</li><li>主演：本·斯蒂勒/克里斯汀·韦格/亚当·斯科特/雪莉·麦克雷恩/西恩·潘/凯瑟琳·哈恩/泰伦斯·伯尼·海恩斯 /保罗·菲兹杰拉德/格蕾丝·雷克斯/乔恩·戴利/乔伊·斯洛特尼克</li><li>片长：114分钟</li><li>影 片类型：剧情/喜剧/冒险</li><li>豆 瓣评分：8.3/10(from124,623users)</li><li>IMDB评分：7.3/10(from243,738users)</li></ul><p>Hi，各位，好久不见。本周给大家推荐的是一部轻松诙谐的喜剧电影《白日梦想家》。但是本片的中文翻译其实并不是特别能很好的描述本片的主题。如果叫做《白日冒险家》可能更好一点？</p><p>我很喜欢本片的宣传语：<code>Stop Dreaming,Start Living</code>（不要做白日梦了，拥抱生活吧）。主人公是个爱做白日梦的公司职员，说是整天沉浸在自己的意淫的世界里也不为过。不过因为一起突发事件他却不得不<code>To see the world</code>，于是开始了正片。喜欢本片的人大概跟我一样吧，影片的风景确实拍的相当漂亮，而且故事一串接着一串，虽然有些夸张有些巧合，但是不可否认观影体验相当棒！我最喜欢的片段是主人公溜着滑板沿着公路俯冲而下的片段，那个片段看着真的感觉，这才是生活啊，这才是<code>Start Living</code>啊。</p><p>不出意料的Happy Ending，也给本片观众灌了一碗大鸡汤。Anyway，如果是想茶余饭后放松心情，喝喝鸡汤，看看风景，享受生活，那么本片绝对是不二之选。</p><hr><h3 id="2017-01-02-WEEK145-45周年"><a href="#2017-01-02-WEEK145-45周年" class="headerlink" title="2017-01-02 WEEK145 45周年"></a>2017-01-02 WEEK145 45周年</h3><p>45周年——————————————45 Years<br><img src="https://img.piegg.cn/week145.jpg" alt="45周年" title="45周年"><br><!--more--></p><ul><li>导演：安德鲁·海格</li><li>主演：夏洛特·兰普林/多莉·韦尔斯/汤姆·康特奈/杰拉丁妮·詹姆斯/山姆·亚历山大/麦克斯·路德/大卫·西布利/汉娜·查尔莫斯/理查德·坎宁汉姆/米歇尔·芬奇/保罗·戈德史密斯</li><li>片长：95分钟</li><li>影 片类型：剧情/爱情</li><li>豆 瓣评分：7.7/10(from19,384users)</li><li>IMDB评分：7.1/10(from21,005users)</li></ul><p>Hi，各位，好久不见。最近推电影的时间总是乱糟糟的，这段时间比较忙，之后会逐步走回正规的，十分抱歉！</p><p>新年给大家推荐的第一部电影，是来自英国的《45周年》。这部电影讲述了两位老人的爱情故事——或者说是爱情悲剧故事？影片从即将迎来结婚45周年之前的6天开始说起，一起突发的事件，打破了45年来的“平静”。按理说能够相扶相伴了45年的老夫老妻，感情应该是十分深厚了。然而在本片的故事设定下，却让一切都打碎。如果说《消失的爱人》这部电影让你后怕不以但是仔细想想生活中发生类似的事情的情况毕竟还是少数，那么这部电影就会给所有的情侣一个警钟——毕竟它太有可能了，并且真的时常就在我们的周围发生类似的事。</p><p>虽然是50年被冰封的记忆，却始终无法消融。用一生的真情换来一生的替代，想必换作是谁都无法接受吧。影片的最后，伴随着极富隐喻的音乐的落幕，女主迅速的抽手，让一切的“美好”彻底破碎，为之动容。本片的两位主演不愧是老戏骨，张弛有度而且让你感慨万分。好电影，值得一看。</p><hr><h3 id="2016-12-26-WEEK144-窃听风暴"><a href="#2016-12-26-WEEK144-窃听风暴" class="headerlink" title="2016-12-26 WEEK144 窃听风暴"></a>2016-12-26 WEEK144 窃听风暴</h3><p>窃听风暴——————————————Das Leben der Anderen<br><img src="https://img.piegg.cn/week144.jpg" alt="窃听风暴" title="窃听风暴"></p><!--more--><ul><li>导演：弗洛里安·亨克尔·冯·多纳斯马</li><li>主演：乌尔里希·穆埃/马蒂娜·戈黛特/塞巴斯蒂安·科赫/乌尔里奇·图克尔/托马斯·席尔梅</li><li>片长：137分钟</li><li>影 片类型：剧情/悬疑</li><li>豆 瓣评分：9.1/10(from195,431users)</li><li>IMDB评分：8.5/10(from268,134users)</li></ul><p>Hi，各位，好久不见。本期给大家带来的又是一部来自德国的电影《窃听风暴》这部电影从一个很“刁钻”的角度切入，向我们还原了当时的东德残酷的社会现实。</p><p>在那个年代，东德有很多秘密警察，负责监视、监听人民的一举一动。有可能一句玩笑话，一个不经意的举动就让他们遭到牢狱之灾。而本片正是通过一个监听特工的视角，去描绘了当时的社会是多么灰暗，高层是多么腐朽。而在这监听的过程中的人性的转变亦是本片最精华最感人的部分——</p><p>主演乌尔里希·穆埃生动地演绎了一个国家机器下的特工从坚定不移地遵守指令到“良心”发现-》感受到了什么是黑暗，什么才是真正的自由和民主的转变。</p><p>去翻阅本片的背景故事的时候有两则小故事让我非常震惊：</p><p>1.东诺士马克的电影用了很多当初东德的机关大楼实地拍摄， 但是监狱博物馆的馆长却拒绝了他拍摄的请求。原因？馆长说，因为东诺士马克的剧本不符合史实:整个东德历史，像魏斯乐那样“良心发现”的秘密警察，对不起，一个都没有。<br>2.主演乌尔里希·穆埃的前妻，曾经也是秘密警察的线民，长期监控自己的丈夫，而这些记录是在两德统一之后，主演去翻看自己的档案的时候才发现的。</p><p>这是一部献给好人的奏鸣曲，好电影，值得观看。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;2017-12-17-WEEK186-一级恐惧&quot;&gt;&lt;a href=&quot;#2017-12-17-WEEK186-一级恐惧&quot; class=&quot;headerlink&quot; title=&quot;2017-12-17 WEEK186 一级恐惧&quot;&gt;&lt;/a&gt;2017-12-17 WEEK186 一级恐惧&lt;/h3&gt;&lt;p&gt;一级恐惧——————————————Primal Fear&lt;br&gt;&lt;img src=&quot;https://img.piegg.cn/week186.jpg?imageslim&quot; alt=&quot;一级恐惧&quot; title=&quot;一级恐惧&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="日志" scheme="https://molunerfinn.com/categories/%E6%97%A5%E5%BF%97/"/>
    
      <category term="周电" scheme="https://molunerfinn.com/categories/%E6%97%A5%E5%BF%97/%E5%91%A8%E7%94%B5/"/>
    
    
      <category term="电影" scheme="https://molunerfinn.com/tags/%E7%94%B5%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title>PicGo——一个基于Electron的图片上传+简单管理的工具</title>
    <link href="https://molunerfinn.com/make-a-picgo/"/>
    <id>https://molunerfinn.com/make-a-picgo/</id>
    <published>2017-12-13T11:11:00.000Z</published>
    <updated>2018-04-27T08:26:51.717Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fmd6ou9eynj2046046glj" alt=""></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>作为一个比较常用markdown写文章、博客的人，在markdown里插入图片对我而言一直一个比较繁琐的活。以前每周写电影推荐的时候，我要在markdown里插入一张电影海报，我需要如下的操作：</p><ol><li>打开豆瓣的网站，选一张满意的海报，下载</li><li>打开七牛的网站，登录，点点点，找到上传，上传</li><li>关闭上传窗口，找到地址，复制地址，再关闭七牛</li><li>粘贴到markdown里</li></ol><p>每次都需要繁琐的打开网页进行一些必要而枯燥的操作。这样很麻烦。在用过mac上一款很不错的小工具应用iPic后我非常喜欢它的简洁操作。不过它免费版本并不支持七牛图床。所以我就想着，能不能自己写一个类似的工具呢？结合自己的使用习惯再顺便加点功能。</p><p>于是我就开始自己的图片上传工具的开发了。它叫做<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a>。</p><a id="more"></a><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><p>最早最早我想着用swift来写一个原生的应用，主要想着能做出体积友良、性能优秀的应用。不过鉴于swift迭代的太快，很多教程都已经不适合了。并且swift网上的教程对我这个小前端来说着实要学的东西不少。我只是想做个方便自己的工具而已，一切以方便自己作为大前提。作为一个前端工程师，我决定采用<a href="https://electronjs.org/" target="_blank" rel="noopener">electron</a>来开发。同时因为我是Vue的粉丝，一并就使用了<a href="https://github.com/SimulatedGREG/electron-vue" target="_blank" rel="noopener">electron-vue</a>作为我的electron开发脚手架。不得不说，<code>electron-vue</code>提供的脚手架做的真的很用心，而且我自己要做修改加配置什么的也很方便。日后做跨平台支持的话也比较容易。</p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>由于用过iPic，很多它的一些操作模式我觉得特别值得借鉴。比如我想要个简单的拖拽就能实现上传，我想要能够上传我剪贴板的图片，我想要是实现上传成功后自动复制链接到剪贴板，这样我就可以直接编辑了。</p><p>那么这样一来，我编辑文章只需要如下操作：</p><ul><li>找到要上传的图片，使用这个工具直接上传</li><li>上传成功后自动复制地址到剪贴板，在markdown里直接粘贴</li></ul><p>一下子省去了很多原本繁琐的操作！</p><h2 id="功能展示"><a href="#功能展示" class="headerlink" title="功能展示"></a>功能展示</h2><blockquote><p>前前后后，用每天的闲暇时间从0开始学习electron框架，到Travis-ci构建出第一个可用的版本，大概花了一个月的时间。基本实现了我自己当初的目标，极大提升了我自己的文章写作体验。</p></blockquote><h3 id="操作演示"><a href="#操作演示" class="headerlink" title="操作演示"></a>操作演示</h3><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fmf5fzq27lg218e0p0kjo" alt=""></p><h3 id="精致设计"><a href="#精致设计" class="headerlink" title="精致设计"></a>精致设计</h3><p><img src="https://user-images.githubusercontent.com/12621342/33876294-14f7cf5a-df60-11e7-9c59-a8d4565c61d4.png" alt=""></p><p>macOS系统下，支持拖拽至menubar图标实现上传。menubar app 窗口显示最新上传的5张图片以及剪贴板里的图片。点击图片自动将上传的链接复制到剪贴板。</p><h3 id="便捷管理"><a href="#便捷管理" class="headerlink" title="便捷管理"></a>便捷管理</h3><p><img src="https://user-images.githubusercontent.com/12621342/33876349-3ee314a0-df60-11e7-8c9f-9904264d6ddb.png" alt=""></p><p>查看你的上传记录，重复使用更方便。支持点击图片大图查看。支持删除图片（仅本地记录），让界面更加干净。</p><h3 id="可选图床"><a href="#可选图床" class="headerlink" title="可选图床"></a>可选图床</h3><p><img src="https://user-images.githubusercontent.com/12621342/33876259-f7620af0-df5f-11e7-807e-0dc84a5cee50.png" alt=""></p><p>目前支持微博图床和七牛图床。未来将支持更多。方便不同图床的上传需求。</p><h3 id="多样链接"><a href="#多样链接" class="headerlink" title="多样链接"></a>多样链接</h3><p><img src="https://user-images.githubusercontent.com/12621342/33876419-70107f68-df60-11e7-8858-9c062bdb4e6e.png" alt=""></p><p>支持4种剪贴板链接格式，让你的文本编辑游刃有余。</p><h2 id="后续工作"><a href="#后续工作" class="headerlink" title="后续工作"></a>后续工作</h2><p>目前PicGo还是一个很年轻的项目，bug肯定是不少的，功能方面也有所欠缺。所以还需要不断地完善。我希望大家在使用的过程中有什么意见或者建议都可以在项目仓库里的<a href="https://github.com/Molunerfinn/PicGo/issues" target="_blank" rel="noopener">issues</a>里提出来~</p><ul><li>目前暂不支持Windows和linux，未来将会逐步支持。</li><li>未来将支持更多的图床。如果可能，可以支持自定义的图床（只要设定好协议）</li><li>将集成系统服务，提供一键上传的全局快捷键</li><li>提升用户体验，修bug</li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>希望这是一个能够提升你文章编辑体验的工具。如果你想学习electron开发，我也会在不久之后写几篇文章用于记录我是如何开发<code>PicGo</code>这个electron应用的。如果你喜欢它，欢迎给这个<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">项目</a>点个Star。另外，它是开源免费的，如果你觉得它对你有所帮助，也可以考虑给我打赏一杯喝咖啡的钱~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/8700af19ly1fmd6ou9eynj2046046glj&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;作为一个比较常用markdown写文章、博客的人，在markdown里插入图片对我而言一直一个比较繁琐的活。以前每周写电影推荐的时候，我要在markdown里插入一张电影海报，我需要如下的操作：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;打开豆瓣的网站，选一张满意的海报，下载&lt;/li&gt;&lt;li&gt;打开七牛的网站，登录，点点点，找到上传，上传&lt;/li&gt;&lt;li&gt;关闭上传窗口，找到地址，复制地址，再关闭七牛&lt;/li&gt;&lt;li&gt;粘贴到markdown里&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;每次都需要繁琐的打开网页进行一些必要而枯燥的操作。这样很麻烦。在用过mac上一款很不错的小工具应用iPic后我非常喜欢它的简洁操作。不过它免费版本并不支持七牛图床。所以我就想着，能不能自己写一个类似的工具呢？结合自己的使用习惯再顺便加点功能。&lt;/p&gt;&lt;p&gt;于是我就开始自己的图片上传工具的开发了。它叫做&lt;a href=&quot;https://github.com/Molunerfinn/PicGo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PicGo&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="https://molunerfinn.com/categories/Web/"/>
    
      <category term="开发" scheme="https://molunerfinn.com/categories/Web/%E5%BC%80%E5%8F%91/"/>
    
      <category term="electron" scheme="https://molunerfinn.com/categories/Web/%E5%BC%80%E5%8F%91/electron/"/>
    
    
      <category term="web" scheme="https://molunerfinn.com/tags/web/"/>
    
      <category term="vue" scheme="https://molunerfinn.com/tags/vue/"/>
    
      <category term="electron" scheme="https://molunerfinn.com/tags/electron/"/>
    
  </entry>
  
  <entry>
    <title>全栈测试实战：用Jest测试Vue+Koa全栈应用</title>
    <link href="https://molunerfinn.com/Use-Jest-To-Test-Vue-Koa/"/>
    <id>https://molunerfinn.com/Use-Jest-To-Test-Vue-Koa/</id>
    <published>2017-11-15T21:34:00.000Z</published>
    <updated>2018-04-27T08:26:51.713Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今年一月份的时候我写了一个<a href="https://github.com/Molunerfinn/vue-koa-demo" target="_blank" rel="noopener">Vue+Koa的全栈应用</a>，以及相应的<a href="https://molunerfinn.com/Vue+Koa/">配套教程</a>，得到了很多的好评。同时我也在和读者交流的过程中不断认识到不足和缺点，于是也对此进行了不断的更新和完善。本次带来的完善是加入和完整的前后端测试。相信对于很多学习前端的朋友来说，<code>测试</code>这个东西似乎是个熟悉的陌生人。你听过，但是你未必做过。如果你对前端（以及nodejs端）测试很熟悉，那么本文的帮助可能不大，不过我很希望能得到你们提出的宝贵意见！</p><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>和上一篇<a href="https://molunerfinn.com/Vue+Koa/">全栈开发实战：用Vue2+Koa1开发完整的前后端项目</a>一样，本文从测试新手的角度出发（默认了解Koa并付诸实践，了解Vue并付诸实践，但是并无测试经历），在已有的项目上从0开始构建我们的全栈测试系统。可以了解到测试的意义，<a href="https://facebook.github.io/jest/" target="_blank" rel="noopener">Jest</a>测试框架的搭建，前后端测试的异同点，如何写测试用例，如何查看测试结果并提升我们的测试覆盖率，100%测试覆盖率是否是必须，以及在搭建测试环境、以及测试本身过程中遇到的各种疑难杂症。希望可以作为入门前端以及Node端测试的文章吧。</p><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>有了之前的项目结构作为骨架，加入Jest测试框架就很简单了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── LICENSE</span><br><span class="line">├── README.md</span><br><span class="line">├── .env  // 环境变量配置文件</span><br><span class="line">├── app.js  // Koa入口文件</span><br><span class="line">├── build // vue-cli 生成，用于webpack监听、构建</span><br><span class="line">│   ├── build.js</span><br><span class="line">│   ├── check-versions.js</span><br><span class="line">│   ├── dev-client.js</span><br><span class="line">│   ├── dev-server.js</span><br><span class="line">│   ├── utils.js</span><br><span class="line">│   ├── webpack.base.conf.js</span><br><span class="line">│   ├── webpack.dev.conf.js</span><br><span class="line">│   └── webpack.prod.conf.js</span><br><span class="line">├── config // vue-cli 生成&amp;自己加的一些配置文件</span><br><span class="line">│   ├── default.conf</span><br><span class="line">│   ├── dev.env.js</span><br><span class="line">│   ├── index.js</span><br><span class="line">│   └── prod.env.js</span><br><span class="line">├── dist // Vue build 后的文件夹</span><br><span class="line">│   ├── index.html // 入口文件</span><br><span class="line">│   └── static // 静态资源</span><br><span class="line">├── env.js // 环境变量切换相关 &lt;-- 新</span><br><span class="line">├── .env // 开发、上线时的环境变量 &lt;-- 新</span><br><span class="line">├── .env.test // 测试时的环境变量 &lt;-- 新</span><br><span class="line">├── index.html // vue-cli生成，用于容纳Vue组件的主html文件。单页应用就只有一个html</span><br><span class="line">├── package.json // npm的依赖、项目信息文件、Jest的配置项 &lt;-- 新</span><br><span class="line">├── server // Koa后端，用于提供Api</span><br><span class="line">│   ├── config // 配置文件夹</span><br><span class="line">│   ├── controllers // controller-控制器</span><br><span class="line">│   ├── models // model-模型</span><br><span class="line">│   ├── routes // route-路由</span><br><span class="line">│   └── schema // schema-数据库表结构</span><br><span class="line">├── src // vue-cli 生成&amp;自己添加的utils工具类</span><br><span class="line">│   ├── App.vue // 主文件</span><br><span class="line">│   ├── assets // 相关静态资源存放</span><br><span class="line">│   ├── components // 单文件组件</span><br><span class="line">│   ├── main.js // 引入Vue等资源、挂载Vue的入口js</span><br><span class="line">│   └── utils // 工具文件夹-封装的可复用的方法、功能</span><br><span class="line">├── test</span><br><span class="line">│   ├── sever // 服务端测试 &lt;-- 新</span><br><span class="line">│   └── client // 客户端（前端）测试 &lt;-- 新</span><br><span class="line">└── yarn.lock // 用yarn自动生成的lock文件</span><br></pre></td></tr></table></figure><p>可以看到新增的或者说更新的东西只有几个：</p><ol><li>最主要的test文件夹，包含了客户端（前端）和服务端的测试文件</li><li>env.js以及配套的<code>.env</code>、<code>.env.test</code>，是跟测试相关的环境变量</li><li>package.json，更新了一些依赖以及Jest的配置项</li></ol><blockquote><p>主要环境：Vue2，Koa2，Nodejs v8.9.0</p></blockquote><h2 id="测试用到的一些关键依赖"><a href="#测试用到的一些关键依赖" class="headerlink" title="测试用到的一些关键依赖"></a>测试用到的一些关键依赖</h2><p>以下依赖的版本都是本文所写的时候的版本，或者更旧一些</p><ol><li>jest: ^21.2.1</li><li>babel-jest: ^21.2.0</li><li>supertest: ^3.0.0</li><li>dotenv: ^4.0.0</li></ol><p>剩下依赖可以项目<a href="https://github.com/Molunerfinn/vue-koa-demo" target="_blank" rel="noopener">demo仓库</a>。</p><h2 id="搭建Jest测试环境"><a href="#搭建Jest测试环境" class="headerlink" title="搭建Jest测试环境"></a>搭建Jest测试环境</h2><p>对于测试来说，我也是个新手。至于为什么选择了<a href="https://facebook.github.io/jest/" target="_blank" rel="noopener">Jest</a>，而不是其他框架（例如mocha+chai、jasmine等），我觉得有如下我自己的观点（当然你也可以不采用它）：</p><ol><li>由Facebook开发，保证了更新速度以及框架质量</li><li>它有很多集成的功能（比如断言库、比如测试覆盖率）</li><li>文档完善，配置简单</li><li>支持typescript，我在学习typescript的时候也用了Jest来写测试</li><li>Vue官方的单元测试框架<a href="https://github.com/vuejs/vue-test-utils" target="_blank" rel="noopener">vue-test-utils</a>专门有配合Jest的测试说明</li><li>支持快照功能，对前端单元测试是一大利好</li><li>如果你是React技术栈，Jest天生就适配React</li></ol><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yarn add jest -D</span><br><span class="line"></span><br><span class="line"><span class="comment">#or</span></span><br><span class="line"></span><br><span class="line">npm install jest --save-dev</span><br></pre></td></tr></table></figure><p>很简单对吧。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>由于我项目的Koa后端用的是ES modules的写法而不是Nodejs的Commonjs的写法，所以是需要babel的插件来进行转译的。否则你运行测试用例的时候，将会出现如下问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">● Test suite failed to run</span><br><span class="line"></span><br><span class="line">   /Users/molunerfinn/Desktop/work/web/vue-koa-demo/test/sever/todolist.test.js:1</span><br><span class="line">   (&#123;&quot;Object.&lt;anonymous&gt;&quot;:function(module,exports,require,__dirname,__filename,global,jest)&#123;import _regeneratorRuntime from &apos;babel-runtime/regenerator&apos;;import _asyncToGenerator from &apos;babel-runtime/helpers/asyncToGenerator&apos;;var _this = this;import server from &apos;../../app.js&apos;;</span><br><span class="line">                                                                                            ^^^^^^</span><br><span class="line"></span><br><span class="line">   SyntaxError: Unexpected token import</span><br><span class="line"></span><br><span class="line">     at ScriptTransformer._transformAndBuildScript (node_modules/jest-runtime/build/script_transformer.js:305:17)</span><br><span class="line">         at Generator.next (&lt;anonymous&gt;)</span><br><span class="line">         at new Promise (&lt;anonymous&gt;)</span><br></pre></td></tr></table></figure><p>看了官方github的<a href="https://github.com/facebook/jest#using-babel" target="_blank" rel="noopener">README</a>发现应该是<code>babel-jest</code>没装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yarn add babel-jest -D</span><br><span class="line"></span><br><span class="line"><span class="comment">#or</span></span><br><span class="line"></span><br><span class="line">npm install babel-jest --save-dev</span><br></pre></td></tr></table></figure><blockquote><p>但是奇怪的是，文档里说：Note: babel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. 也就是babel-jest在jest安装的时候便会自动安装了。这点需要求证。</p></blockquote><p>然而发现运行测试用例的时候还是出了上述问题，查阅了相关<a href="https://github.com/facebook/jest/issues/2081" target="_blank" rel="noopener">issue</a>之后，我给出两种解决办法：</p><p>都是修改项目目录下的<code>.babelrc</code>配置文件，增加<code>env</code>属性，配置<code>test</code>环境如下：</p><p><strong>1.</strong> 增加<code>presets</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"env": &#123;</span><br><span class="line">  "test": &#123;</span><br><span class="line">    "presets": ["env", "stage-2"] // 采用babel-presents-env来转译</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.</strong> 或者增加<code>plugins</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"env": &#123;</span><br><span class="line">  "test": &#123;</span><br><span class="line">    "plugins": ["transform-es2015-modules-commonjs"] // 采用plugins来讲ES modules转译成Commonjs modules</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次运行，编译通过。</p><blockquote><p>通常我们将测试文件（*.test.js或*.spec.js）放置在项目的test目录下。Jest将会自动运行这些测试用例。值得一提的是，通常我们将基于<code>TDD</code>的测试文件命名为<code>*.test.js</code>，把基于<code>BDD</code>的测试文件命名为<code>*.spec.js</code>。这二者的区别可以看这篇<a href="http://www.cnblogs.com/ustbwuyi/archive/2012/10/26/2741223.html" target="_blank" rel="noopener">文章</a></p></blockquote><p>我们可以在<code>package.json</code>的<code>scripts</code>字段里加入<code>test</code>的命令（如果原本存在则换一个名字，不要冲突）</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  // ...其他命令</span><br><span class="line">  "test": "jest"</span><br><span class="line">  // ...其他命令</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>这样我们就可以在终端直接运行<code>npm test</code>来执行测试了。下面我们先来从后端的Api测试开始写起。</p><h2 id="Koa后端Api测试"><a href="#Koa后端Api测试" class="headerlink" title="Koa后端Api测试"></a>Koa后端Api测试</h2><p>重现一下之前的应用的操作流程，可以发现应用分为登录前和登录后两种状态。</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fl97i5zzb0g20z30ixk77.gif" alt=""></p><p>可以根据操作流程或者后端api的结构来写测试。如果根据操作流程来写测试就可以分为登录前和登录后。如果根据后端api的结构的话，就可以根据routes或者controllers的结构、功能来写测试。</p><p>由于本例登录前和登录后的api基本上是分开的，所以我主要根据上述后者（routes或controllers）来写测试。</p><p>到此需要解释一下一般来说（写）测试的步骤：</p><ol><li>写测试说明，针对你的每条测试说明测试了什么功能，预期结果是什么。</li><li>写测试主体，通常是 输入 -&gt; 输出。</li><li>判断测试结果，拿输出和预期做对比。如果输出和预期相符，则测试通过。反之，不通过。</li></ol><p>在<code>test</code>文件夹下新建一个<code>server</code>文件夹。然后创建一个<code>user.spec.js</code>文件。</p><p>我们可以通过</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> server <span class="keyword">from</span> <span class="string">'../../app.js'</span></span><br></pre></td></tr></table></figure><p>的方式将我们的Koa应用的主入口文件引入。但是此时遇到了一个问题。我们如何对这个server发起http请求，并对其的返回结果做出判断呢？</p><p>在阅读了<a href="https://hackernoon.com/async-testing-koa-with-jest-1b6e84521b71" target="_blank" rel="noopener">Async testing Koa with Jest</a>以及<a href="https://www.valentinog.com/blog/testing-api-koa-jest/" target="_blank" rel="noopener">A clear and concise introduction to testing Koa with Jest and Supertest</a>这两篇文章之后，我决定使用<a href="https://github.com/visionmedia/supertest" target="_blank" rel="noopener">supertest</a>这个工具了。它是专门用来测试nodejs端HTTP server的测试工具。它内封了<a href="https://github.com/visionmedia/superagent" target="_blank" rel="noopener">superagent</a>这个著名的Ajax请求库。并且支持Promise，意味着我们对于异步请求的结果也能通过<code>async await</code>的方式很好的控制了。</p><p>安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yarn add supertest -D</span><br><span class="line"></span><br><span class="line"><span class="comment">#or</span></span><br><span class="line"></span><br><span class="line">npm install supertest --save-dev</span><br></pre></td></tr></table></figure><p>现在开始着手写我们第一个测试用例。先写一个针对登录功能的吧。当我们输入了错误的用户名或者密码的时候将无法登录，后端返回的参数里，success会是false。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test/server/user.spec.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> server <span class="keyword">from</span> <span class="string">'../../app.js'</span></span><br><span class="line"><span class="keyword">import</span> request <span class="keyword">from</span> <span class="string">'supertest'</span></span><br><span class="line"></span><br><span class="line">afterEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  server.close() <span class="comment">// 当所有测试都跑完了之后，关闭server</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果输入用户名为Molunerfinn，密码为1234则无法登录。正确应为molunerfinn和123。</span></span><br><span class="line">test(<span class="string">'Failed to login if typing Molunerfinn &amp; 1234'</span>, <span class="keyword">async</span> () =&gt; &#123; <span class="comment">// 注意用了async</span></span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> request(server) <span class="comment">// 注意这里用了await</span></span><br><span class="line">                    .post(<span class="string">'/auth/user'</span>) <span class="comment">// post方法向'/auth/user'发送下面的数据</span></span><br><span class="line">                    .send(&#123;</span><br><span class="line">                      name: <span class="string">'Molunerfinn'</span>,</span><br><span class="line">                      password: <span class="string">'1234'</span></span><br><span class="line">                    &#125;)</span><br><span class="line">  expect(response.body.success).toBe(<span class="literal">false</span>) <span class="comment">// 期望回传的body的success值是false（代表登录失败）</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>上述例子中，test()方法能接受3个参数，第一个是对测试的描述(string)，第二个是回调函数(fn)，第三个是延时参数(number)。本例不需要延时。然后expect()函数里放输出，再用各种<a href="https://facebook.github.io/jest/docs/en/expect.html" target="_blank" rel="noopener">match</a>方法来将预期和输出做对比。</p></blockquote><p>在终端执行<code>npm test</code>，紧张地希望能跑通也许是人生的第一个测试用例。结果我得到如下关键的报错信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">● Post todolist failed if not give the params</span><br><span class="line"></span><br><span class="line">   TypeError: app.address is not a function</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">● Post todolist failed if not give the params</span><br><span class="line"></span><br><span class="line">   TypeError: _app2.default.close is not a function</span><br></pre></td></tr></table></figure><p>这是怎么回事？说明我们import进来的server看来并没有close、address等方法。原因在于我们在<code>app.js</code>里最后一句：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> app</span><br></pre></td></tr></table></figure><p>此处export出来的是一个对象。但我们实际上需要一个function。</p><p>在谷歌的过程中，找到两种解决办法：</p><blockquote><p>参考<a href="https://segmentfault.com/q/1010000006906863" target="_blank" rel="noopener">解决办法1</a>和<a href="https://hackernoon.com/async-testing-koa-with-jest-1b6e84521b71" target="_blank" rel="noopener">解决办法2</a></p></blockquote><p><strong>1.</strong> 修改<code>app.js</code></p><p>将</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.listen(<span class="number">8889</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Koa is listening in 8889`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> app</span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> app.listen(<span class="number">8889</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Koa is listening in 8889`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>即可。</p><p><strong>2.</strong> 修改你的test文件：</p><p>在里要用到<code>server</code>的地方都改为<code>server.callback()</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> request(server.callback())</span><br><span class="line">                    .post(<span class="string">'/auth/user'</span>)</span><br><span class="line">                    .send(&#123;</span><br><span class="line">                      name: <span class="string">'Molunerfinn'</span>,</span><br><span class="line">                      password: <span class="string">'1234'</span></span><br><span class="line">                    &#125;)</span><br></pre></td></tr></table></figure><p>我采用的是第一种做法。</p><p>改完之后，顺利通过：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PASS  test/sever/user.test.js</span><br><span class="line"> ✓ Failed to login if typing Molunerfinn &amp; 1234 (248ms)</span><br></pre></td></tr></table></figure><p>然而此时发现一个问题，为何测试结束了，jest还占用着终端进程呢？我想要的是测试完jest就自动退出了。查了一下文档，发现它的cli有个参数<code>--forceExit</code>能解决这个问题，于是就把<code>package.json</code>里的<code>test</code>命令修改一下（后续我们还将修改几次）加上这个参数：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  // ...其他命令</span><br><span class="line">  "test": "jest --forceExit"</span><br><span class="line">  // ...其他命令</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>再测试一遍，发现没问题。这样一来我们就可以继续依葫芦画瓢，把<code>auth/*</code>这个路由的功能都测试一遍：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server/routes/auth.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> auth <span class="keyword">from</span> <span class="string">'../controllers/user.js'</span></span><br><span class="line"><span class="keyword">import</span> koaRouter <span class="keyword">from</span> <span class="string">'koa-router'</span></span><br><span class="line"><span class="keyword">const</span> router = koaRouter()</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/user/:id'</span>, auth.getUserInfo) <span class="comment">// 定义url的参数是id</span></span><br><span class="line">router.post(<span class="string">'/user'</span>, auth.postUserAuth)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure><p>测试用例如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> server <span class="keyword">from</span> <span class="string">'../../app.js'</span></span><br><span class="line"><span class="keyword">import</span> request <span class="keyword">from</span> <span class="string">'supertest'</span></span><br><span class="line"></span><br><span class="line">afterEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  server.close()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'Failed to login if typing Molunerfinn &amp; 1234'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> request(server)</span><br><span class="line">                    .post(<span class="string">'/auth/user'</span>)</span><br><span class="line">                    .send(&#123;</span><br><span class="line">                      name: <span class="string">'Molunerfinn'</span>,</span><br><span class="line">                      password: <span class="string">'1234'</span></span><br><span class="line">                    &#125;)</span><br><span class="line">  expect(response.body.success).toBe(<span class="literal">false</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'Successed to login if typing Molunerfinn &amp; 123'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> request(server)</span><br><span class="line">                    .post(<span class="string">'/auth/user'</span>)</span><br><span class="line">                    .send(&#123;</span><br><span class="line">                      name: <span class="string">'Molunerfinn'</span>,</span><br><span class="line">                      password: <span class="string">'123'</span></span><br><span class="line">                    &#125;)</span><br><span class="line">  expect(response.body.success).toBe(<span class="literal">true</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'Failed to login if typing MARK &amp; 123'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> request(server)</span><br><span class="line">                    .post(<span class="string">'/auth/user'</span>)</span><br><span class="line">                    .send(&#123;</span><br><span class="line">                      name: <span class="string">'MARK'</span>,</span><br><span class="line">                      password: <span class="string">'123'</span></span><br><span class="line">                    &#125;)</span><br><span class="line">  expect(response.body.info).toBe(<span class="string">'用户不存在！'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'Getting the user info is null if the url is /auth/user/10'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> request(server)</span><br><span class="line">                    .get(<span class="string">'/auth/user/10'</span>)</span><br><span class="line">  expect(response.body).toEqual(&#123;&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'Getting user info successfully if the url is /auth/user/2'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> request(server)</span><br><span class="line">                    .get(<span class="string">'/auth/user/2'</span>)</span><br><span class="line">  expect(response.body.user_name).toBe(<span class="string">'molunerfinn'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>都很简洁易懂，看描述+预期你就能知道在测试什么了。不过需要注意一点的是，我们用到了<code>toBe()</code>和<code>toEqual()</code>两个方法。乍一看好像没有区别。实际上有大区别。</p><p>简单来说，<code>toBe()</code>适合<code>===</code>这个判断条件。比如<code>1 === 1</code>，<code>&#39;hello&#39; === &#39;hello&#39;</code>。但是<code>[1] === [1]</code>是错的。具体原因不多说，js的基础。所以要判断比如数组或者对象相等的话需要用<code>toEqual()</code>这个方法。</p><p>OK，接下去我们开始测试<code>api/*</code>这个路由。</p><p>在<code>test</code>目录下创建一个叫做<code>todolits.spec.js</code>的文件：</p><p>有了上一个测试的经验，测试这个其实也不会有多大的问题。首先我们来测试一下当我们没有携带上JSON WEB TOKEN的header的话，服务端是不是返回401错误：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> server <span class="keyword">from</span> <span class="string">'../../app.js'</span></span><br><span class="line"><span class="keyword">import</span> request <span class="keyword">from</span> <span class="string">'supertest'</span></span><br><span class="line"></span><br><span class="line">afterEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  server.close()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'Getting todolist should return 401 if not set the JWT'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> request(server)</span><br><span class="line">                    .get(<span class="string">'/api/todolist/2'</span>)</span><br><span class="line">  expect(response.status).toBe(<span class="number">401</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>一切看似没问题，但是运行的时候却报错了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">console.error node_modules/jest-jasmine2/build/jasmine/Env.js:194</span><br><span class="line">    Unhandled error</span><br><span class="line"></span><br><span class="line">console.error node_modules/jest-jasmine2/build/jasmine/Env.js:195</span><br><span class="line">  Error: listen EADDRINUSE :::8888</span><br><span class="line">      at Object._errnoException (util.js:1024:11)</span><br><span class="line">      at _exceptionWithHostPort (util.js:1046:20)</span><br><span class="line">      at Server.setupListenHandle [as _listen2] (net.js:1351:14)</span><br><span class="line">      at listenInCluster (net.js:1392:12)</span><br><span class="line">      at Server.listen (net.js:1476:7)</span><br><span class="line">      at Application.listen (/Users/molunerfinn/Desktop/work/web/vue-koa-demo/node_modules/koa/lib/application.js:64:26)</span><br><span class="line">      at Object.&lt;anonymous&gt; (/Users/molunerfinn/Desktop/work/web/vue-koa-demo/app.js:60:5)</span><br><span class="line">      at Runtime._execModule (/Users/molunerfinn/Desktop/work/web/vue-koa-demo/node_modules/jest-runtime/build/index.js:520:13)</span><br><span class="line">      at Runtime.requireModule (/Users/molunerfinn/Desktop/work/web/vue-koa-demo/node_modules/jest-runtime/build/index.js:332:14)</span><br><span class="line">      at Runtime.requireModuleOrMock (/Users/molunerfinn/Desktop/work/web/vue-koa-demo/node_modules/jest-runtime/build/index.js:408:19)</span><br></pre></td></tr></table></figure><p>看来是因为同时运行了两个Koa实例导致了监听端口的冲突。所以我们需要让Jest按顺序执行。查阅官方文档，发现了<a href="http://facebook.github.io/jest/docs/en/cli.html#runinband" target="_blank" rel="noopener">runInBand</a>这个参数正是我们想要的。</p><p>所以修改<code>package.json</code>里的<code>test</code>命令如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  // ...其他命令</span><br><span class="line">  "test": "jest --forceExit --runInBand"</span><br><span class="line">  // ...其他命令</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>再次运行，成功通过！</p><p>接下来遇到一个问题。我们的JWT的token原本是登录成功后生成并派发给前端的。如今我们测试api的时候并没有经过登录那一步。所以要测试的时候要用的token的话，我觉得有两种办法：</p><ol><li>增加测试的时候的api接口，不需要经过<code>koa-jwt</code>的验证。但是这种方法对项目有入侵性的影响，如果有的时候我们需要从token获取信息的话就有问题了。</li><li>后端预先生成一个合法的token，然后测试的时候用上这个测试的token即可。不过这种办法的话就需要保证token不能泄露。</li></ol><p>我采用第二种办法。为了读者使用方便我是预先生成一个token然后用一个变量存起来的。（真正的开发环境下应对将测试的token放置在项目环境变量.env中）</p><p>接下来我们测试一下数据库的四大操作：增删改查。不过我们为了一次性将这四个接口都测试一遍可以按照这个顺序：增查改删。其实就是先增加一个todo，然后查找的时候将id记录下来。随后可以用这个id进行更新和删除。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> server <span class="keyword">from</span> <span class="string">'../../app.js'</span></span><br><span class="line"><span class="keyword">import</span> request <span class="keyword">from</span> <span class="string">'supertest'</span></span><br><span class="line"></span><br><span class="line">afterEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  server.close()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> token = <span class="string">'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoibW9sdW5lcmZpbm4iLCJpZCI6MiwiaWF0IjoxNTA5ODAwNTg2fQ.JHHqSDNUgg9YAFGWtD0m3mYc9-XR3Gpw9gkZQXPSavM'</span> <span class="comment">// 预先生成的token</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> todoId = <span class="literal">null</span> <span class="comment">// 用来存放测试生成的todo的id</span></span><br><span class="line"></span><br><span class="line">test(<span class="string">'Getting todolist should return 401 if not set the JWT'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> request(server)</span><br><span class="line">                    .get(<span class="string">'/api/todolist/2'</span>)</span><br><span class="line">  expect(response.status).toBe(<span class="number">401</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增</span></span><br><span class="line">test(<span class="string">'Created todolist successfully if set the JWT &amp; correct user'</span>, <span class="keyword">async</span> () =&gt; &#123; </span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> request(server)</span><br><span class="line">                    .post(<span class="string">'/api/todolist'</span>)</span><br><span class="line">                    .send(&#123;</span><br><span class="line">                      status: <span class="literal">false</span>,</span><br><span class="line">                      content: <span class="string">'来自测试'</span>,</span><br><span class="line">                      id: <span class="number">2</span></span><br><span class="line">                    &#125;)</span><br><span class="line">                    .set(<span class="string">'Authorization'</span>, <span class="string">'Bearer '</span> + token) <span class="comment">// header处加入token验证</span></span><br><span class="line">  expect(response.body.success).toBe(<span class="literal">true</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查</span></span><br><span class="line">test(<span class="string">'Getting todolist successfully if set the JWT &amp; correct user'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> request(server)</span><br><span class="line">                    .get(<span class="string">'/api/todolist/2'</span>)</span><br><span class="line">                    .set(<span class="string">'Authorization'</span>, <span class="string">'Bearer '</span> + token)</span><br><span class="line">  response.body.result.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (item.content === <span class="string">'来自测试'</span>) todoId = item.id <span class="comment">// 获取id</span></span><br><span class="line">  &#125;)</span><br><span class="line">  expect(response.body.success).toBe(<span class="literal">true</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改</span></span><br><span class="line">test(<span class="string">'Updated todolist successfully if set the JWT &amp; correct todoId'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> request(server)</span><br><span class="line">                    .put(<span class="string">`/api/todolist/2/<span class="subst">$&#123;todoId&#125;</span>/0`</span>) <span class="comment">// 拿id去更新</span></span><br><span class="line">                    .set(<span class="string">'Authorization'</span>, <span class="string">'Bearer '</span> + token)</span><br><span class="line">  expect(response.body.success).toBe(<span class="literal">true</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删</span></span><br><span class="line">test(<span class="string">'Removed todolist successfully if set the JWT &amp; correct todoId'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> request(server)</span><br><span class="line">                    .delete(<span class="string">`/api/todolist/2/<span class="subst">$&#123;todoId&#125;</span>`</span>)</span><br><span class="line">                    .set(<span class="string">'Authorization'</span>, <span class="string">'Bearer '</span> + token)</span><br><span class="line">  expect(response.body.success).toBe(<span class="literal">true</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>对照着api的4大接口，我们已经将它们都测试了一遍。那是不是我们对于服务端的测试已经结束了呢？其实不是的。要想保证后端api的健壮性，我们得将很多情况都考虑到。但是人为的去排查每个条件、语句什么的必然过于繁琐和机械。于是我们需要一个指标来帮我们确保测试的全面性。这就是测试覆盖率了。</p><h3 id="后端api测试覆盖率"><a href="#后端api测试覆盖率" class="headerlink" title="后端api测试覆盖率"></a>后端api测试覆盖率</h3><p>上面说过，Jest是自带了测试覆盖率功能的（其实就是基于<a href="https://github.com/gotwarlost/istanbul" target="_blank" rel="noopener">istanbul</a>这个工具来生成测试覆盖率的）。要如何开启呢？这里我还走了不少坑。</p><p>通过阅读官方的<a href="http://facebook.github.io/jest/docs/en/configuration.html" target="_blank" rel="noopener">配置文档</a>，我确定了几个需要开启的参数：</p><ol><li>coverageDirectory，指定输出测试覆盖率报告的目录</li><li>coverageReporters，指定输出的测试覆盖率报告的形式，具体可以参考istanbul的<a href="https://istanbul.js.org/docs/advanced/alternative-reporters/" target="_blank" rel="noopener">说明</a></li><li>collectCoverage，是否要收集覆盖率信息，当然是。</li><li>mapCoverage，由于我们的代码经过babel-jest转译，所以需要开启sourcemap来让Jest能够把测试结果定位到源代码上而不是编译的代码上。</li><li>verbose，用于显示每个测试用例的通过与否。</li></ol><p>于是我们需要在<code>package.json</code>里配置一个Jest字段（不是在scripts字段里配置，而是和scripts在同一级的字段），来配置Jest。</p><p>配置如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">"jest": &#123;</span><br><span class="line">  "verbose": true,</span><br><span class="line">  "coverageDirectory": "coverage",</span><br><span class="line">  "mapCoverage": true,</span><br><span class="line">  "collectCoverage": true,</span><br><span class="line">  "coverageReporters": [</span><br><span class="line">    "lcov", // 会生成lcov测试结果以及HTML格式的漂亮的测试覆盖率报告</span><br><span class="line">    "text" // 会在命令行界面输出简单的测试报告</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们再进行一遍测试，可以看到在终端里已经输出了简易的测试报告总结：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1flc95bhjwmj20y80lijus.jpg" alt=""></p><p>从中我们能看到一些字段是100%，而一些不是100%。最后一列<code>Uncovered Lines</code>就是告诉我们，测试里没有覆盖到的代码行。为了更直观地看到测试的结果报告，可以到项目的根目录下找到一个<code>coverage</code>的目录，在<code>lcov-report</code>目录里有个<code>index.html</code>就是输出的html报告。打开来看看：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fld7tv6c91j21z20h0n0f.jpg" alt=""></p><p>首页是个概览，跟命令行里输出的内容差不多。不过我们可以往深了看，可以点击左侧的File提供的目录：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fld8bgzj3gj21z20hotc4.jpg" alt=""></p><p>然后我们可以看到没有被覆盖到代码行数（50）以及有一个函数没有被测试到：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fld8erd8g6j215w05a757.jpg" alt=""></p><p>通常我们没有测试到的函数也伴随着代码行数没有被测试到。我们可以看到在本例里，app的<code>error</code>事件没有被触发过。想想也是的，我们的测试都是建立在合法的api请求的基础上的。所以自然不会触发<code>error</code>事件。因此我们需要写一个测试用例来测试这个<code>.on(&#39;error&#39;)</code>的函数。</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fld8fyapefj21z20fy0yc.jpg" alt=""></p><p>通常这样的测试用例并不是特别好写。不过好在我们可以尝试去触发server端的错误，对于本例来说，如果向服务端创建一个todo的时候，没有附上相应的信息（id、status、content），就无法创建相应的todo，会触发错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// server/models/todolist.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> createTodolist = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> Todolist.create(&#123;</span><br><span class="line">    user_id: data.id,</span><br><span class="line">    content: data.content,</span><br><span class="line">    status: data.status</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是server端创建todo的相关函数，下面是针对它的错误进行的测试：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test/server/todolist.spec.js</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">test(<span class="string">'Failed to create a todo if not give the params'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> request(server)</span><br><span class="line">            .post(<span class="string">'/api/todolist'</span>)</span><br><span class="line">            .set(<span class="string">'Authorization'</span>, <span class="string">'Bearer '</span> + token) <span class="comment">// 不发送创建的参数</span></span><br><span class="line">  expect(response.status).toBe(<span class="number">500</span>) <span class="comment">// 服务端报500错误</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>再进行测试，发现之前对于app.js的相关测试都已经是100%了。</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fld8s0m0g5j20xy0lq41t.jpg" alt=""></p><p>不过<code>controllers/todolist.js</code>里还是有未测试到的行数34，以及我们可以看到<code>% Branch</code>这列的数字显示的是50而不是100。<code>Branch</code>的意思就是分支测试。什么是分支测试呢？简单来说就是你的条件语句测试。比如一个<code>if...else</code>语句，如果测试用例只跑过<code>if</code>的条件，而没有跑过<code>else</code>的条件，那么<code>Branch</code>的测试就不完整。让我们来看看是什么条件没有测试到？</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fld8yzgta5j214w0b6di6.jpg" alt=""></p><p>可以看到是个三元表达式并没有测试完整。（三元表达式也算分支）我们测试了0的情况，但是没有测试非零的情况，所以再写一个非零的情况：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'Failed to update todolist  if not update the status of todolist'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> request(server)</span><br><span class="line">                    .put(<span class="string">`/api/todolist/2/<span class="subst">$&#123;todoId&#125;</span>/1`</span>) <span class="comment">// &lt;- 这里最后一个参数改成了1</span></span><br><span class="line">                    .set(<span class="string">'Authorization'</span>, <span class="string">'Bearer '</span> + token)</span><br><span class="line">  expect(response.body.success).toBe(<span class="literal">false</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>再次跑测试：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fld977icalj20x40lmdj2.jpg" alt=""></p><p>哈，成功做到了100%测试覆盖率！</p><h3 id="端口占用和环境变量的引入"><a href="#端口占用和环境变量的引入" class="headerlink" title="端口占用和环境变量的引入"></a>端口占用和环境变量的引入</h3><p>虽然做到了100%测试覆盖率，但是有一个问题却是不容忽视的。那就是我们现在测试环境和开发环境下的服务端监听的端口是一致的。意味着你不能在开发环境下测试你的代码。比如你写完一个api之后马上要写一个测试用例的时候，如果测试环境和开发环境的服务端监听的端口一致的话，测试的时候就会因为端口被占用而无法被监听到。</p><p>所以我们需要指定一下测试环境下的端口，让它和开发乃至生产环境的端口不一样。我一开始想法很简单，指定一下<code>NODE_ENV=test</code>的时候用8888端口，开发环境下用8889端口。在<code>app.js</code>里就是这样写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">let</span> port = process.env.NODE_ENV === <span class="string">'test'</span> ? <span class="number">8888</span> : <span class="number">8889</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> app.listen(port, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Koa is listening in <span class="subst">$&#123;port&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>接下去就遇到了两个问题：</p><ol><li>需要解决跨平台env设置</li><li>这样设置的话一旦在测试环境下，对于port这句话，<code>Branch</code>测试是无法完全通过的——因为始终是在test环境下，无法运行到<code>port = 8889</code>那个条件</li></ol><h4 id="跨平台env设置"><a href="#跨平台env设置" class="headerlink" title="跨平台env设置"></a>跨平台env设置</h4><p>跨平台env主要涉及到windows、linux和macOS。要在三个平台在测试的时候都跑着<code>NODE_ENV=test</code>的话，我们需要借助<a href="https://github.com/kentcdodds/cross-env" target="_blank" rel="noopener">cross-env</a>来帮助我们。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yarn add cross-env -D</span><br><span class="line"></span><br><span class="line"><span class="comment">#or</span></span><br><span class="line"></span><br><span class="line">npm install cross-env --save-dev</span><br></pre></td></tr></table></figure><p>然后在<code>package.json</code>里修改<code>test</code>的命令如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  // ...其他命令</span><br><span class="line">  "test": "cross-env NODE_ENV=test jest --forceExit --runInBand"</span><br><span class="line">  // ...其他命令</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>这样就能在后端代码里，通过<code>process.env.NODE_ENV</code>这个变量访问到<code>test</code>这个值。这样就解决了第一个问题。</p><h4 id="端口分离并保证测试覆盖率"><a href="#端口分离并保证测试覆盖率" class="headerlink" title="端口分离并保证测试覆盖率"></a>端口分离并保证测试覆盖率</h4><p>目前为止，我们已经能够解决测试环境和开发环境的监听端口一致的问题了。不过却带来了测试覆盖率不全的问题。</p><p>为此我找到两种解决办法：</p><ol><li>通过istanbul特殊的<a href="https://github.com/gotwarlost/istanbul/blob/master/ignoring-code-for-coverage.md" target="_blank" rel="noopener"><code>ignore</code>注释</a>来忽略测试环境下的一些测试分支条件</li><li>通过配置环境变量文件，不同环境下采用不同的环境变量文件</li></ol><p>第一种方法很简单，在需要忽略的地方，输入<code>/* istanbul ignore next */</code>或<code>/* istanbul ignore &lt;word&gt;[non-word] [optional-docs] */</code>等语法忽略代码。不过考虑到这是涉及到测试环境和开发环境下的环境变量问题，如果不仅仅是端口问题的话，那么就不如采用第二种方法来得更加优雅。（比如开发环境和测试环境的数据库用户和密码都不一样的话，还是需要写在对应的环境变量的）</p><p>此时我们需要另外一个很常用的库<a href="https://github.com/motdotla/dotenv" target="_blank" rel="noopener">dotenv</a>，它能默认读取<code>.env</code>文件里的值，让我们的项目可以通过不同的<code>.env</code>文件来应对不同的环境要求。</p><p>步骤如下：</p><h5 id="1-安装dotenv"><a href="#1-安装dotenv" class="headerlink" title="1. 安装dotenv"></a>1. 安装dotenv</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yarn add dotenv</span><br><span class="line"></span><br><span class="line"><span class="comment">#or</span></span><br><span class="line"></span><br><span class="line">npm install dotenv --save</span><br></pre></td></tr></table></figure><h5 id="2-在项目根目录下创建-env和-env-test两个文件，分别应用于开发环境和测试环境"><a href="#2-在项目根目录下创建-env和-env-test两个文件，分别应用于开发环境和测试环境" class="headerlink" title="2. 在项目根目录下创建.env和.env.test两个文件，分别应用于开发环境和测试环境"></a>2. 在项目根目录下创建<code>.env</code>和<code>.env.test</code>两个文件，分别应用于开发环境和测试环境</h5><p>// .env</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DB_USER=xxxx <span class="comment"># 数据库用户</span></span><br><span class="line">DB_PASSWORD=yyyy <span class="comment"># 数据库密码</span></span><br><span class="line">PORT=8889 <span class="comment"># 监听端口</span></span><br></pre></td></tr></table></figure><p>// .env.test</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DB_USER=xxxx <span class="comment"># 数据库用户</span></span><br><span class="line">DB_PASSWORD=yyyy <span class="comment"># 数据库密码</span></span><br><span class="line">PORT=8888 <span class="comment"># 监听端口</span></span><br></pre></td></tr></table></figure><h5 id="3-创建一个env-js文件，用于不同环境下采用不同的环境变量。代码如下："><a href="#3-创建一个env-js文件，用于不同环境下采用不同的环境变量。代码如下：" class="headerlink" title="3. 创建一个env.js文件，用于不同环境下采用不同的环境变量。代码如下："></a>3. 创建一个<code>env.js</code>文件，用于不同环境下采用不同的环境变量。代码如下：</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> dotenv <span class="keyword">from</span> <span class="string">'dotenv'</span></span><br><span class="line"><span class="keyword">let</span> path = process.env.NODE_ENV === <span class="string">'test'</span> ? <span class="string">'.env.test'</span> : <span class="string">'.env'</span></span><br><span class="line">dotenv.config(&#123;path, <span class="attr">silent</span>: <span class="literal">true</span>&#125;)</span><br></pre></td></tr></table></figure><h5 id="4-在app-js开头引入env"><a href="#4-在app-js开头引入env" class="headerlink" title="4. 在app.js开头引入env"></a>4. 在app.js开头引入env</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./env'</span></span><br></pre></td></tr></table></figure><p>然后把原本那句port的话改成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> port = process.env.PORT</span><br></pre></td></tr></table></figure><p>再把数据库连接的用户密码也用环境变量来代替：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server/config/db.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'../../env'</span></span><br><span class="line"><span class="keyword">import</span> Sequelize <span class="keyword">from</span> <span class="string">'sequelize'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Todolist = <span class="keyword">new</span> Sequelize(<span class="string">`mysql://<span class="subst">$&#123;process.env.DB_USER&#125;</span>:<span class="subst">$&#123;process.env.DB_PASSWORD&#125;</span>@localhost/todolist`</span>, &#123;</span><br><span class="line">  define: &#123;</span><br><span class="line">    timestamps: <span class="literal">false</span> <span class="comment">// 取消Sequelzie自动给数据表加入时间戳（createdAt以及updatedAt）</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>不过需要注意的是，.env和.env.js文件都不应该纳入git版本库，因为都是比较重要的内容。</strong></p><p>这样就能实现不同环境下用不同的变量了。慢着！这样不是还没有解决问题吗？<code>env.js</code>里的条件还是无法被测试覆盖啊——你肯定有这样的疑问。不用紧张，现在给出解决办法——给Jest指定收集测试覆盖率的范围：</p><p>修改<code>package.json</code>里<code>jest</code>字段如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">"jest": &#123;</span><br><span class="line">  "verbose": true,</span><br><span class="line">  "coverageDirectory": "coverage",</span><br><span class="line">  "mapCoverage": true,</span><br><span class="line">  "collectCoverage": true,</span><br><span class="line">  "coverageReporters": [</span><br><span class="line">    "lcov",</span><br><span class="line">    <span class="string">"text"</span></span><br><span class="line">  ],</span><br><span class="line">  "collectCoverageFrom": [ // 指定Jest收集测试覆盖率的范围</span><br><span class="line">    "!env.js", // 排除env.js</span><br><span class="line">    "server/**/*.js",</span><br><span class="line">    <span class="string">"app.js"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>做完这些工作之后，再跑一次测试，一次通过：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fld977icalj20x40lmdj2.jpg" alt=""></p><p>这样我们就完成了后端的api测试。完成了100%测试覆盖率。下面我们可以开始测试Vue的前端项目了。</p><h2 id="Vue前端测试"><a href="#Vue前端测试" class="headerlink" title="Vue前端测试"></a>Vue前端测试</h2><p>Vue的前端测试我就要推荐来自官方的<a href="https://github.com/vuejs/vue-test-utils" target="_blank" rel="noopener">vue-test-utils</a>了。当然前端测试大致分成了单元测试（Unit test)和端对端测试(e2e test)，由于端对端的测试对于测试环境的要求比较严苛，而且测试起来比较繁琐，而且官方给出的测试框架是单元测试框架，因此本文对于Vue的前端测试也仅介绍配合官方工具的单元测试。</p><p>在Vue的前端测试中我们能够了解到jest的mock、snapshot等特性和用法和vue-test-utils提供的mount、shallow、setData等一系列操作。</p><h3 id="安装vue-test-utils"><a href="#安装vue-test-utils" class="headerlink" title="安装vue-test-utils"></a>安装vue-test-utils</h3><p>根据官网的<a href="https://vue-test-utils.vuejs.org/en/guides/testing-SFCs-with-jest.html" target="_blank" rel="noopener">介绍</a>我们需要安装如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yarn add vue-test-utils vue-jest jest-serializer-vue -D</span><br><span class="line"></span><br><span class="line"><span class="comment">#or</span></span><br><span class="line"></span><br><span class="line">npm install vue-test-utils vue-jest jest-serializer-vue --save-dev</span><br></pre></td></tr></table></figure><p>其中，<code>vue-test-utils</code>是最关键的测试框架。提供了一系列对于Vue组件的测试操作。（下面会提到）。<code>vue-jest</code>用于处理<code>*.vue</code>的文件，<code>jest-serializer-vue</code>用于快照测试提供快照序列化。</p><h3 id="配置vue-test-utils以及jest"><a href="#配置vue-test-utils以及jest" class="headerlink" title="配置vue-test-utils以及jest"></a>配置vue-test-utils以及jest</h3><p><strong>1.</strong> 修改<code>.babelrc</code></p><p>在<code>test</code>的<code>env</code>里增加或修改<code>presets</code>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [</span><br><span class="line">    [<span class="string">"env"</span>, &#123; <span class="attr">"modules"</span>: <span class="literal">false</span> &#125;],</span><br><span class="line">    <span class="string">"stage-2"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"plugins"</span>: [</span><br><span class="line">    <span class="string">"transform-runtime"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"comments"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"env"</span>: &#123;</span><br><span class="line">    <span class="attr">"test"</span>: &#123;</span><br><span class="line">      <span class="attr">"plugins"</span>: [<span class="string">"transform-es2015-modules-commonjs"</span>],</span><br><span class="line">      <span class="attr">"presets"</span>: [</span><br><span class="line">        [<span class="string">"env"</span>, &#123; <span class="attr">"targets"</span>: &#123; <span class="attr">"node"</span>: <span class="string">"current"</span> &#125;&#125;] // 增加或修改</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.</strong> 修改<code>package.json</code>里的jest配置：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">"jest": &#123;</span><br><span class="line">  "verbose": true,</span><br><span class="line">  "moduleFileExtensions": [</span><br><span class="line">    <span class="string">"js"</span></span><br><span class="line">  ],</span><br><span class="line">  "transform": &#123; // 增加transform转换</span><br><span class="line">    ".*\\.(vue)$": "&lt;rootDir&gt;/node_modules/vue-jest",</span><br><span class="line">    "^.+\\.js$": "&lt;rootDir&gt;/node_modules/babel-jest"</span><br><span class="line">  &#125;,</span><br><span class="line">  "coverageDirectory": "coverage",</span><br><span class="line">  "mapCoverage": true,</span><br><span class="line">  "collectCoverage": true,</span><br><span class="line">  "coverageReporters": [</span><br><span class="line">    "lcov",</span><br><span class="line">    <span class="string">"text"</span></span><br><span class="line">  ],</span><br><span class="line">  "moduleNameMapper": &#123; // 处理webpack alias</span><br><span class="line">    "@/(.*)$": "&lt;rootDir&gt;/src/$1"</span><br><span class="line">  &#125;,</span><br><span class="line">  "snapshotSerializers": [ // 配置快照测试</span><br><span class="line">    <span class="string">"&lt;rootDir&gt;/node_modules/jest-serializer-vue"</span></span><br><span class="line">  ],</span><br><span class="line">  "collectCoverageFrom": [</span><br><span class="line">    "!env.js",</span><br><span class="line">    "server/**/*.js",</span><br><span class="line">    <span class="string">"app.js"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="前端单元测试的一些说明"><a href="#前端单元测试的一些说明" class="headerlink" title="前端单元测试的一些说明"></a>前端单元测试的一些说明</h3><p>关于vue-test-utils和Jest的配合测试，我推荐可以查看这个系列的<a href="https://alexjoverm.github.io/2017/08/21/Write-the-first-Vue-js-Component-Unit-Test-in-Jest/" target="_blank" rel="noopener">文章</a>，讲解很清晰。</p><p>接着，明确一下前端单元测试都需要测试些什么东西。引用<code>vue-test-utils</code>的说法：</p><blockquote><p>对于 UI 组件来说，我们不推荐一味追求行级覆盖率，因为它会导致我们过分关注组件的内部实现细节，从而导致琐碎的测试。</p></blockquote><blockquote><p>取而代之的是，我们推荐把测试撰写为断言你的组件的公共接口，并在一个黑盒内部处理它。一个简单的测试用例将会断言一些输入 (用户的交互或 prop 的改变) 提供给某组件之后是否导致预期结果 (渲染结果或触发自定义事件)。</p></blockquote><blockquote><p>比如，对于每次点击按钮都会将计数加一的 Counter 组件来说，其测试用例将会模拟点击并断言渲染结果会加 1。该测试并没有关注 Counter 如何递增数值，而只关注其输入和输出。</p></blockquote><blockquote><p>该提议的好处在于，即便该组件的内部实现已经随时间发生了改变，只要你的组件的公共接口始终保持一致，测试就可以通过。</p></blockquote><p>所以，相对于后端api测试看重测试覆盖率而言，前端的单元测试是不必一味追求测试覆盖率的。（当然你要想达到100%测试覆盖率也是没问题的，只不过如果要达到这样的效果你需要撰写非常多繁琐的测试用例，占用太多时间，得不偿失。）替代地，我们只需要回归测试的本源：给定输入，我只关心输出，不考虑内部如何实现。只要能覆盖到和用户相关的操作，能测试到页面的功能即可。</p><p>和之前类似，我们在<code>test/client</code>目录下书写我们的测试用例。对于Vue的单元测试来说，我们就是针对<code>*.vue</code>文件进行测试了。由于本例里的<code>app.vue</code>无实际意义，所以就测试<code>Login.vue</code>和<code>Todolist.vue</code>即可。</p><p>运用<code>vue-test-utils</code>如何来进行测试呢？简单来说，我们需要的做的就是用<code>vue-test-utils</code>提供的<code>mount</code>或者<code>shallow</code>方法将组件在后端渲染出来，然后通过一些诸如<code>setData</code>，<code>propsData</code>、<code>setMethods</code>等方法模拟用户的操作或者模拟我们的测试条件，最后再用jest提供的<code>expect</code>断言来对预期的结果进行判断。这里的预期就很丰富了。我们可以通过判断事件是否触发、元素是否存在、数据是否正确、方法是否被调用等等来对我们的组件进行比较全面的测试。下面的例子里也会比较完整地介绍它们。</p><h3 id="Login-vue的测试"><a href="#Login-vue的测试" class="headerlink" title="Login.vue的测试"></a>Login.vue的测试</h3><p>创建一个<code>login.spec.js</code>文件。</p><p>首先我们来测试页面里是否有两个输入框和一个登录按钮。根据官方文档，我首先注意到了<a href="https://vue-test-utils.vuejs.org/en/guides/common-tips.html#shallow-rendering" target="_blank" rel="noopener">shallow rendering</a>，它的说明是，对于某个组件而言，只渲染这个组件本身，而不渲染它的子组件，让测试速度提高，也符合单元测试的理念。看着好像很不错的样子，拿过来用。</p><h4 id="查找元素测试"><a href="#查找元素测试" class="headerlink" title="查找元素测试"></a>查找元素测试</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; shallow &#125; <span class="keyword">from</span> <span class="string">'vue-test-utils'</span></span><br><span class="line"><span class="keyword">import</span> Login <span class="keyword">from</span> <span class="string">'../../src/components/Login.vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> wrapper</span><br><span class="line"></span><br><span class="line">beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  wrapper = shallow(Login) <span class="comment">// 每次测试前确保我们的测试实例都是是干净完整的。返回一个wrapper对象</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'Should have two input &amp; one button'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> inputs = wrapper.findAll(<span class="string">'.el-input'</span>) <span class="comment">// 通过findAll来查找dom或者vue实例</span></span><br><span class="line">  <span class="keyword">const</span> loginButton = wrapper.find(<span class="string">'.el-button'</span>) <span class="comment">// 通过find查找元素</span></span><br><span class="line">  expect(inputs.length).toBe(<span class="number">2</span>) <span class="comment">// 应该有两个输入框</span></span><br><span class="line">  expect(loginButton).toBeTruthy() <span class="comment">// 应该有一个登录按钮。 只要断言条件不为空或这false，toBeTruthy就能通过。</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>一切看起来很正常。运行测试。结果报错了。报错是<code>input.length</code>并不等于2。通过debug断点查看，确实并没有找到元素。</p><p>这是怎么回事？哦对，我想起来，形如<code>el-input</code>、<code>el-button</code>其实也相当于是子组件啊，所以<code>shallow</code>并不能将它们渲染出来。在这种情况下，用<code>shallow</code>来渲染就不合适了。所以还是需要用<code>mount</code>来渲染，它会将页面渲染成它应该有的样子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mount &#125; <span class="keyword">from</span> <span class="string">'vue-test-utils'</span></span><br><span class="line"><span class="keyword">import</span> Login <span class="keyword">from</span> <span class="string">'../../src/components/Login.vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> wrapper</span><br><span class="line"></span><br><span class="line">beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  wrapper = mount(Login) <span class="comment">// 每次测试前确保我们的测试实例都是是干净完整的。返回一个wrapper对象</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'Should have two input &amp; one button'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> inputs = wrapper.findAll(<span class="string">'.el-input'</span>) <span class="comment">// 通过findAll来查找dom或者vue实例</span></span><br><span class="line">  <span class="keyword">const</span> loginButton = wrapper.find(<span class="string">'.el-button'</span>) <span class="comment">// 通过find查找元素</span></span><br><span class="line">  expect(inputs.length).toBe(<span class="number">2</span>) <span class="comment">// 应该有两个输入框</span></span><br><span class="line">  expect(loginButton).toBeTruthy() <span class="comment">// 应该有一个登录按钮。 只要断言条件不为空或这false，toBeTruthy就能通过。</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>测试，还是报错！还是没有找到它们。为什么呢？再想想。应该是我们并没有将<code>element-ui</code>引入我们的测试里。因为<code>.el-input</code>实际上是<code>element-ui</code>的一个组件，如果没有引入它，vue自然无法将一个<code>el-input</code>渲染成<code>&lt;div class=&quot;el-input&quot;&gt;&lt;input&gt;&lt;/div&gt;</code>这样的形式。想通了就好说了，把它引进来。因为我们的项目里在<code>webpack</code>环境下是有一个<code>main.js</code>作为入口文件的，在测试里可没有这个东西。所以Vue自然也不知道你测试里用到了什么依赖，需要我们单独引入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> elementUI <span class="keyword">from</span> <span class="string">'element-ui'</span></span><br><span class="line"><span class="keyword">import</span> &#123; mount &#125; <span class="keyword">from</span> <span class="string">'vue-test-utils'</span></span><br><span class="line"><span class="keyword">import</span> Login <span class="keyword">from</span> <span class="string">'../../src/components/Login.vue'</span></span><br><span class="line"></span><br><span class="line">Vue.use(elementUI)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>再次运行测试，通过！</p><h4 id="快照测试"><a href="#快照测试" class="headerlink" title="快照测试"></a>快照测试</h4><p>接下来，使用Jest内置的一个特别棒的特性：快照（snapshot）。它能够将某个状态下的html结构以一个快照文件的形式存储下来，以后每次运行快照测试的时候如果发现跟之前的快照测试的结果不一致，测试就无法通过。</p><p>当然如果是以后页面确实需要发生改变，快照需要更新，那么只需要在执行jest的时候增加一个<code>-u</code>的参数，就能实现快照的更新。</p><p>说完了原理来实践一下。对于登录页，实际上我们只需要确保html结构没问题那么所有必要的元素自然就存在。因此快照测试写起来特别方便：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'Should have the expected html structure'</span>, () =&gt; &#123;</span><br><span class="line">  expect(wrapper.element).toMatchSnapshot() <span class="comment">// 调用toMatchSnapshot来比对快照</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如果是第一次进行快照测试，那么它会在你的测试文件所在目录下新建一个<code>__snapshots__</code>的目录存放快照文件。上面的测试就生成了一个<code>login.spec.js.snap</code>的文件，如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">// Jest Snapshot v1, https://goo.gl/fbAQLP</span><br><span class="line"></span><br><span class="line">exports[`Should have the expected html structure 1`] = `</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">"el-row content"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"el-col el-col-24 el-col-xs-24 el-col-sm-6 el-col-sm-offset-9"</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"title"</span></span></span><br><span class="line"><span class="tag">    &gt;</span></span><br><span class="line">      </span><br><span class="line">     欢迎登录</span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">     </span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"el-row"</span></span></span><br><span class="line"><span class="tag">    &gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"el-input"</span></span></span><br><span class="line"><span class="tag">      &gt;</span></span><br><span class="line">        <span class="comment">&lt;!----&gt;</span></span><br><span class="line">        <span class="comment">&lt;!----&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">          <span class="attr">autocomplete</span>=<span class="string">"off"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">"el-input__inner"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">placeholder</span>=<span class="string">"账号"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">type</span>=<span class="string">"text"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!----&gt;</span></span><br><span class="line">        <span class="comment">&lt;!----&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">       </span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"el-input"</span></span></span><br><span class="line"><span class="tag">      &gt;</span></span><br><span class="line">        <span class="comment">&lt;!----&gt;</span></span><br><span class="line">        <span class="comment">&lt;!----&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">          <span class="attr">autocomplete</span>=<span class="string">"off"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">"el-input__inner"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">placeholder</span>=<span class="string">"密码"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">type</span>=<span class="string">"password"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!----&gt;</span></span><br><span class="line">        <span class="comment">&lt;!----&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">       </span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"el-button el-button--primary"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">type</span>=<span class="string">"button"</span></span></span><br><span class="line"><span class="tag">      &gt;</span></span><br><span class="line">        <span class="comment">&lt;!----&gt;</span></span><br><span class="line">        <span class="comment">&lt;!----&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">          登录</span><br><span class="line">        <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">`;</span><br></pre></td></tr></table></figure><p>可以看到它将整个html结构以快照的形式保存下来了。快照测试能确保我们的前端页面结构的完整性和稳定性。</p><h4 id="methods测试"><a href="#methods测试" class="headerlink" title="methods测试"></a>methods测试</h4><p>很多时候我们需要测试在某些情况下，Vue中的一些methods能否被触发。比如本例里的，我们点击登录按钮应对要触发<code>loginToDo</code>这个方法。于是就涉及到了<code>methods</code>的测试，这个时候<code>vue-test-utils</code>提供的<code>setMethods</code>这个方法就很有用了。我们可以通过设置（覆盖）<code>loginToDo</code>这个方法，来查看它是否被触发了。</p><blockquote><p>注意，一旦setMethods了某个方法，那么在某个test()内部，这个方法原本的作用将完全被你的新function覆盖。包括这个Vue实例里其他methods通过<code>this.xxx()</code>方式调用也一样。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'loginToDo should be called after clicking the button'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> stub = jest.fn() <span class="comment">// 伪造一个jest的mock funciton</span></span><br><span class="line">  wrapper.setMethods(&#123; <span class="attr">loginToDo</span>: stub &#125;) <span class="comment">// setMethods将loginToDo这个方法覆写</span></span><br><span class="line">  wrapper.find(<span class="string">'.el-button'</span>).trigger(<span class="string">'click'</span>) <span class="comment">// 对button触发一个click事件</span></span><br><span class="line">  expect(stub).toBeCalled() <span class="comment">// 查看loginToDo是否被调用</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>注意到这里我们用到了<code>jest.fn</code>这个方法，这个在下节会详细说明。此处你只需要明白这个是jest提供的，可以用来检测是否被调用的方法。</p><h4 id="mock方法测试"><a href="#mock方法测试" class="headerlink" title="mock方法测试"></a>mock方法测试</h4><p>接下去就是对登录这个功能的测试了。由于我们之前把Koa的后端api进行了测试，所以我们在前端测试中，可以默认后端的api接口都是返回正确的结果的。（这也是我们先进行了Koa端测试的原因，保证了后端api的健壮性回到前端测试的时候就能很轻松）</p><p>虽然道理是说得通的，但是我们如何来默认、或者说“伪造”我们的api请求，以及返回的数据呢？这个时候就需要用上Jest一个非常有用的功能<code>mock</code>了。可以说<code>mock</code>这个词对很多做前端的朋友来说，不是很陌生。在没有后端，或者后端功能还未完成的时候，我们可以通过api的mock来实现伪造请求和数据。</p><p>Jest的mock也是同理，不过它更厉害的一点是，它能伪造库。比如我们接下去要用的HTTP请求库<code>axios</code>。对于我们的页面来说，登录只需要发送post请求，判断返回的<code>success</code>是否是<code>true</code>即可。我们先来mock一下<code>axios</code>以及它的<code>post</code>请求。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">jest.mock(<span class="string">'axios'</span>, () =&gt; (&#123;</span><br><span class="line">  post: jest.fn(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Promise</span>.resolve(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">      success: <span class="literal">false</span>,</span><br><span class="line">      info: <span class="string">'用户不存在！'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;))</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><p>然后我们可以把axios引入我们的项目了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> elementUI <span class="keyword">from</span> <span class="string">'element-ui'</span></span><br><span class="line"><span class="keyword">import</span> &#123; mount &#125; <span class="keyword">from</span> <span class="string">'vue-test-utils'</span></span><br><span class="line"><span class="keyword">import</span> Login <span class="keyword">from</span> <span class="string">'../../src/components/Login.vue'</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"></span><br><span class="line">Vue.use(elementUI)</span><br><span class="line"></span><br><span class="line">Vue.prototype.$http = axios</span><br><span class="line"></span><br><span class="line">jest.mock(....)</span><br></pre></td></tr></table></figure><p>等会，你肯定会提出疑问，<code>jest.mock()</code>方法写在了<code>import axios from &#39;axios&#39;</code>下面，那么不就意味着<code>axios</code>是从<code>node_modules</code>里引入的吗？其实不是的，<code>jest.mock()</code>会实现函数提升，也就是实际上上面的代码其实和下面的是一样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">jest.mock(....)</span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> elementUI <span class="keyword">from</span> <span class="string">'element-ui'</span></span><br><span class="line"><span class="keyword">import</span> &#123; mount &#125; <span class="keyword">from</span> <span class="string">'vue-test-utils'</span></span><br><span class="line"><span class="keyword">import</span> Login <span class="keyword">from</span> <span class="string">'../../src/components/Login.vue'</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span> <span class="comment">// 这里的axios是来自jest.mock()里的axios</span></span><br><span class="line"></span><br><span class="line">Vue.use(elementUI)</span><br><span class="line"></span><br><span class="line">Vue.prototype.$http = axios</span><br></pre></td></tr></table></figure><p>看起来甚至有些<code>var</code>的变量提升的味道。</p><p>不过这样的好处是很明显的，我们可以在不破坏<code>eslint</code>的规则的情况下采用第一种的写法而达到一样的目的。</p><p>然后你还会注意到我们用到了<code>jest.fn()</code>的方法，它是jest的mock方法里很重要的一部分。它本身是一个<code>mock function</code>。通过它能够实现方法调用的追踪以及后面会说到的能够实现创建复杂行为的模拟功能。</p><p>继续我们没写完的测试：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'Failed to login if not typing the correct password'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  wrapper.setData(&#123;</span><br><span class="line">    account: <span class="string">'molunerfinn'</span>,</span><br><span class="line">    password: <span class="string">'1234'</span></span><br><span class="line">  &#125;) <span class="comment">// 模拟用户输入数据</span></span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> wrapper.vm.loginToDo() <span class="comment">// 模拟异步请求的效果</span></span><br><span class="line">  expect(result.data.success).toBe(<span class="literal">false</span>) <span class="comment">// 期望返回的数据里success是false</span></span><br><span class="line">  expect(result.data.info).toBe(<span class="string">'密码错误！'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们通过<code>setData</code>来模拟用户在两个input框内输入了数据。然后通过<code>wrapper.vm.loginToDo()</code>来显式调用<code>loginTodo</code>的方法。由于我们返回的是一个<code>Promise</code>对象，所以可以用<code>async await</code>将resolve里的数据拿出来。然后测试是否和预期相符。我们这次是测试了输入错误的情况，测试通过，没有问题。那如果我接下去要再测试用户密码都通过的测试怎么办？我们<code>mock</code>的<code>axios</code>的<code>post</code>方法只有一个，难不成还能一个方法输出多种结果？下一节来详细说明这个问题。</p><h4 id="创建复杂行为测试"><a href="#创建复杂行为测试" class="headerlink" title="创建复杂行为测试"></a>创建复杂行为测试</h4><p>回顾一下我们的mock写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">jest.mock(<span class="string">'axios'</span>, () =&gt; (&#123;</span><br><span class="line">  post: jest.fn(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Promise</span>.resolve(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">      success: <span class="literal">false</span>,</span><br><span class="line">      info: <span class="string">'用户不存在！'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;))</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><p>可以看到，采用这种写法的话，post请求始终只能返回一种结果。如何做到既能<code>mock</code>这个<code>post</code>方法又能实现多种结果测试？接下去就要用到Jest另一个杀手锏的方法：<a href="https://facebook.github.io/jest/docs/en/mock-functions.html#mock-implementations" target="_blank" rel="noopener">mockImplementationOnce</a>。官方的示例如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myMockFn = jest.fn(<span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'default'</span>)</span><br><span class="line">  .mockImplementationOnce(<span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'first call'</span>)</span><br><span class="line">  .mockImplementationOnce(<span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'second call'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myMockFn(), myMockFn(), myMockFn(), myMockFn());</span><br><span class="line"><span class="comment">// &gt; 'first call', 'second call', 'default', 'default'</span></span><br></pre></td></tr></table></figure><p>4次调用同一个方法却能给出不同的运行结果。这正是我们想要的。</p><p>于是在我们测试登录成功这个方法的时候我们需要改写一下我们对<code>axios</code>的mock方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">jest.mock(<span class="string">'axios'</span>, () =&gt; (&#123;</span><br><span class="line">  post: jest.fn()</span><br><span class="line">        .mockImplementationOnce(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Promise</span>.resolve(&#123;</span><br><span class="line">          data: &#123;</span><br><span class="line">            success: <span class="literal">false</span>,</span><br><span class="line">            info: <span class="string">'用户不存在！'</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;))</span><br><span class="line">        .mockImplementationOnce(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Promise</span>.resolve(&#123;</span><br><span class="line">          data: &#123;</span><br><span class="line">            success: <span class="literal">true</span>,</span><br><span class="line">            token: <span class="string">'xxx'</span> <span class="comment">// 随意返回一个token</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;))</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><p>然后开始写我们的测试：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'Succeeded to login if typing the correct account &amp; password'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  wrapper.setData(&#123;</span><br><span class="line">    account: <span class="string">'molunerfinn'</span>,</span><br><span class="line">    password: <span class="string">'123'</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> wrapper.vm.loginToDo()</span><br><span class="line">  expect(result.data.success).toBe(<span class="literal">true</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>就在我认为跟之前的测试没有什么两样的时候，报错传来了。先来看看当<code>success</code>为true的时候，<code>loginToDo</code>在做什么：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (res.data.success) &#123; <span class="comment">// 如果成功</span></span><br><span class="line">  sessionStorage.setItem(<span class="string">'demo-token'</span>, res.data.token) <span class="comment">// 用sessionStorage把token存下来</span></span><br><span class="line">  <span class="keyword">this</span>.$message(&#123; <span class="comment">// 登录成功，显示提示语</span></span><br><span class="line">    type: <span class="string">'success'</span>,</span><br><span class="line">    message: <span class="string">'登录成功！'</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">this</span>.$router.push(<span class="string">'/todolist'</span>) <span class="comment">// 进入todolist页面，登录成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很快我就看到了错误所在：我们的测试环境里并没有<code>sessionStorage</code>这个原本应该在浏览器端的东西。以及我们并没有使用<code>vue-router</code>，所以就无法执行<code>this.$router.push()</code>这个方法。</p><p>关于前者，很容易找到<a href="https://stackoverflow.com/questions/30792076/mocking-sessionstorage-when-using-jestjs" target="_blank" rel="noopener">问题</a>的<a href="https://github.com/letsrock-today/mock-local-storage" target="_blank" rel="noopener">解决办法</a>。</p><p>首先安装一下<code>mock-local-storage</code>这个库（也包括了sessionStorage）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yarn add mock-local-storage -D</span><br><span class="line"></span><br><span class="line"><span class="comment">#or</span></span><br><span class="line"></span><br><span class="line">npm install mock-local-storage --save-dev</span><br></pre></td></tr></table></figure><p>然后配置一下<code>package.json</code>里的<code>jest</code>参数：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">"jest": &#123;</span><br><span class="line">  // ...</span><br><span class="line">  "setupTestFrameworkScriptFile": "mock-local-storage"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于后者，阅读过官方的<a href="https://vue-test-utils.vuejs.org/en/guides/common-tips.html#dealing-with-routing" target="_blank" rel="noopener">建议</a>，我们不应该引入<code>vue-router</code>，这样会破坏我们的单元测试。相应的，我们可以mock它。不过这次是用<code>vue-test-utils</code>自带的<code>mocks</code>特性了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> $router = &#123; <span class="comment">// 声明一个$router对象</span></span><br><span class="line">  push: jest.fn()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  wrapper = mount(Login, &#123;</span><br><span class="line">    mocks: &#123;</span><br><span class="line">      $router <span class="comment">// 在beforeEach钩子里挂载进mount的mocks里。</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>通过这个方式，会把<code>$router</code>这个对象挂载到实例的<code>prototype</code>上，就能实现在组件内部通过<code>this.$router.push()</code>的方式来调用了。</p><p>上述两个问题解决之后，我们的测试也顺利通过了：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1flj15nzsg0j215c06aq4c.jpg" alt=""></p><p>接下去开始测试<code>Todolist.vue</code>这个组件了。</p><h3 id="Todolist-vue的测试"><a href="#Todolist-vue的测试" class="headerlink" title="Todolist.vue的测试"></a>Todolist.vue的测试</h3><h4 id="键盘事件测试以及隐式事件触发"><a href="#键盘事件测试以及隐式事件触发" class="headerlink" title="键盘事件测试以及隐式事件触发"></a>键盘事件测试以及隐式事件触发</h4><p>类似的我们在<code>test/client</code>目录下创建一个叫做<code>todolist.spec.js</code>的文件。</p><p>先把上例中的一些环境先预置进来：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> elementUI <span class="keyword">from</span> <span class="string">'element-ui'</span></span><br><span class="line"><span class="keyword">import</span> &#123; mount &#125; <span class="keyword">from</span> <span class="string">'vue-test-utils'</span></span><br><span class="line"><span class="keyword">import</span> Todolist <span class="keyword">from</span> <span class="string">'../../src/components/Todolist.vue'</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"></span><br><span class="line">Vue.use(elementUI)</span><br><span class="line"></span><br><span class="line">jest.mock(...) <span class="comment">// 后续补充</span></span><br><span class="line"></span><br><span class="line">Vue.prototype.$http = axios</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> wrapper</span><br><span class="line"></span><br><span class="line">beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  wrapper = mount(Todolist)</span><br><span class="line">  wrapper.setData(&#123;</span><br><span class="line">    name: <span class="string">'Molunerfinn'</span>, <span class="comment">// 预置数据</span></span><br><span class="line">    id: <span class="number">2</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>先来个简单的，测试数据是否正确：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test 1</span></span><br><span class="line">test(<span class="string">'Should get the right username &amp; id'</span>, () =&gt; &#123;</span><br><span class="line">  expect(wrapper.vm.name).toBe(<span class="string">'Molunerfinn'</span>)</span><br><span class="line">  expect(wrapper.vm.id).toBe(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>不过需要注意的是，<code>todolist</code>这个页面在<code>created</code>阶段就会触发<code>getUserInfo</code>和<code>getTodolist</code>这两个方法，而我们的wrapper是相当于在<code>mounted</code>阶段之后的。所以在我们拿到wrapper的时候，<code>created</code>、<code>mounted</code>等生命周期的钩子其实已经运行了。本例里<code>getUserInfo</code>是从<code>sessionStorage</code>里取值，不涉及ajax请求。但是<code>getTodolist</code>涉及请求，因此需要在jest.mock方法里为其配置一下，否则将会报错：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">jest.mock(<span class="string">'axios'</span>, () =&gt; (&#123;</span><br><span class="line">  get: jest.fn()</span><br><span class="line">        <span class="comment">// for test 1</span></span><br><span class="line">        .mockImplementationOnce(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Promise</span>.resolve(&#123;</span><br><span class="line">          status: <span class="number">200</span>,</span><br><span class="line">          data: &#123;</span><br><span class="line">            result: []</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;))</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><p>上面说到的<code>getTodolist</code>和<code>getUserInfo</code>就是在测试中需要注意的隐式事件，它们并不受你测试的控制就在组件里触发了。</p><p>接下来开始进行键盘事件测试。其实跟鼠标事件类似，键盘事件的触发也是以事件名来命名的。不过对于一些常见的事件，<code>vue-test-utils</code>里给出了一些别名比如：</p><p><code>enter, tab, delete, esc, space, up, down, left, right</code>。你在书写测试的时候可以直接这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> input = wrapper.find(<span class="string">'.el-input'</span>)</span><br><span class="line">input.trigger(<span class="string">'keyup.enter'</span>)</span><br></pre></td></tr></table></figure><p>当然如果你需要指定某个键也是可以的，只需要提供keyCode就行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> input = wrapper.find(<span class="string">'.el-input'</span>)</span><br><span class="line">input.trigger(<span class="string">'keyup'</span>， &#123;</span><br><span class="line">  which: <span class="number">13</span> <span class="comment">// enter的keyCode为13</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>于是我们把这个测试完善一下，这个测试是测试当我在输入框激活的情况下按下回车键能否触发<code>addTodos</code>这个事件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'Should trigger addTodos when typing the enter key'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> stub = jest.fn()</span><br><span class="line">  wrapper.setMethods(&#123;</span><br><span class="line">    addTodos: stub</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> input = wrapper.find(<span class="string">'.el-input'</span>)</span><br><span class="line">  input.trigger(<span class="string">'keyup.enter'</span>)</span><br><span class="line">  expect(stub).toBeCalled()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>没有问题，一次通过。</p><p>注意到我们在实际开发时，在组件上调用原生事件是需要加<code>.native</code>修饰符的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-input</span> <span class="attr">placeholder</span>=<span class="string">"请输入待办事项"</span> <span class="attr">v-model</span>=<span class="string">"todos"</span> @<span class="attr">keyup.enter.native</span>=<span class="string">"addTodos"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-input</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是在<code>vue-test-utils</code>里你是可以直接通过原生的<code>keyup.enger</code>来触发的。</p><h4 id="wrapper-update-的使用"><a href="#wrapper-update-的使用" class="headerlink" title="wrapper.update()的使用"></a>wrapper.update()的使用</h4><p>很多时候我们要跟异步打交道。尤其是异步取值，异步赋值，页面异步更新。而对于使用Vue来做的实际开发来说，异步的情况简直太多了。</p><p>还记得<code>nextTick</code>么？很多时候，我们要获取一个变更的数据结果，不能直接通过<code>this.xxx</code>获取，相应的我们需要在<code>this.$nextTick()</code>里获取。在测试里我们也会遇到很多需要异步获取的情况，但是我们不需要<code>nextTick</code>这个办法，相应的我们可以通过<code>async await</code>配合<code>wrapper.update()</code>来实现组件更新。例如下面这个测试添加todo成功的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'Should add a todo if handle in the right way'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  wrapper.setData(&#123;</span><br><span class="line">    todos: <span class="string">'Test'</span>,</span><br><span class="line">    stauts: <span class="string">'0'</span>,</span><br><span class="line">    id: <span class="number">1</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> wrapper.vm.addTodos()</span><br><span class="line">  <span class="keyword">await</span> wrapper.update()</span><br><span class="line">  expect(wrapper.vm.list).toEqual([</span><br><span class="line">    &#123;</span><br><span class="line">      status: <span class="string">'0'</span>,</span><br><span class="line">      content: <span class="string">'Test'</span>,</span><br><span class="line">      id: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  ])</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在本例中，从进页面到添加一个todo并显示出来需要如下步骤：</p><ol><li>getUserInfo -&gt; getTodolist</li><li>输入todo并敲击回车</li><li>addTodos -&gt; getTodolist</li><li>显示添加的todo</li></ol><p>可以看到总共有3个ajax请求。其中第一步不在我们test()的范围内，2、3、4都是我们能控制的。而addTodos和getTodolist这两个ajax请求带来的就是异步的操作。虽然我们mock方法，但是本质上是返回了Promise对象。所以还是需要用<code>await</code>来等待。</p><blockquote><p>注意你在jest.mock()里要加上相应的mockImplementationOnce的get和post请求。</p></blockquote><p>所以第一步<code>await wrapper.vm.addTodos()</code>就是等待<code>addTodos()</code>的返回。<br>第二步<code>await wrapper.update()</code>实际是在等待<code>getTodolist</code>的返回。</p><p>缺一不可。两步等待之后我们就可以通过断言数据<code>list</code>的方式测试我们是否拿到了返回的todo的信息。</p><p>接下去的就是对todo的一些增删改查的操作，采用的测试方法已经和前文所述相差无几，不再赘述。至此所有的独立测试用例的说明就说完了。看看这测试通过的成就感：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1flj2hpjeprj213606udhc.jpg" alt=""></p><p>不过在测试中我还有关于调试的一些经验想分享一下，配合调试能更好的判断我们的测试的时候发生的不可预知的问题所在。</p><h3 id="用VSCode来调试测试"><a href="#用VSCode来调试测试" class="headerlink" title="用VSCode来调试测试"></a>用VSCode来调试测试</h3><p>由于我自己是使用VSCode来做的开发和调试，所以一些用其他IDE或者编辑器的朋友们可能会有所失望。不过没关系，可以考虑加入VSCode阵营嘛！</p><p>本文撰写的时候采用的nodejs版本为<code>8.9.0</code>，VSCode版本为<code>1.18.0</code>，所以所有的debug测试的配置仅保证适用于目前的环境。其他环境的可能需要自行测试一下，不再多说。</p><p>关于jest的调试的配置如下：（注意配置路径为VScode关于本项目的<code>.vscode/launch.json</code>）</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // Use IntelliSense to learn about possible Node.js debug attributes.</span><br><span class="line">  // Hover to view descriptions of existing attributes.</span><br><span class="line">  // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387</span><br><span class="line">  "version": "0.2.0",</span><br><span class="line">  "configurations": [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"Debug Jest"</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"node"</span>,</span><br><span class="line">      <span class="attr">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">      <span class="attr">"program"</span>: <span class="string">"$&#123;workspaceRoot&#125;/node_modules/jest-cli/bin/jest.js"</span>,</span><br><span class="line">      <span class="attr">"stopOnEntry"</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">"args"</span>: [</span><br><span class="line">        <span class="string">"--runInBand"</span>,</span><br><span class="line">        <span class="string">"--forceExit"</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"cwd"</span>: <span class="string">"$&#123;workspaceRoot&#125;"</span>,</span><br><span class="line">      <span class="attr">"preLaunchTask"</span>: <span class="literal">null</span>,</span><br><span class="line">      <span class="attr">"runtimeExecutable"</span>: <span class="literal">null</span>,</span><br><span class="line">      <span class="attr">"runtimeArgs"</span>: [</span><br><span class="line">        <span class="string">"--nolazy"</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"env"</span>: &#123;</span><br><span class="line">        <span class="attr">"NODE_ENV"</span>: <span class="string">"test"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"console"</span>: <span class="string">"integratedTerminal"</span>,</span><br><span class="line">      <span class="attr">"sourceMaps"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置完上面的配置之后，你可以在<code>DEBUG</code>面板里（不要跟我说你不知道什么是DEBUG面板~）找到名为<code>Debug Jest</code>的选项：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1flj2s0qhxkj20og09kq3p.jpg" alt=""></p><p>然后你可以在你的测试文件里打断点了：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1flj2uakvi4j21bk09oq5s.jpg" alt=""></p><p>然后运行debug模式，按那个绿色启动按钮，就能进入DEBUG模式，当运行到断点处就会停下：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1flj2y2hpeaj21fa09u41u.jpg" alt=""></p><p>于是你可以在左侧面板的<code>Local</code>和<code>Closure</code>里找到当前作用域下你所需要的变量值、变量类型等等。充分运用VSCode的debug模式，开发的时候查错和调试的效率都会大大加大。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文用了很大的篇幅描述了如何搭建一个Jest测试环境，并在测试过程中不断完善我们的测试环境。讲述了Koa后端测试的方法和测试覆盖率的提高，讲述了Vue前端单元测试环境的搭建以及许多相应的测试实例，以及在测试过程中不停地遇到问题并解决问题。能够看到此处的都不是一般有耐心的人，为你们鼓掌~也希望你们通过这篇文章能过对本文在开头提出的几个重点在心中有所体会和感悟：</p><blockquote><p>可以了解到测试的意义，<a href="https://facebook.github.io/jest/" target="_blank" rel="noopener">Jest</a>测试框架的搭建，前后端测试的异同点，如何写测试用例，如何查看测试结果并提升我们的测试覆盖率，100%测试覆盖率是否是必须，以及在搭建测试环境、以及测试本身过程中遇到的各种疑难杂症。</p></blockquote><p>本文所有的测试用例以及整体项目实例你都可以在我的<a href="https://github.com/Molunerfinn/vue-koa-demo" target="_blank" rel="noopener">vue-koa-demo</a>的github项目中找到源代码。如果你喜欢我的文章以及项目，欢迎点个star~如果你对我的文章和项目有任何建议或者意见，欢迎在文末评论或者在本项目的<a href="https://github.com/Molunerfinn/vue-koa-demo/issues" target="_blank" rel="noopener">issues</a>跟我探讨！</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><blockquote><p>Koa相关</p></blockquote><p><a href="https://segmentfault.com/q/1010000006906863" target="_blank" rel="noopener">Supertest搭配koa报错</a></p><p><a href="http://facebook.github.io/jest/docs/en/cli.html#forceexit" target="_blank" rel="noopener">测试完自动退出</a></p><p><a href="https://hackernoon.com/async-testing-koa-with-jest-1b6e84521b71" target="_blank" rel="noopener">Async testing Koa with Jest</a></p><p><a href="http://www.albertgao.xyz/2017/06/10/how-to-use-jest-to-test-express-middleware-or-a-function-which-consumes-a-callback/" target="_blank" rel="noopener">How to use Jest to test Express middleware or a funciton which consumes a callback?</a></p><p><a href="https://www.valentinog.com/blog/testing-api-koa-jest/" target="_blank" rel="noopener">A clear and concise introduction to testing Koa with Jest and Supertest</a></p><p><a href="https://github.com/Microsoft/vscode/issues/28007" target="_blank" rel="noopener">Debug jest with vscode</a></p><p><a href="https://stackoverflow.com/questions/12236890/run-mocha-tests-in-test-environment" target="_blank" rel="noopener">Test port question</a><br><a href="https://github.com/facebook/jest/issues/4777" target="_blank" rel="noopener">Coverage bug</a></p><p><a href="https://stackoverflow.com/questions/41733634/eaddrinuse-127-0-0-15858-during-jest-test-debugging" target="_blank" rel="noopener">Eaddrinuse bug</a></p><p><a href="https://github.com/gotwarlost/istanbul/blob/master/ignoring-code-for-coverage.md" target="_blank" rel="noopener">Istanbul ignore</a></p><blockquote><p>Vue相关</p></blockquote><p><a href="https://vue-test-utils.vuejs.org/en/" target="_blank" rel="noopener">vue-test-utils</a></p><p><a href="https://alexjoverm.github.io/2017/09/25/Test-Methods-and-Mock-Dependencies-in-Vue-js-with-Jest/" target="_blank" rel="noopener">Test Methods and Mock Dependencies in Vue.js with Jest</a></p><p><a href="https://stackoverflow.com/questions/30792076/mocking-sessionstorage-when-using-jestjs" target="_blank" rel="noopener">Storage problem</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;今年一月份的时候我写了一个&lt;a href=&quot;https://github.com/Molunerfinn/vue-koa-demo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Vue+Koa的全栈应用&lt;/a&gt;，以及相应的&lt;a href=&quot;https://molunerfinn.com/Vue+Koa/&quot;&gt;配套教程&lt;/a&gt;，得到了很多的好评。同时我也在和读者交流的过程中不断认识到不足和缺点，于是也对此进行了不断的更新和完善。本次带来的完善是加入和完整的前后端测试。相信对于很多学习前端的朋友来说，&lt;code&gt;测试&lt;/code&gt;这个东西似乎是个熟悉的陌生人。你听过，但是你未必做过。如果你对前端（以及nodejs端）测试很熟悉，那么本文的帮助可能不大，不过我很希望能得到你们提出的宝贵意见！&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="https://molunerfinn.com/categories/Web/"/>
    
      <category term="开发" scheme="https://molunerfinn.com/categories/Web/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Nodejs" scheme="https://molunerfinn.com/categories/Web/%E5%BC%80%E5%8F%91/Nodejs/"/>
    
    
      <category term="前端" scheme="https://molunerfinn.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Nodejs" scheme="https://molunerfinn.com/tags/Nodejs/"/>
    
  </entry>
  
  <entry>
    <title>把你的github操作从ssh转成https</title>
    <link href="https://molunerfinn.com/git-ssh2https/"/>
    <id>https://molunerfinn.com/git-ssh2https/</id>
    <published>2017-10-26T21:44:00.000Z</published>
    <updated>2018-04-27T08:26:51.717Z</updated>
    
    <content type="html"><![CDATA[<p>从10月24日开始，由于总所周知的原因，某些地区一些运营商的网络环境下已经无法通过ssh的方式对一些国外服务器进行操作。很不幸github也因此被误杀。这对于广大程序猿来说，简直是一大噩耗。不过我发现通过https的方式还是可以对github进行操作的。毕竟技术是无罪的，不管怎么样，github总是要用的。所以可以将现有的ssh方式改成https。</p><a id="more"></a><h2 id="从ssh到https"><a href="#从ssh到https" class="headerlink" title="从ssh到https"></a>从ssh到https</h2><p>把原有项目从ssh的方式转成https其实很简单：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote <span class="built_in">set</span>-url origin https://xxxxx <span class="comment">#your https repo url</span></span><br></pre></td></tr></table></figure><p>通过如下命令查看是否更改成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  https://github.com/xxx/xxx.github.io.git (fetch)</span><br><span class="line">origin  https://github.com/xxx/xxx.github.io.git (push)</span><br></pre></td></tr></table></figure><p>不过转成https之后会带来一个问题，那就是每次提交的时候都需要输入github的用户名密码。其实当初用ssh的方式除了安全之外很重要的一个原因就是不用每次都手动输入账号密码。不过其实https的方式也是可以实现的，只是需要一些额外配置。</p><h2 id="配置https免输入密码"><a href="#配置https免输入密码" class="headerlink" title="配置https免输入密码"></a>配置https免输入密码</h2><p>git官方手册里有对于<a href="https://git-scm.com/docs/git-credential-store" target="_blank" rel="noopener">git-credential-store</a>的描述。简单来说，就是将用户名和密码缓存在本地，每次提交的时候自动帮你填入用户名密码。</p><blockquote><p>注意git版本需要在1.7以上</p></blockquote><p>开启也很简单：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global credential.helper store</span><br></pre></td></tr></table></figure><p>然后你对某个仓库第一次执行push操作的时候，会要求输入用户密码，之后就再也不用了：</p><blockquote><p>官方示例</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git config credential.helper store</span><br><span class="line">$ git push http://example.com/repo.git</span><br><span class="line">Username: &lt;<span class="built_in">type</span> your username&gt;</span><br><span class="line">Password: &lt;<span class="built_in">type</span> your password&gt;</span><br><span class="line"></span><br><span class="line">[several days later]</span><br><span class="line">$ git push http://example.com/repo.git</span><br><span class="line">[your credentials are used automatically]</span><br></pre></td></tr></table></figure><p>通过store的方式会将你的账号密码以明文的形式存在<code>~/.git-credentials</code>文件里，大致长这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat ~/.git-credentials</span><br><span class="line">https://username:password@github.com</span><br></pre></td></tr></table></figure><p>如果你觉得这样不太安全，见下一章：</p><h2 id="提高安全性"><a href="#提高安全性" class="headerlink" title="提高安全性"></a>提高安全性</h2><h3 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h3><p>对于mac而言，可以将git默认的<code>credential.helper</code>指定成<code>osxkeychain</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global credential.helper osxkeychain</span><br></pre></td></tr></table></figure><p>然后可以通过</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config credential.helper</span><br><span class="line">osxkeychain</span><br></pre></td></tr></table></figure><p>来查看是否指定成功了。之后用户名密码将会保存在系统自带的<code>keychain access</code>里。</p><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>使用微软开发的<a href="https://github.com/Microsoft/Git-Credential-Manager-for-Windows" target="_blank" rel="noopener">Git-Credential-Manager-for-Windows</a></p><p>最新版下载地址：<a href="https://github.com/Microsoft/Git-Credential-Manager-for-Windows/releases/latest" target="_blank" rel="noopener">https://github.com/Microsoft/Git-Credential-Manager-for-Windows/releases/latest</a></p><p>安装之后，在控制台里输入：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global credential.helper manager</span><br></pre></td></tr></table></figure><p>之后还是一样的，某个项目里输入用户名密码之后，以后就再也不用输入了。你可以在<code>管理网络密码</code>里找到你的用户密码——其实不是密码，而是token了，因为<code>Git-Credential-Manager-for-Windows</code>它会自动调用github的api生成<code>Personal access tokens</code>，你可以在你的github的<code>Personal settings</code>里找到它。所以安全性还是有保障的！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果你已经无法用ssh的方式连接github的话，不妨试试https的方式。至少目前来说还是有效的，而且配置也不难~Happy coding again！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从10月24日开始，由于总所周知的原因，某些地区一些运营商的网络环境下已经无法通过ssh的方式对一些国外服务器进行操作。很不幸github也因此被误杀。这对于广大程序猿来说，简直是一大噩耗。不过我发现通过https的方式还是可以对github进行操作的。毕竟技术是无罪的，不管怎么样，github总是要用的。所以可以将现有的ssh方式改成https。&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="https://molunerfinn.com/categories/Web/"/>
    
      <category term="开发" scheme="https://molunerfinn.com/categories/Web/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="git" scheme="https://molunerfinn.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Hexo主题开发经验杂谈</title>
    <link href="https://molunerfinn.com/make-a-hexo-theme/"/>
    <id>https://molunerfinn.com/make-a-hexo-theme/</id>
    <published>2017-09-14T22:46:00.000Z</published>
    <updated>2018-04-27T08:26:51.717Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前学前端的初衷就是为了让自己的个人博客好看点。Hexo主题如今很大概率你能够看到<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">Next</a>主题以及它的一些个人修改、衍生版本。我记得去年在看一篇<a href="http://chensd.com/2016-06/hexo-theme-guide.html" target="_blank" rel="noopener">Hexo主题开发指南</a>的时候，有句话对我感触很深：</p><blockquote><p>当你看到你用的主题出现在两个以上的博客的时候，那你就要考虑自己写一个了。</p></blockquote><p>懒癌晚期的自己以及毕业设计等等事情的拖延，终于在最近完成了自己的Hexo主题——<a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener">Melody</a>。</p><p>本文将讲述如何制作一个<code>Hexo</code>主题，以及在制作过程中的一些坑和一些经验。</p><p><strong>在我主题制作过程中，Next主题以及其他一些优秀的前端博客例如<a href="https://huangxuan.me/" target="_blank" rel="noopener">Hux</a>，对我帮助和启发很大，再次感谢</strong></p><a id="more"></a><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><h3 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h3><p>Hexo的博客的页面都是通过模板引擎渲染的静态页面。当然如果你不想用模板引擎，用html也是可以的。但是这样做的话会很不方便，因为其实很多代码是可以复用的，用模板引擎的话可以比较方便地帮我们实现代码的复用。</p><p>我是<a href="https://pugjs.org/api/getting-started.html" target="_blank" rel="noopener">Pug</a>模板引擎的忠实粉丝，所以<code>melody</code>主题我用的是<code>Pug</code>。所以你可能需要了解和学习pug模板引擎的语法和入门使用。</p><h3 id="CSS预处理"><a href="#CSS预处理" class="headerlink" title="CSS预处理"></a>CSS预处理</h3><p>跟模板引擎一样，CSS预处理能够更方便地写CSS，复用代码、函数等功能是十分方便的。我是<a href="http://stylus-lang.com/" target="_blank" rel="noopener">Stylus</a>的忠实粉丝，所以<code>melody</code>主题我用的是<code>Stylus</code>。所以你可能需要学习stylus的语法和入门使用。</p><h3 id="Hexo的变量以及辅助函数"><a href="#Hexo的变量以及辅助函数" class="headerlink" title="Hexo的变量以及辅助函数"></a>Hexo的变量以及辅助函数</h3><p>Hexo的官方文档是出了名的烂。不过有两个用得比较多的部分，一个是Hexo会植入模板引擎的<a href="https://hexo.io/docs/variables.html" target="_blank" rel="noopener">变量</a>，以及在很多地方都用得到的<a href="https://hexo.io/docs/helpers.html" target="_blank" rel="noopener">辅助函数</a>。这些通常是用来进行配置不同页面显示不同的内容。</p><h2 id="搭建主题脚手架"><a href="#搭建主题脚手架" class="headerlink" title="搭建主题脚手架"></a>搭建主题脚手架</h2><h3 id="页面"><a href="#页面" class="headerlink" title="页面"></a>页面</h3><p>通常来说一个Hexo主题需要包括如下几个页面：</p><ol><li>首页 <code>Home</code></li><li>归档页 <code>Archive</code></li><li>标签页 <code>Tag</code></li><li>分类页 <code>Category</code></li><li>文章页 <code>Post</code></li><li>页面详情页 <code>Page</code></li></ol><p>这些页面文件都要放到<code>layout</code>目录里。构建的时候将会读取里面的内容进行编译。</p><h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><p>像<code>CSS</code>，<code>JS</code>，<code>IMG</code>这些都可以算作是资源文件，构建的时候作为引用的资源。这些都放到<code>source</code>目录里。</p><h3 id="搭建书写主题的舒适环境"><a href="#搭建书写主题的舒适环境" class="headerlink" title="搭建书写主题的舒适环境"></a>搭建书写主题的舒适环境</h3><p>首先需要搭建一个Hexo的博客环境。去<a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a>的官网，按提示安装<code>hexo-cli</code>，然后在本地创建一个Hexo博客的目录。它会预先置入一个默认主题<code>landspace</code>以及一篇默认的<code>hello world</code>文章。当然我们不是在<code>landspace</code>上修改，我们需要自己撰写。</p><p>主题在写的时候我们需要实时看到效果，而不是写完重新构建一遍才能看到效果，所以需要借助<code>hexo-server</code>和<code>hexo-browsersync</code>的帮助。前者能够开启一个小型服务器，自动构建来展示hexo博客的页面。而后者能够在你修改了主题文件的时候自动帮你刷新浏览器，帮你省去刷新的动作。所以我们需要安装一下。</p><p>另外我们的主题需要<code>pug</code>和<code>stylus</code>的渲染引擎，所以如下一并安装了：</p><p><code>npm install hexo-server hexo-browsersync hexo-renderer-jade hexo-renderer-stylus --save-dev</code></p><blockquote><p>注意，新版的<code>hexo-renderer-jade</code>已经包括了处理<code>pug</code>的渲染引擎。</p></blockquote><h4 id="Bug以及解决"><a href="#Bug以及解决" class="headerlink" title="Bug以及解决"></a>Bug以及解决</h4><p>1. 安装了<code>hexo-browsersync</code>之后也不能实现修改<code>pug</code>文件之后刷新出修改后的结果。只能实现自动刷新，但是刷新了之后还是修改前的页面。所以我找了一种办法使其能够达到预期的刷新并修改的效果，可以参考这个<a href="https://github.com/hexojs/hexo-renderer-jade/issues/6" target="_blank" rel="noopener">issue</a>里最下面我的回答：</p><p>在你的<code>node_modules</code>文件夹里找到<code>hexo-renderer-jade</code>的文件夹，然后将里面<code>lib/pug.js</code>（jade同理）的其中一行代码注释掉：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pugRender.compile = pugCompile</span></span><br></pre></td></tr></table></figure><p>我初步看了一下应该是跟预编译有关系。</p><p>2. <code>hexo-server</code>模式下，中文文章渲染不全。可以参考这个相关<a href="https://github.com/hexojs/hexo-server/issues/23" target="_blank" rel="noopener">issue</a>。解决办法是在站点的（而不是主题的）<code>_config.yml</code>里添加如下配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  compress:</span> <span class="literal">true</span> <span class="comment"># 开启压缩</span></span><br></pre></td></tr></table></figure><p>3. <code>hexo</code>默认的<code>highlight</code>渲染在未指定代码类型的时候会很慢，为了规范我们的文章书写以及提高渲染速度，我们应该在站点的配置文件里加上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">highlight:</span><br><span class="line"> auto_detect: false</span><br></pre></td></tr></table></figure><p>并在写文章的时候，代码块的声明区域边上直接带上代码类型，比如：```js，这样就正常了。</p><h3 id="用Yeoman来生成主题结构"><a href="#用Yeoman来生成主题结构" class="headerlink" title="用Yeoman来生成主题结构"></a>用Yeoman来生成主题结构</h3><p>生成<code>Hexo</code>主题的话，用<code>Yeoman</code>是很方便的。如果系统里没有首先先安装一下<code>npm install yo -g</code>，然后再安装一下<code>npm install generator-hexo-theme -g</code>。（注意全局安装可能需要权限）于是我们就拥有了一个可以生成主题目录结构的脚手架工具。</p><p>进入之前创建好的Hexo的博客目录，找到<code>themes</code>文件夹，进入。然后<code>yo hexo-theme</code>，这样就会自动生成对应选项，根据选项我们选择<code>pug</code>和<code>stylus</code>，给这个主题命名为<code>temp</code>。然后就会生成一个还不错的项目目录结构。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml # 主题配置文件</span><br><span class="line">├── layout # 布局文件夹</span><br><span class="line">│   ├── archive.pug # 归档页</span><br><span class="line">│   ├── category.pug # 分类页</span><br><span class="line">│   ├── includes # 复用的公共页</span><br><span class="line">│   │   ├── layout.pug # 页面布局</span><br><span class="line">│   │   ├── pagination.pug # 翻页模板</span><br><span class="line">│   │   └── recent-posts.pug # 文章列表模板</span><br><span class="line">│   ├── index.pug # 主页</span><br><span class="line">│   ├── page.pug # 页面详情页</span><br><span class="line">│   ├── post.pug # 文章详情页</span><br><span class="line">│   └── tag.pug # 标签页</span><br><span class="line">└── source # 资源文件夹</span><br><span class="line">    ├── css # CSS</span><br><span class="line">    │   └── temp.styl</span><br><span class="line">    ├── favicon.ico # 站点图标</span><br><span class="line">    └── js # JS</span><br><span class="line">        └── temp.js</span><br></pre></td></tr></table></figure><p>如果完全依照它给的结构来写东西显示是不够的。我们需要一点点给它加东西进去。</p><p>先找到站点的<code>_config.yml</code>文件，找到<code>theme: landsacpe</code>的字样，把它改成<code>theme: temp</code>。（改成的主题名字得根据你在<code>themes</code>目录下创建的主题的文件夹名字，本教程为<code>temp</code>）</p><p>然后我们用<code>hexo s</code>启动服务器，此时应该就能够看到效果了——嗯，一个完全没有CSS样式的页面。确实，因为这个脚手架并没有帮我们写好任何JS和CSS。除了帮我们建好一些模板之外，剩余的完全就靠我们自己来写了。</p><blockquote><p>对于<code>hexo s</code>而言，这个是<code>hexo server</code>的缩写。它的默认端口应该是3000，如果跟你本机的一些端口冲突的话我们可以考虑采用指定端口。比如<code>hexo server -p 3111</code>就能指定在3111端口开启服务。还可以加个<code>-o</code>的参数让它自动帮我们打开浏览器。当然每次写主题的时候都要这样输这么多字肯定不舒服，所以我们可以把命令写入<code>npm scripts</code></p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scripts: &#123;</span><br><span class="line">  "dev": "hexo s -p 3111 -o"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样以后我们只需要<code>npm run dev</code>就行了。</p><h2 id="主题配置文件"><a href="#主题配置文件" class="headerlink" title="主题配置文件"></a>主题配置文件</h2><p>我们很经常会跟主题的配置文件打交道，因为有些功能的开启与关闭我们可以在主题的<code>_config.yml</code>实现。配置文件采用的是<a href="http://docs.ansible.com/ansible/latest/YAMLSyntax.html" target="_blank" rel="noopener">Yaml</a>的语法。它跟json其实很类似，但是写法上简单一些，少去了引号逗号花括号等等，取而代之的是缩进以及<code>-</code>前缀符号。</p><p>之所以把主题配置文件提到这么前面来讲，主要是我踩了一些坑。涉及到主题开发和之后发布上的问题。所以要在这里说一下。往常我们用hexo的主题的话，一些配置项通常是直接修改<code>_config.yml</code>文件，然后再编译一遍站点就可以看到效果。这样做的话优点是方便省心，一次配置了之后就不用管了。</p><p>然而这样做缺点也很明显：</p><p>1. 对于使用者来说，<strong>更新主题的话难免需要把之前的配置文件不管是复制还是剪切，都要找个新的地方先暂时存放，然后再和更新后的主题的配置文件合并</strong>。对于一个不断更新的主题而言，如果你想要用上一些新的功能难免要不断升级。那么升级的话就会遇到配置文件频繁挪动的困扰。</p><p>2. 对于开发者来说，如果单纯把配置项全部写在主题的<code>_config.yml</code>里，那么在发布的时候，因为涉及到一些隐私或者是一些功能默认不需要打开的话，就需要先把<code>_config.yml</code>里的东西先整理成一份干净的配置文件，不能有自己的诸如<code>disqus</code>的id这样的内容在里面。对于开发者而言这也是很痛苦的。每次要发布主题就需要把自己的<code>_config.yml</code>清空一份，然后发布。然后开发主题的时候又要恢复回来。</p><h3 id="data-files"><a href="#data-files" class="headerlink" title="data files"></a>data files</h3><p>为了解决这个问题，我找了不少资料。后来发现了Hexo3.0之后自带支持的这个功能：<a href="https://hexo.io/docs/data-files.html" target="_blank" rel="noopener">data files</a>，能够实现我的需求。并且在参阅<code>Next</code>主题对于这个特性的一些实现之后，发现这个确实是可行的。</p><p>简单来说，就是你可以通过在站点的<code>source/_data</code>目录下（<code>_data</code>文件夹不存在的话手动创建一个）新建配置文件，比如<code>temp.yml</code>，然后在主题里可以通过<code>site.data.temp.xxx</code>去访问配置文件里的配置。</p><p>但是这样对于写主题而言还是不太方便。因为有的用户并不需要频繁更新主题，他只需要修改主题的<code>_config.yml</code>就好了。那么我们在模板引擎里引用主题配置文件的内容是用<code>theme.xxx</code>来访问的。如果两种状态都要考虑的话，我们可能需要在写任何一个配置的时候都要判断一下主题的<code>_config.yml</code>里或者_data里的<code>temp.yml</code>存不存在。这样很麻烦。</p><p>参考了<code>Next</code>主题对于这个的实现后，<code>melody</code>对于这个问题的实现如下：</p><p>参考hexo渲染的<a href="https://hexo.io/api/events.html" target="_blank" rel="noopener">事件</a>，可以找到<code>generateBefore</code>这个钩子，只要在这个钩子触发的时候，判断一下存不存在<code>data files</code>里的配置文件，存在的话就把这个配置文件替换或者合并主题本身的配置文件。<code>Next</code>主题采用的是覆盖，<code>melody</code>主题采用的是替换。各有各的好处，并不是绝对的。</p><p>写法是就是在我们的<code>temp</code>主题目录下的<code>scripts</code>文件夹里（没有就创建一个），写一个js文件，内容如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">Note:</span> configs in _data/temp.yml will replace configs in hexo.theme.config.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">hexo.on(<span class="string">'generateBefore'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (hexo.locals.get) &#123;</span><br><span class="line">    <span class="keyword">var</span> data = hexo.locals.get(<span class="string">'data'</span>) <span class="comment">// 获取_data文件夹下的内容</span></span><br><span class="line">    data &amp;&amp; data.temp &amp;&amp; (hexo.theme.config = data.temp) <span class="comment">// 如果temp.yml 存在，就把内容替换掉主题的config</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样，hexo在构建的时候，会去<code>scripts</code>文件夹里执行里面的代码并运用在渲染中。</p><h3 id="平滑升级"><a href="#平滑升级" class="headerlink" title="平滑升级"></a>平滑升级</h3><p>有了上面的步骤之后，作为用户要更新主题，如果一开始是用<code>git clone</code>的方式克隆的话，只需要在目录里<code>git pull</code>就行了。而作为开发者，可以放心的在自己的<code>data files</code>里定义的配置文件里写下自己的一些配置项的参数，比如一些不适合暴露出去的id等，然后在主题里的<code>_config.yml</code>写上对应的空配置项即可。</p><blockquote><p><strong>注意，这个方法的缺陷是，每当修改了<code>data files</code>里的配置，需要重新运行<code>hexo s</code>或者<code>hexo g</code>才能看到效果</strong></p></blockquote><h2 id="页面书写"><a href="#页面书写" class="headerlink" title="页面书写"></a>页面书写</h2><p>动手开始写主题的页面开始，需要注意到<code>layout.pug</code>这个文件，这个文件是整个网站布局的最核心的基础代码——连index页面都是通过<code>extends</code>它而来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extends includes/layout.pug</span><br><span class="line"></span><br><span class="line">block content</span><br><span class="line">  include includes/recent-posts.pug</span><br><span class="line">  include includes/pagination.pug</span><br></pre></td></tr></table></figure><p>所以它决定了我们整个网站的布局。打开<code>layout.pug</code>可以看到，它暴露一个<code>block content</code>给我们去根据不同的页面来写不同的内容。这个是整个Hexo主题的主入口。根据不同的页面类型，渲染不同的页面内容。不同的页面，书写代码的思路其实说到底跟上面的方式差不多了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extends includes/layout.pug // 首先继承layout模板</span><br><span class="line"></span><br><span class="line">block content</span><br><span class="line">  include includes/recent-posts.pug // block content 区域引入rencent-posts模板</span><br><span class="line">  include includes/pagination.pug // block content 区域引入pagination模板</span><br></pre></td></tr></table></figure><p>可以发现，这样做的好处是最大化复用了<code>layout</code>的模板，让所有页面都一致或者相似的地方能够少些不少代码。</p><h3 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h3><p>页面数据的获取，一般有三种途径：</p><ol><li>Hexo预置（<a href="https://hexo.io/docs/variables.html" target="_blank" rel="noopener">变量</a>、<a href="https://hexo.io/docs/helpers.html" target="_blank" rel="noopener">辅助函数</a>）</li><li>站点的配置文件（_config.yml）</li><li>主题的配置文件（temp.yml或者_config.yml）</li></ol><p>下面详细说一下如何使用。</p><h4 id="Hexo预置"><a href="#Hexo预置" class="headerlink" title="Hexo预置"></a>Hexo预置</h4><p>Hexo预置的变量，查看文档后你能发现主要有<code>site</code>、<code>page</code>、<code>post</code>和<code>theme</code>（会在主题的配置文件里说）。</p><p>1.<code>site</code>变量可以说是个对象，长得如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">site = &#123;</span><br><span class="line">  posts: [object object], <span class="comment">// 包含文章对象的数组</span></span><br><span class="line">  pages: [object object], <span class="comment">// 包含页面对象的数组</span></span><br><span class="line">  categories: [object object], <span class="comment">// 包含分类对象的数组</span></span><br><span class="line">  tags: [object object] <span class="comment">// 包含标签对象的数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常，我们可以通过<code>site</code>变量获取站点的文章总数，标签总数和分类总数</p><p>2.<code>page</code>是一个很神奇的变量，也是最有用的变量。不同的页面，从page拿到的文章不一样。</p><p>比如首页，如果你在站点的配置文件里配置了一页显示多少文章的话（比如10篇文章），那么在首页，<code>page</code>里就只会有这10篇文章的相关信息，而不是你的博客里所有的文章的相关信息。如果在标签页，你通过<code>page</code>拿到的值将只会是某个标签对应的所有文章的相关信息（当然也受制于一页显示多少文章）</p><p>所以<code>page</code>将会是很常用的一个变量。</p><p>3.<code>post</code>变量实际上是某一篇文章的具体信息。它和<code>page</code>变量里的某一项差别就在于，<code>post</code>变量还多包含了这一篇文章的<code>tags</code>、<code>categories</code>和<code>published</code>变量。前两者很常用，它们通常就是用来显示某一篇文章所具有的标签以及所处的分类。</p><p>4.<code>theme</code>这个变量实际上就是主题的配置文件的对象。这个我们将放到后面再讲。</p><p>Hexo预置的辅助函数，常用的我觉得有如下几个：</p><ol><li><code>is\_home</code>、<code>is\_post</code>、<code>is\_tag</code>、<code>is\_category</code>、<code>is\_post</code>等几个判断当前文章类型的函数</li><li><code>date</code>、<code>time</code>等时间字符串处理函数</li><li><code>list\_categories</code>、<code>list\_tags</code>、<code>tagcloud</code>等生成分类列表、标签列表、标签云等函数</li><li><code>toc</code> 生成文章目录</li><li><code>paginator</code> 生成页面页码</li></ol><h4 id="站点配置文件和主题配置文件"><a href="#站点配置文件和主题配置文件" class="headerlink" title="站点配置文件和主题配置文件"></a>站点配置文件和主题配置文件</h4><p>站点配置文件和主题配置文件在hexo页面里能够暴露出来的配置项分别是<code>config</code>和<code>theme</code>。而且相当简单就能获取。</p><p>比如我在主题的<code>temp.yml</code>配置文件里有配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line"><span class="attr">  Home:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">  Archives:</span> <span class="string">/archives</span></span><br><span class="line"><span class="attr">  Tags:</span> <span class="string">/tags</span></span><br><span class="line"><span class="attr">  Categories:</span> <span class="string">/categories</span></span><br></pre></td></tr></table></figure><p>那么我在模板引擎里就可以通过<code>menu.Tags</code>的方式获取<code>/tags</code>这个字符串</p><h3 id="数据查看与填充"><a href="#数据查看与填充" class="headerlink" title="数据查看与填充"></a>数据查看与填充</h3><p>在pug里如果你想要查看一个变量的值（比如site的pages），你可以直接这样做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- console.log(site.pages)</span><br></pre></td></tr></table></figure><p>注意到，如果要在<code>pug</code>里书写变量声明，表达式，可以有如下写法：</p><p><strong>单行书写</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- console.log(1)</span><br><span class="line">- var a = 2</span><br></pre></td></tr></table></figure><p>通过短横线<code>-</code>后加个空格，然后书写单行表达式。如果要多行书写要用如下写法：</p><p><strong>多行书写</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-</span><br><span class="line">  console.log(1)</span><br><span class="line">  var a = 2</span><br></pre></td></tr></table></figure><p>通过短横线<code>-</code>下方代码区缩进来书写多行表达式。<strong>需要注意的是，此时<code>-</code>号后面不能跟空格，直接回车。</strong></p><p>那么你就可以在控制台看到具体的pages的信息。这并不会渲染到最终的html里。既然拿到了数据，那我们就可以开始渲染了。</p><p>比如对于<code>recent-posts</code>，实际上就是我们常见的首页能看到一堆文章列表的页面。要对这个页面进行渲染，可以采用如下写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">each article in page.posts.data //- 注意首页也是一个page，它包含的posts只包括了首页会显示出来的文章。</span><br><span class="line">  .recent-post-item</span><br><span class="line">    - var link = article.link || article.path</span><br><span class="line">      a.article-title(href=url_for(link))= article.title || &apos;no_title&apos;</span><br><span class="line">    .content!= article.excerpt //- excerpt是post的一个变量，只会显示文章的摘要部分（也就是文章里&lt;!--more--&gt;之前的内容）</span><br><span class="line">    a.more(href=url_for(link) + &apos;#more&apos;) 阅读更多</span><br><span class="line">    hr</span><br></pre></td></tr></table></figure><p>注意到上面的a标签里，我们用到了一个<code>url_for(link)</code>，<code>url_for()</code>是个辅助函数，负责将相对路径转换为页面的绝对地址，这样在哪里都能点开而不用考虑相对路径的问题了。</p><p>注意到pug里，如果要输出变量，有两种写法<code>=</code>和<code>!=</code>。这两者的区别就是前者的输出带转义，后者的输出不带转义。可以查看pug的官方文档对于这二者区别的<a href="https://pugjs.org/zh-cn/language/code.html#buffered-code" target="_blank" rel="noopener">解释</a>。简单来说后者的输出可以输出标准的html标签。而前者将会把html标签转义成字符串。</p><h4 id="页码的实现"><a href="#页码的实现" class="headerlink" title="页码的实现"></a>页码的实现</h4><p>我们能够发现通常博客底部是有页码的，告诉读者有多少页的文章，并且当前在第几页。这个功能在Hexo里实现起来特别容易。就是运用<code>paginator</code>这个辅助函数。</p><p>找到脚手架生成的<code>pagination.pug</code>文件，发现它的实现还蛮复杂。我们将它改写一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-</span><br><span class="line">  var options = &#123;</span><br><span class="line">    prev_text: &apos;&lt;&apos;,</span><br><span class="line">    next_text: &apos;&gt;&apos;</span><br><span class="line">  &#125;</span><br><span class="line">#pagination</span><br><span class="line">  .pagination</span><br><span class="line">    !=paginator(options)</span><br></pre></td></tr></table></figure><p>那么它就会按照页面的不同生成不同的页码。不过有个例外，在文章页，由于没有分页，我们通常需要实现上一篇文章和下一篇文章的链接按钮供读者快速切换邻近的文章。所以改写如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">-</span><br><span class="line">  var options = &#123;</span><br><span class="line">    prev_text: &apos;&lt;&apos;,</span><br><span class="line">    next_text: &apos;&gt;&apos;</span><br><span class="line">  &#125;</span><br><span class="line">#pagination</span><br><span class="line">  if(!is_post())</span><br><span class="line">    .pagination</span><br><span class="line">      !=paginator(options)</span><br><span class="line">  else //- </span><br><span class="line">    if(page.prev)</span><br><span class="line">      .prev-post.pull-left</span><br><span class="line">        a(href=url_for(page.prev.path))</span><br><span class="line">          i.fa.fa-chevron-left   </span><br><span class="line">          span=page.prev.title</span><br><span class="line">    if(page.next)</span><br><span class="line">      .next-post.pull-right</span><br><span class="line">        a(href=url_for(page.next.path))</span><br><span class="line">          span=page.next.title </span><br><span class="line">          i.fa.fa-chevron-right</span><br></pre></td></tr></table></figure><h4 id="侧边栏目录的实现"><a href="#侧边栏目录的实现" class="headerlink" title="侧边栏目录的实现"></a>侧边栏目录的实现</h4><p>侧边栏目录的实现其实很简单。通过<code>toc</code>这个辅助函数，其实很容易就能做到。如果不需要额外配置，最简单的话如下就可以实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if(is_post()) //- 如果是文章页面</span><br><span class="line">  .sidebar-toc!= toc(page.content) //- 给toc传入当前页面的内容用于生成目录结构</span><br></pre></td></tr></table></figure><p>它大致生成如下的HTML结构：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">class</span>=<span class="string">"toc"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"toc-item toc-level-2"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"toc-link"</span> <span class="attr">href</span>=<span class="string">"#hexo"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"toc-number"</span>&gt;</span>1.<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"toc-text"</span>&gt;</span>hexo<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后你可以用js去控制它是否可以展开，是否可以跟随页面滚动而高亮等等，以及用css去修改它的默认样式。</p><p>如果还要定义目录的层级、是否显示前缀数字，可以根据官网的文档，在<code>toc</code>里传入额外的参数来实现。</p><h4 id="标签云页-分类归纳页"><a href="#标签云页-分类归纳页" class="headerlink" title="标签云页+分类归纳页"></a>标签云页+分类归纳页</h4><p>标签云页，也就是我们常见的一个能够展现所有标签集合的页面：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fjib2khkdoj21je0y20x0.jpg" alt=""></p><p>分类归纳页，也就是展示所有<code>categories</code>层级关系的页面：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fjib7uhzo0j21jc0rydie.jpg" alt=""></p><p>一开始我以为是在<code>tag.pug</code>页面书写这个这个标签云的。后来我发现错了。这个标签云的页面实际上是在<code>page.pug</code>页面，通过判断页面类型来进行不同输出的。而分类归纳页也是同理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">extends includes/layout.pug</span><br><span class="line"></span><br><span class="line">block content</span><br><span class="line">  if page.type === &apos;tags&apos;</span><br><span class="line">    .tag-cloud</span><br><span class="line">      .tag-cloud__title= page.title  </span><br><span class="line">        |  - </span><br><span class="line">        span.tag-cloud__amount= site.tags.length</span><br><span class="line">      .tag-cloud-tags!= tagcloud(&#123;min_font: 12, max_font: 30, amount: 200, color: true, start_color: &apos;#A4D8FA&apos;, end_color: &apos;#0790E8&apos;&#125;)</span><br><span class="line">  else if page.type === &apos;categories&apos;</span><br><span class="line">    .category-lists</span><br><span class="line">      .category__title= page.title  </span><br><span class="line">        |  - </span><br><span class="line">        span.category__amount= site.categories.length</span><br><span class="line">      div!= list_categories()</span><br><span class="line">  else</span><br><span class="line">    article#page</span><br><span class="line">      h1= page.title</span><br><span class="line">      != page.content</span><br><span class="line">    include includes/pagination.pug</span><br></pre></td></tr></table></figure><p>其中，标签云的生成依赖于辅助函数<code>tagcloud</code>，相关配置项也可以在官网找到说明。而分类归纳列表，则通过辅助函数<code>list_categories</code>生成。至于样式，当然是根据自己的主题风格自己书写CSS来适配了。</p><h4 id="详情页-文章归档页"><a href="#详情页-文章归档页" class="headerlink" title="详情页+文章归档页"></a>详情页+文章归档页</h4><p>例外的是，文章归档页（archives）不适用于上面的规则，而是直接在<code>archive.pug</code>里直接书写相应的页面代码就好了。</p><p>而实际上，你会发现，从标签云点击某个标签页，以及从分类归纳页点击某个分类后，进入的页面，跟文章归档页其实是很类似的：</p><p>1.具体的标签页</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fjibyqrm5gj21z211kjxf.jpg" alt=""></p><p>2.具体的分类页</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fjibyqq731j21z212244o.jpg" alt=""></p><p>3.文章归档页</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fjibyr0atdj21z211e447.jpg" alt=""></p><p>可以发现，基本上除了标题有所不同之外，基本都是文章列表的形式。如果没有特殊要求，实际上就跟做首页一样，统一用<code>each article in page.posts.data</code>，然后把文章标题和标题地址拿出来就好了。然而由于我对文章列表的形式有所要求和定制，所以我写了一个<code>mixin</code>，用于处理文章列表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mixin articleSort(posts)</span><br><span class="line">  .article-sort</span><br><span class="line">    - var year</span><br><span class="line">    - posts.each(function (article) &#123;</span><br><span class="line">      - var tempYear = date(article.date, &apos;YYYY&apos;)</span><br><span class="line">      if tempYear !== year</span><br><span class="line">        - year = tempYear </span><br><span class="line">        .article-sort-item.year= year //- 展示年份</span><br><span class="line">      .article-sort-item</span><br><span class="line">        time.article-sort-item__time= date(article.date)</span><br><span class="line">        a.article-sort-item__title(href=url_for(article.path) target=&quot;_blank&quot;)= article.title || &apos;No Title&apos;</span><br><span class="line">    - &#125;)</span><br></pre></td></tr></table></figure><p>然后比方说在<code>tag.pug</code>页面，就可以用如下的写法来实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">extends includes/layout.pug</span><br><span class="line"></span><br><span class="line">block content</span><br><span class="line">  include ./includes/mixins/article-sort.pug //- 引入mixin</span><br><span class="line">  #tag</span><br><span class="line">    .article-sort-title= &apos;Tag - &apos; + page.tag</span><br><span class="line">    +articleSort(page.posts) //- 调用mixin</span><br><span class="line">  include includes/pagination.pug</span><br></pre></td></tr></table></figure><h3 id="Stylus一些技巧"><a href="#Stylus一些技巧" class="headerlink" title="Stylus一些技巧"></a>Stylus一些技巧</h3><p>在<code>pug</code>里可以通过诸如<code>div=theme.xxx</code>的方式来获取主题配置文件里的<code>xxx</code>项的值。而<code>stylus</code>里要获取主题配置里的变量要怎么做呢？最普遍的需求就是，代码高亮配色方案的选择，比如<code>melody</code>主题提供了<code>material-theme</code>四种配色方案，要通过配置文件的配置项来配置采用何种配色方案。</p><p>比如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">highlight:</span> <span class="string">default</span></span><br></pre></td></tr></table></figure><p>这个时候在stylus里可以通过比如：</p><figure class="highlight styl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$highlight</span>-theme = hexo-config(<span class="string">'highlight'</span>)</span><br></pre></td></tr></table></figure><p>用<code>hexo-confg</code>这个方法，来获取当前在主题配置文件里的配置项。</p><p>然后运用<code>stylus</code>的条件语句就可以渲染不同的主题配色方案了。</p><p>另外，我们在使用stylus的时候，通常会书写一些变量文件stylus，这些变量文件可以运用到其他需要编译成css的stylus，而变量文件本身并不需要编译成具体的CSS文件。如何控制这些stylus文件不编译成具体的css呢？</p><p>例如<code>melody</code>主题的CSS文件夹结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _global</span><br><span class="line">│   └── index.styl</span><br><span class="line">├── _highlight</span><br><span class="line">│   ├── diff.styl</span><br><span class="line">│   ├── highlight.styl</span><br><span class="line">│   └── theme.styl</span><br><span class="line">├── _layout</span><br><span class="line">│   ├── comments.styl</span><br><span class="line">│   ├── footer.styl</span><br><span class="line">│   ├── head.styl</span><br><span class="line">│   ├── page.styl</span><br><span class="line">│   ├── pagination.styl</span><br><span class="line">│   ├── post.styl</span><br><span class="line">│   └── sidebar.styl</span><br><span class="line">├── _search</span><br><span class="line">│   ├── algolia.styl</span><br><span class="line">│   └── index.styl</span><br><span class="line">├── _third-party</span><br><span class="line">│   ├── jquery.fancybox.min.css</span><br><span class="line">│   └── normalize.min.css</span><br><span class="line">├── index.styl</span><br><span class="line">└── var.styl</span><br></pre></td></tr></table></figure><p>你会发现，里面的文件夹都是以下划线<code>_</code>作为起始的。我在<code>index.styl</code>里引用了它们：</p><figure class="highlight styl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@import <span class="string">"nib"</span></span><br><span class="line"><span class="comment">// third-party</span></span><br><span class="line">@import <span class="string">"_third-party/jquery.fancybox.min.css"</span></span><br><span class="line">@import <span class="string">"_third-party/normalize.min.css"</span></span><br><span class="line"><span class="comment">// project</span></span><br><span class="line">@import <span class="string">"var"</span></span><br><span class="line">@import <span class="string">"_global"</span></span><br><span class="line">@import <span class="string">"_highlight/highlight"</span></span><br><span class="line">@import <span class="string">"_layout/*"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// search</span></span><br><span class="line"><span class="keyword">if</span> hexo-config(<span class="string">"algolia_search.enable"</span>)</span><br><span class="line">  @import <span class="string">"_search/index"</span></span><br><span class="line">  @import <span class="string">"_search/algolia"</span></span><br></pre></td></tr></table></figure><p>实际上，以下划线作为文件夹命名起始的话，hexo在编译的时候就会略过他们不生成具体的css——也就是说最后只会生成<code>index.css</code>和<code>var.css</code>两个css文件，而不会生成诸如<code>_layout/footer.css</code>这样的文件了。</p><p>当然如果你需要做到生成<code>footer.css</code>这样的css文件，就把它所在文件夹的名字去掉前面的下划线就好啦。</p><h3 id="pug的一些使用技巧"><a href="#pug的一些使用技巧" class="headerlink" title="pug的一些使用技巧"></a>pug的一些使用技巧</h3><p>通常我们主题或者站点的一些配置文件的配置项，根据需要可以由pug渲染成不同的html。但是难免我们需要比如js里获取来自主题配置或者站点配置的一些配置项。</p><p>一个比较鲜明的例子就是<a href="https://www.algolia.com/" target="_blank" rel="noopener">algolia</a>这个搜索框架需要我们在js里提供诸如<code>appId</code>等信息。这个时候我们需要在<code>pug</code>里写script，把来自主题或者站点配置的内容写到<code>script</code>标签里。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-</span><br><span class="line">  var algolia;</span><br><span class="line">  if (theme.algolia_search.enable) &#123;</span><br><span class="line">    algolia = JSON.stringify(&#123;</span><br><span class="line">      appId: config.algolia.appId || config.algolia.applicationID,</span><br><span class="line">      apiKey: config.algolia.apiKey,</span><br><span class="line">      indexName: config.algolia.indexName,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    algolia = &apos;undefined&apos;</span><br><span class="line">  &#125;</span><br><span class="line">script.</span><br><span class="line">  var GLOBAL = &#123; </span><br><span class="line">    algolia: !&#123;algolia&#125;,</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>上面的pug最后会输出成html如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> GLOBAL = &#123;</span></span><br><span class="line"><span class="undefined">    algolia: &#123;</span></span><br><span class="line"><span class="javascript">      appId: <span class="string">'xxxxx'</span>,</span></span><br><span class="line"><span class="javascript">      apiKey: <span class="string">'xxxxx'</span>,</span></span><br><span class="line"><span class="javascript">      indexName: <span class="string">'xxxx'</span></span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意到上面我们用到了<code>!{algolia}</code>的方式，把变量输入到了<code>pug</code>的script标签里。我们不能简单像在pug的html部分通过诸如<code>div= theme.algolia_search.enable</code>这样的方式把内容渲染到<code>script</code>标签里，因为script标签里的就是实打实最后要输出到html里的js内容。不过可以通过<code>!{}</code>的方式，pug在编译的时候会把这部分变量的内容填充到script标签里。</p><p>同时需要注意的两点是：</p><ol><li>要在<code>script</code>标签里写js代码的话，需要在<code>script</code>后面加个点：<code>script.</code></li><li>如果只是单纯填充某个变量，用<code>!{xxx}</code>就行了。但是如果该变量是个对象的话，则需要通过<code>JSON.stringify</code>先字符串化。具体可以看上面的代码。</li></ol><h2 id="主题发布"><a href="#主题发布" class="headerlink" title="主题发布"></a>主题发布</h2><p>根据自己的奇思妙想，运用上面的各种方法去实现你自己的hexo的主题。而主题写完就可以发布了。首先先去fork Hexo的官方<a href="https://github.com/hexojs/site" target="_blank" rel="noopener">站点</a>，然后编辑<code>source/_data/theme.yml</code>文件，把你的主题信息加上去：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">Melody</span></span><br><span class="line"><span class="attr">  description:</span> <span class="string">A</span> <span class="string">simple</span> <span class="string">&amp;</span> <span class="string">beautiful</span> <span class="string">&amp;</span> <span class="string">fast</span> <span class="string">theme</span> <span class="string">for</span> <span class="string">Hexo</span> <span class="comment"># 简介</span></span><br><span class="line"><span class="attr">  link:</span> <span class="attr">https://github.com/Molunerfinn/hexo-theme-melody</span> <span class="comment"># 示范站点</span></span><br><span class="line"><span class="attr">  preview:</span> <span class="attr">https://molunerfinn.com</span> <span class="comment"># github 仓库</span></span><br><span class="line"><span class="attr">  tags:</span> <span class="comment"># 标签</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">simple</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">beautiful</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">fast</span></span><br></pre></td></tr></table></figure><p>然后去<code>source/theme/screenshots/</code>文件夹里放置一个跟你主题名字一样的图片，大小是800*500。</p><p>弄完这些就把这些提交到自己fork的仓库里。然后，向官方站点发起一个<code>pull request</code>，静候Hexo官方维护人员把你的主题收录，就大功告成啦！</p><p>我的主题<a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener">hexo-theme-melody</a>就已经成功被官方收录啦：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fjjgshdhkwj20p20suwqd.jpg" alt=""></p><hr><p>如果你喜欢我的主题，欢迎使用，star，pull request，也可以在issue里给我提意见或者建议。感谢阅读了我这篇啰嗦的文章的所有读者，希望对大家的Hexo主题开发能有所启迪~</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;之前学前端的初衷就是为了让自己的个人博客好看点。Hexo主题如今很大概率你能够看到&lt;a href=&quot;https://github.com/iissnan/hexo-theme-next&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Next&lt;/a&gt;主题以及它的一些个人修改、衍生版本。我记得去年在看一篇&lt;a href=&quot;http://chensd.com/2016-06/hexo-theme-guide.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo主题开发指南&lt;/a&gt;的时候，有句话对我感触很深：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;当你看到你用的主题出现在两个以上的博客的时候，那你就要考虑自己写一个了。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;懒癌晚期的自己以及毕业设计等等事情的拖延，终于在最近完成了自己的Hexo主题——&lt;a href=&quot;https://github.com/Molunerfinn/hexo-theme-melody&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Melody&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;本文将讲述如何制作一个&lt;code&gt;Hexo&lt;/code&gt;主题，以及在制作过程中的一些坑和一些经验。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;在我主题制作过程中，Next主题以及其他一些优秀的前端博客例如&lt;a href=&quot;https://huangxuan.me/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hux&lt;/a&gt;，对我帮助和启发很大，再次感谢&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="hexo" scheme="https://molunerfinn.com/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://molunerfinn.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>hexo持久化构建以及给自有域名github-page上HTTPS</title>
    <link href="https://molunerfinn.com/hexo-travisci-https/"/>
    <id>https://molunerfinn.com/hexo-travisci-https/</id>
    <published>2017-07-27T18:44:00.000Z</published>
    <updated>2018-04-27T08:26:51.717Z</updated>
    
    <content type="html"><![CDATA[<p>过一段时间博客的主机要到期了。我看了一下才发现，主机上其实我也只是放着我hexo的静态博客而已。觉得每个月要交几十块钱其实并不值当，遂决定把hexo博客从云主机上转移出来到github-page上。</p><p>本文主要记录如何运用<code>Travis-CI</code>对hexo博客进行持久化构建，以及通过<code>Cloudflare</code>给自有域名的github-page加上<code>https</code>。<strong>文末给出如何将自己的博客加入<code>HSTS</code>网站列表。</strong></p><a id="more"></a><p>之前在自己的主机上写博客的时候，写完执行一下<code>hexo g</code>就可以了。不过后来想想其实还是不太安全。这个方式万一在主机dang掉之后，数据就有可能找不回来了。如果每次写完既要<code>hexo g</code>又要<code>hexo d</code>的话又过于麻烦，而且只能推送构建后的页面而不能保存文章源(markdown)文件。于是趁此机会来改造一下，也是一件快意之事。</p><h2 id="持久化构建"><a href="#持久化构建" class="headerlink" title="持久化构建"></a>持久化构建</h2><p>持久化构建，也就是<code>持久化</code>和<code>构建</code>。</p><p><code>持久化</code>的意思就是能保证数据能够长久保留下来。对应于我的情况来说，github就是一个非常优秀的持久化存储数据的地方。github的仓库能够持久化保留我的md文件+构建后的hexo博客页面。</p><p>而<code>构建</code>就是把源(md)文件编译成博客页的步骤。</p><p>能够做到构建的同时持久化的，目前来说最方便而且最省心的就是<code>Travis-CI</code>了。</p><p>简单来说，在你push到github仓库后，通过配置文件，它能够执行一系列的脚本（比如编译、构建、测试、推送等）。对于我来说，就可以实现：只要我写完hexo的md博客，推送到github仓库里后，它就能自动帮我构建并推送到github相应的分支上。从而实现了持久化构建，以及我博客的更新。</p><h3 id="注册Travis-CI"><a href="#注册Travis-CI" class="headerlink" title="注册Travis-CI"></a>注册Travis-CI</h3><p>去官网注册一下<a href="https://travis-ci.org/" target="_blank" rel="noopener">Travis-CI</a>，关联上你的github账号，给予权限后就可以把你的github仓库同步到它这里来。</p><p><img src="https://ws1.sinaimg.cn/large/8700af19gy1fi42yvwwfzj21460le418.jpg" alt="Travis-CI"></p><p>在需要<code>Travis-CI</code>构建的仓库打开同步设置。</p><p><img src="https://ws1.sinaimg.cn/large/8700af19gy1fi430jb981j20w404ct8w.jpg" alt="打开同步设置"></p><h3 id="设定Token"><a href="#设定Token" class="headerlink" title="设定Token"></a>设定Token</h3><p>去github的个人设置那边找到Token设置。</p><p><img src="https://ws1.sinaimg.cn/large/8700af19gy1fi433d1zlkj21mi0q4799.jpg" alt="Github-token"></p><p>设定一个Token给<code>Travis-CI</code>，名字自己取让它对我们的仓库能够拥有读写权限（就够了）。</p><p><img src="https://ws1.sinaimg.cn/large/8700af19gy1fi434caiywj216o08otaa.jpg" alt="Token"></p><p><strong>然后保存一下这个Token——它只显示一次，之后就不再显示了。所以找个地方把它记下来先。</strong></p><p>然后回到<code>Travis-CI</code>里，对于开启同步的仓库进行设置，我们把刚才的这个Token存储为一个叫做<code>GH_TOKEN</code>的环境变量，可以在<code>.travis.yml</code>这个配置文件里通过<code>${GH_TOKEN}</code>的方式获取。这样就不会将你的TOKEN暴露出去了。</p><p><img src="https://ws1.sinaimg.cn/large/8700af19gy1fi438l5g9sj218a0wmn1u.jpg" alt="GH_TOKEN"></p><p>然后在所在github项目里创建一个叫做<code>.travis.yml</code>的文件。这个文件就是<code>Travis-CI</code>的执行脚本。它会根据里面定义的环境、步骤一步一步执行直到最后输出结果。</p><h3 id="编写-travis-yml"><a href="#编写-travis-yml" class="headerlink" title="编写.travis.yml"></a>编写.travis.yml</h3><p><code>.travis.yml</code>是<code>Travis-CI</code>读取的配置文件。我的配置文件如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">node_js</span> <span class="comment"># 声明环境为node</span></span><br><span class="line"><span class="attr">node_js:</span> <span class="string">stable</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Travis-CI Caching</span></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line"><span class="attr">  directories:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">node_modules</span> <span class="comment"># 缓存node_modules文件夹</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># S: Build Lifecycle</span></span><br><span class="line"><span class="attr">install:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">npm</span> <span class="string">install</span> <span class="comment"># 下载依赖</span></span><br><span class="line"></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">hexo</span> <span class="string">algolia</span> <span class="comment"># 我装了algolia的搜索工具。这一步正常可以是 hexo g</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">after_script:</span> <span class="comment"># 推送到github的部分</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">cd</span> <span class="string">./public</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">init</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">config</span> <span class="string">user.name</span> <span class="string">"Molunerfinn"</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">config</span> <span class="string">user.email</span> <span class="string">"marksz@teamsz.xyz"</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">add</span> <span class="string">.</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">commit</span> <span class="bullet">-m</span> <span class="string">"Update docs"</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">push</span> <span class="bullet">--force</span> <span class="bullet">--quiet</span> <span class="string">"https://$&#123;GH_TOKEN&#125;@$&#123;GH_REF&#125;"</span> <span class="attr">master:master</span> <span class="comment"># 通过之前存在Travis-CI里的token以及github仓库的地址推送到相应的master分支</span></span><br><span class="line"><span class="comment"># E: Build LifeCycle</span></span><br><span class="line"></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line"><span class="attr">  only:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">hexo</span> <span class="comment"># 只对hexo分支构建</span></span><br><span class="line"></span><br><span class="line"><span class="attr">env:</span> <span class="comment"># 环境变量</span></span><br><span class="line"><span class="attr"> global:</span></span><br><span class="line"><span class="attr">   - GH_REF:</span> <span class="string">github.com/Molunerfinn/Molunerfinn.github.io.git</span> <span class="comment"># 我的仓库地址</span></span><br></pre></td></tr></table></figure><h3 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h3><p>我原本设定的是master分支作为<code>github-page</code>的展示分支。所以我切出了一个<code>hexo</code>分支，用来放置博客原文。<code>hexo</code>分支只需要留下如下的目录结构即可（其实就是除了public文件夹以外，其他文件夹都可以留）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── .travis.yml</span><br><span class="line">├── package-lock.json</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">│   ├── draft.md</span><br><span class="line">│   ├── page.md</span><br><span class="line">│   └── post.md</span><br><span class="line">├── source</span><br><span class="line">│   ├── CNAME</span><br><span class="line">│   ├── _posts</span><br><span class="line">│   ├── about</span><br><span class="line">│   ├── favicon.ico</span><br><span class="line">│   └── tags</span><br><span class="line">└── themes</span><br><span class="line">    └── next</span><br></pre></td></tr></table></figure><p>做完上述工作后，将<code>.travis.yml</code>这个文件添加进<code>git</code>仓库，然后推送到远端的<code>hexo</code>分支，就会发现<code>Travis-CI</code>已经接收到相应的请求正在进行构建了。构建完成后，会将<code>public</code>文件夹内的内容推送到<code>master</code>分支。至此我们完成了持久化构建的部分。</p><h2 id="给自有域名的github-page上HTTPS"><a href="#给自有域名的github-page上HTTPS" class="headerlink" title="给自有域名的github-page上HTTPS"></a>给自有域名的github-page上HTTPS</h2><p>从Chrome56左右开始，对于没有HTTPS的网站，不符合要求的，都不会出现一把小绿锁。反之，有了小绿锁的网站，标志着这个网站是HTTPS安全的。</p><p>假如你没有自己的域名，而是使用着github的子域名（形如<code>xxx.github.io</code>）那么能够自动拥有github的https，无需操心。</p><p>但是如果有自己的域名，想要实现自己的域名通过CNAME指向github的page，并加上小绿锁的话，就比较麻烦了。首先我们需要将自己的域名通过CNAME指向github-page。在hexo的<code>source</code>文件夹里创建一个叫做CNAME的文件，内容只需要写上你自己的域名即可。对于我来说就是<code>molunerfinn.com</code>。</p><p>通过CNAME指向github-page的页面之后，我们发现，原本github自带的https已经不能再使用了。我们必须给自己的域名想办法弄上https。一开始并无头绪，不过好在我找到了<code>Cloudflare</code>这个解决方案。</p><h3 id="注册Cloudflare"><a href="#注册Cloudflare" class="headerlink" title="注册Cloudflare"></a>注册Cloudflare</h3><p>第一步当然是注册。<code>Cloudflare</code>是国外非常有名的一家网络服务提供商。它提供的其中一项免费服务就是给我们自有域名加上HTTPS。正好符合我们的需求。</p><p>注册成功后添加域名。</p><p>然后需要增加几个记录，其中A记录就是指向这<code>192.30.252.153</code>和<code>192.30.252.154</code>这两个IP地址，它们是github-page的ip地址。然后建一个CNAME将<code>www</code>的网址指向我们非<code>www</code>的网址</p><p><img src="https://ws1.sinaimg.cn/large/8700af19gy1fi43icnw1jj21l80wajwm.jpg" alt="DNS Records"></p><p>然后需要将我们的域名的DNS服务商的地址改成<code>Cloudflare</code>要求的两个<code>DNS</code>服务器地址。每个人分配的不一样，而且必须用分配的否则会失效。</p><p><img src="https://ws1.sinaimg.cn/large/8700af19gy1fi43n3bs7yj21ig0g4wgj.jpg" alt="DNS Server"></p><p>这个操作需要在自己的域名服务提供那边修改。一般是48小时内生效。</p><h3 id="开启HTTPS"><a href="#开启HTTPS" class="headerlink" title="开启HTTPS"></a>开启HTTPS</h3><p>找到<code>Crypto</code>选项，这里我们需要开启<code>Flexible</code>的HTTPS选项。</p><p><img src="https://ws1.sinaimg.cn/large/8700af19gy1fi45c5avd6j21jq0s4tcc.jpg" alt="https"></p><p>其实<code>Cloudflare</code>做的事就是，当访问我们的域名的时候，实际上走的是<code>Cloudflare</code>的服务器，这个时候这个阶段的访问是有HTTPS的。然后<code>Cloudflare</code>再去请求我们实际的内容，再将内容返回给用户。这一段是没有HTTPS的。也就是实际上是半HTTPS。不过对于我们静态博客来说，这种半HTTPS实际上已经够我们使用了。</p><p>可以看见开启HTTPS真的非常简单，基本不需要额外操作。</p><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>这个时候我们访问<code>https://molunerfinn.com</code>自然走的是HTTPS。但是如果有人访问了<code>http://molunerfinn.com</code>，那要如何跳转到HTTPS的页面呢？<code>CloudFare</code>另一个很棒的功能<code>Page Rules</code>就派上用场了。我们可以指定我们的域名强制使用HTTPS，并且当访问是HTTP的时候重定向到HTTPS。这样就能保证用户访问我们的页面都是通过HTTPS的了。</p><p><img src="https://ws1.sinaimg.cn/large/8700af19gy1fi45ezb4b2j21k20xotdz.jpg" alt="Rewrite"></p><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><h4 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h4><p>刚开始用<code>CloudFare</code>的DNS服务器，国内域名解析一开始会时断时续。我自己大概是过了24小时之后开始稳定的。所以一开始有可能访问不到自己的博客这是正常的。一开始我还以为是Cloudflare那边问题比较严重还提了一个issue。后来第三天就正常了。</p><h4 id="加入HSTS的列表"><a href="#加入HSTS的列表" class="headerlink" title="加入HSTS的列表"></a>加入HSTS的列表</h4><p>上面说到，我们有可能访问自己的网站是走HTTP-&gt;304重定向-&gt;HTTPS。这个是浏览器跟服务器进行了一次通信之后才发生的跳转。那有没有可能做到，访问的是HTTP，但是浏览器识别之后自动转成HTTPS访问，而不经过重定向那一层操作呢？有的。通过HSTS的Preload List。</p><p>可以参考这篇文章对<a href="http://www.jianshu.com/p/caa80c7ad45c" target="_blank" rel="noopener">HSTS</a>进行更深入的了解。简单来说，HSTS能够使我们的网站安全性更上一层楼。</p><p>还是<code>CloudFare</code>，它家自有的HSTS功能，开启之后就能很好的满足我们的需要。（真是完美了）还是在<code>Crypto</code>选项下，开启<code>HSTS</code></p><p><img src="https://ws1.sinaimg.cn/large/8700af19gy1fi45gia6pcj21kc0iugny.jpg" alt="HSTS"></p><p>建议都使用默认的选项。</p><p>然后可以去<a href="https://hstspreload.org/" target="_blank" rel="noopener">HSTS Preload List</a>的网站把我们的域名进行检查并收录（不能是子域名，必须是一级域名），如果没通过会给出修改建议，按照建议修改就行。如果通过了，就会放入审核列表。之后可以时不时回来看看自己的网站被收录了没有。我是等了快一周才被收录。网上的说法普遍是几周内。所以耐心等待收录。一旦被收录就会应用到主流浏览器上，这样你的网站就是更加安全的网站啦。</p><p><img src="https://ws1.sinaimg.cn/large/8700af19gy1fi45hvxt3oj21fu0f8gn5.jpg" alt="HSTS Preload List"></p><h2 id="记录总结"><a href="#记录总结" class="headerlink" title="记录总结"></a>记录总结</h2><p>至此，我的博客迁移工作就做完了。用的因为是<code>Cloudflare</code>的cdn加速，所以在国外访问速度很快，在国内访问的速度会稍慢一些。不过也无伤大雅。最关键的是通过上述的办法，让我的博客能够实现持久化构建，加上了HTTPS的小绿锁，并且成功加入HSTS的Preload List，还是比较满意。</p><p><img src="https://ws1.sinaimg.cn/large/8700af19gy1fi45ityzzrj20yo01smxb.jpg" alt="HTTPS"></p><p>最后由衷感谢GitHub+Travis-CI+Cloudflare提供的这么优质的服务。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;过一段时间博客的主机要到期了。我看了一下才发现，主机上其实我也只是放着我hexo的静态博客而已。觉得每个月要交几十块钱其实并不值当，遂决定把hexo博客从云主机上转移出来到github-page上。&lt;/p&gt;&lt;p&gt;本文主要记录如何运用&lt;code&gt;Travis-CI&lt;/code&gt;对hexo博客进行持久化构建，以及通过&lt;code&gt;Cloudflare&lt;/code&gt;给自有域名的github-page加上&lt;code&gt;https&lt;/code&gt;。&lt;strong&gt;文末给出如何将自己的博客加入&lt;code&gt;HSTS&lt;/code&gt;网站列表。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="hexo" scheme="https://molunerfinn.com/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://molunerfinn.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Vue组件的三种调用方式</title>
    <link href="https://molunerfinn.com/vue-components/"/>
    <id>https://molunerfinn.com/vue-components/</id>
    <published>2017-06-15T14:23:00.000Z</published>
    <updated>2018-04-27T08:26:51.717Z</updated>
    
    <content type="html"><![CDATA[<p>最近在写<a href="https://fj.teamsz.xyz" target="_blank" rel="noopener">fj-service-system</a>的时候，遇到了一些问题。那就是我有些组件，比如<code>Dialog</code>、<code>Message</code>这样的组件，是引入三方组件库，比如<code>element-ui</code>这样的，还是自己实现一个？虽然它们有按需引入的功能，但是整体风格和我的整个系统不搭。于是就可以考虑自己手动实现这些简单的组件了。</p><a id="more"></a><p>通常我们看Vue的一些文章的时候，我们能看到的通常是讲Vue单文件组件化开发页面的。单一组件开发的文章相对就较少了。我在做<a href="https://fj.teamsz.xyz" target="_blank" rel="noopener">fj-service-system</a>项目的时候，发现其实单一组件开发也是很有意思的。可以写写记录下来。因为写的不是什么ui框架，所以也只是一个记录，没有github仓库，权且看代码吧。</p><p>主要讲三种方式调用组件：</p><ul><li><code>v-model</code>或者<code>.sync</code>显式控制组件显示隐藏</li><li>通过js代码调用</li><li>通过Vue指令调用</li></ul><p>在写组件的时候很多写法、灵感来自于<a href="https://github.com/ElemeFE/element" target="_blank" rel="noopener">element-ui</a>，感谢。</p><h3 id="Dialog"><a href="#Dialog" class="headerlink" title="Dialog"></a>Dialog</h3><p>我习惯把这个东西叫做对话框，实际上还有叫做modal(弹窗)组件的<a href="https://www.zhihu.com/question/35820643" target="_blank" rel="noopener">叫法</a>。其实就是在页面里，弹出一个小窗口，这个小窗口里的内容可以定制。通常可以用来做登录功能的对话框。</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fgoih3m6apg20kw0do4pv.gif" alt="dialog"></p><p>这种组件就很适合通过<code>v-model</code>或者<code>.sync</code>的方式来显式的控制出现和消失。它可以直接写在页面里，然后通过data去控制——这也是最符合Vue的设计思路的组件。</p><p>为此我们可以写一个组件就叫做<code>Dialog.vue</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"dialog"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"dialog__wrapper"</span> <span class="attr">v-if</span>=<span class="string">"visble"</span> @<span class="attr">clcik</span>=<span class="string">"closeModal"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"dialog"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"dialog__header"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"dialog__title"</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"dialog__body"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"dialog__footer"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"footer"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"modal"</span> <span class="attr">v-show</span>=<span class="string">"visible"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    name: <span class="string">'dialog'</span>,</span></span><br><span class="line"><span class="undefined">    props: &#123;</span></span><br><span class="line"><span class="javascript">      title: <span class="built_in">String</span>,</span></span><br><span class="line"><span class="undefined">      visible: &#123;</span></span><br><span class="line"><span class="javascript">        type: <span class="built_in">Boolean</span>,</span></span><br><span class="line"><span class="javascript">        <span class="keyword">default</span>: <span class="literal">false</span></span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="undefined">    methods: &#123;</span></span><br><span class="line"><span class="undefined">      close() &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.$emit(<span class="string">'update:visible'</span>, <span class="literal">false</span>) <span class="comment">// 传递关闭事件</span></span></span><br><span class="line"><span class="undefined">      &#125;,</span></span><br><span class="line"><span class="undefined">      closeModal(e) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (<span class="keyword">this</span>.visible) &#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">document</span>.querySelector(<span class="string">'.dialog'</span>).contains(e.target) ? <span class="string">''</span> : <span class="keyword">this</span>.close(); <span class="comment">// 判断点击的落点在不在dialog对话框内，如果在对话框外就调用this.close()方法关闭对话框</span></span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>CSS什么的就不写了，跟组件本身关系比较小。不过值得注意的是，上面的<code>dialog__wrapper</code>这个class也是全屏的，透明的，主要用于获取点击事件并锁定点击的位置，通过DOM的<code>Node.contains()</code>方法来判断点击的位置是不是dialog本身，如果是点击到了dialog外面，比如半透明的<code>modal</code>层那么就派发关闭事件，把dialog给关闭掉。</p><p>当我们在外部要调用的时候，就可以如下调用：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"xxx"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dialog</span> <span class="attr">:visible.sync</span>=<span class="string">"visible"</span>&gt;</span><span class="tag">&lt;/<span class="name">dialog</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"openDialog"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> Dialog <span class="keyword">from</span> <span class="string">'Dialog'</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="undefined">    components: &#123;</span></span><br><span class="line"><span class="undefined">      Dialog</span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="undefined">    data() &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">        visible: <span class="literal">false</span></span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="undefined">    methods: &#123;</span></span><br><span class="line"><span class="undefined">      openDialog() &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.visible = <span class="literal">true</span> <span class="comment">// 通过data显式控制dialog</span></span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>为了Dialog开启和关闭好看点，你可试着加上<code>&lt;transition&gt;&lt;/transition&gt;</code>组件配合上过渡效果，简单的一点过渡动效也将会很好看。</p><h3 id="Notice"><a href="#Notice" class="headerlink" title="Notice"></a>Notice</h3><p>这个组件类似于<code>element-ui</code>的<a href="http://element.eleme.io/#/zh-CN/component/message" target="_blank" rel="noopener">message</a>（消息提示）。它吸引我的最大的地方在于，它不是通过显式的在页面里写好组件的html结构通过v-model去调用的，而是通过在js里通过形如<code>this.$message()</code>这样的方法调用的。这种方法虽然跟Vue的数据驱动的思想有所违背。不过不得不说在某些情况下真的特别方便。</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fgoiiwtkymg20ju07m46t.gif" alt="notice"></p><p>对于Notice这种组件，一次只要提示几个文字，给用户简单的消息提示就行了。提示的信息可能是多变的，甚至可以出现叠加的提示。如果通过第一种方式去调用，事先就得写好html结构，这无疑是麻烦的做法，而且无法预知有多少消息提示框。而通过js的方法调用的话，只需要考虑不同情况调用的文字、类型不同就可以了。</p><p>而之前的做法都是写一个Vue文件，然后通过<code>components</code>属性引入页面，显式写入标签调用的。那么如何将组件通过js的方法去调用呢？</p><p>这里的关键是Vue的<code>extend</code><a href="https://vuejs.org/v2/api/#Vue-extend" target="_blank" rel="noopener">方法</a>。</p><p>文档里并没有详细给出<code>extend</code>能这么用，只是作为需要手动<code>mount</code>的一个Vue的组件构造器说明了一下而已。</p><p>通过查看<code>element-ui</code>的源码，才算是理解了如何实现上述的功能。</p><p>首先依然是创建一个<code>Notice.vue</code>的文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"notice"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">      &#123;&#123; content &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    name: <span class="string">'notice'</span>,</span></span><br><span class="line"><span class="undefined">    data () &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">        visible: <span class="literal">false</span>,</span></span><br><span class="line"><span class="javascript">        content: <span class="string">''</span>,</span></span><br><span class="line"><span class="undefined">        duration: 3000</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="undefined">    methods: &#123;</span></span><br><span class="line"><span class="undefined">      setTimer() &#123;</span></span><br><span class="line"><span class="javascript">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">this</span>.close() <span class="comment">// 3000ms之后调用关闭方法</span></span></span><br><span class="line"><span class="javascript">        &#125;, <span class="keyword">this</span>.duration)</span></span><br><span class="line"><span class="undefined">      &#125;,</span></span><br><span class="line"><span class="undefined">      close() &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.visible = <span class="literal">false</span></span></span><br><span class="line"><span class="javascript">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">this</span>.$destroy(<span class="literal">true</span>)</span></span><br><span class="line"><span class="javascript">          <span class="keyword">this</span>.$el.parentNode.removeChild(<span class="keyword">this</span>.$el) <span class="comment">// 从DOM里将这个组件移除</span></span></span><br><span class="line"><span class="undefined">        &#125;, 500)</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="undefined">    mounted() &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.setTimer() <span class="comment">// 挂载的时候就开始计时，3000ms后消失</span></span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面写的东西跟普通的一个单文件Vue组件没有什么太大的区别。不过区别就在于，没有props了，那么是如何通过外部来控制这个组件的显隐呢？</p><p>所以还需要一个js文件来接管这个组件，并调用<code>extend</code>方法。同目录下可以创建一个<code>index.js</code>的文件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> NoticeConstructor = Vue.extend(<span class="built_in">require</span>(<span class="string">'./Notice.vue'</span>)) <span class="comment">// 直接将Vue组件作为Vue.extend的参数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> nId = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Notice = <span class="function">(<span class="params">content</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> id = <span class="string">'notice-'</span> + nId++</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> NoticeInstance = <span class="keyword">new</span> NoticeConstructor(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">      content: content</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;) <span class="comment">// 实例化一个带有content内容的Notice</span></span><br><span class="line"></span><br><span class="line">  NoticeInstance.id = id</span><br><span class="line">  NoticeInstance.vm = NoticeInstance.$mount() <span class="comment">// 挂载但是并未插入dom，是一个完整的Vue实例</span></span><br><span class="line">  NoticeInstance.vm.visible = <span class="literal">true</span></span><br><span class="line">  NoticeInstance.dom = NoticeInstance.vm.$el</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(NoticeInstance.dom) <span class="comment">// 将dom插入body</span></span><br><span class="line">  NoticeInstance.dom.style.zIndex = nId + <span class="number">1001</span> <span class="comment">// 后插入的Notice组件z-index加一，保证能盖在之前的上面</span></span><br><span class="line">  <span class="keyword">return</span> NoticeInstance.vm</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  install: <span class="function"><span class="params">Vue</span> =&gt;</span> &#123;</span><br><span class="line">    Vue.prototype.$notice = Notice <span class="comment">// 将Notice组件暴露出去，并挂载在Vue的prototype上</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个文件里我们能看到通过<code>NoticeConstructor</code>我们能够通过js的方式去控制一个组件的各种属性。最后我们把它注册进Vue的prototype上，这样我们就可以在页面内部使用形如<code>this.$notice()</code>方法了，可以方便调用这个组件来写做出简单的通知提示效果了。</p><p>当然别忘了这个相当于一个Vue的插件，所以需要去主js里调用一下<code>Vue.use()</code>方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">import</span> Notice <span class="keyword">from</span> <span class="string">'notice/index.js'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Notice)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><h3 id="Loading"><a href="#Loading" class="headerlink" title="Loading"></a>Loading</h3><p>在看<code>element-ui</code>的时候，我也发现了一个很有意思的组件，是<code>Loading</code>，用于给一些需要加载数据等待的组件套上一层加载中的样式的。这个loading的调用方式，最方便的就是通过<code>v-loading</code>这个指令，通过赋值的<code>true/false</code>来控制Loading层的显隐。这样的调用方法当然也是很方便的。而且可以选择整个页面Loading或者某个组件Loading。这样的开发体验自然是很好的。</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fgoija6xrkg20k6082js0.gif" alt="loading"></p><p>其实跟Notice的思路差不多，不过因为涉及到<code>directive</code>，所以在逻辑上会相对复杂一点。</p><p>平时如果不涉及Vue的<code>directive</code>的开发，可能是不会接触到<code>modifiers</code>、<code>binding</code>等概念。参考<a href="https://vuejs.org/v2/guide/custom-directive.html" target="_blank" rel="noopener">文档</a></p><p>简单说下，形如<code>:v-loading.fullscreen=&quot;true&quot;</code>这句话，<code>v-loading</code>就是<code>directive</code>，<code>fullscreen</code>就是它的<code>modifier</code>，<code>true</code>就是<code>binding</code>的<code>value</code>值。所以，就是通过这样简单的一句话实现全屏的loading效果，并且当没有<code>fullscreen</code>修饰符的时候就是对拥有该指令的元素进行<code>loading</code>效果。组件通过<code>binding</code>的<code>value</code>值来控制<code>loading</code>的开启和关闭。（类似于<code>v-model</code>的效果）</p><p>其实loading也是一个实际的DOM节点，只不过要把它做成一个方便的指令还不是特别容易。</p><p>首先我们需要写一下<code>loading</code>的Vue组件。新建一个<code>Loading.vue</code>文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">transition</span></span></span><br><span class="line"><span class="tag">    <span class="attr">name</span>=<span class="string">"loading"</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">after-leave</span>=<span class="string">"handleAfterLeave"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">      <span class="attr">v-show</span>=<span class="string">"visible"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"loading-mask"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">:class</span>=<span class="string">&#123;</span>'<span class="attr">fullscreen</span>'<span class="attr">:</span> <span class="attr">fullscreen</span>&#125;&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"loading"</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"loading-text"</span> <span class="attr">v-if</span>=<span class="string">"text"</span>&gt;</span></span><br><span class="line">        &#123;&#123; text &#125;&#125;</span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  name: <span class="string">'loading'</span>,</span></span><br><span class="line"><span class="undefined">  data () &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      visible: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">      fullscreen: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">      text: <span class="literal">null</span></span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;,</span></span><br><span class="line"><span class="undefined">  methods: &#123;</span></span><br><span class="line"><span class="undefined">    handleAfterLeave() &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.$emit(<span class="string">'after-leave'</span>);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css"><span class="selector-class">.loading-mask</span>&#123;</span></span><br><span class="line"><span class="undefined">  position: absolute; // 非全屏模式下，position是absolute</span></span><br><span class="line"><span class="undefined">  z-index: 10000;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">background-color</span>: <span class="selector-tag">rgba</span>(255,235,215, <span class="selector-class">.8</span>);</span></span><br><span class="line"><span class="undefined">  margin: 0;</span></span><br><span class="line"><span class="undefined">  top: 0;</span></span><br><span class="line"><span class="undefined">  right: 0;</span></span><br><span class="line"><span class="undefined">  bottom: 0;</span></span><br><span class="line"><span class="undefined">  left: 0;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">transition</span>: <span class="selector-tag">opacity</span> <span class="selector-class">.3s</span>;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.loading-mask</span><span class="selector-class">.fullscreen</span>&#123;</span></span><br><span class="line"><span class="undefined">  position: fixed; // 全屏模式下，position是fixed</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">// ...</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Loading关键是实现两个效果：</p><ol><li>全屏loading，此时可以通过插入body下，然后将Loading的position改为fixed，插入body实现。</li><li>对所在的元素进行loading，此时需要对当前这个元素的的position修改：如果不是<code>absolute</code>的话，就将其修改为<code>relatvie</code>，并插入当前元素下。此时Loading的position就会相对于当前元素进行绝对定位了。</li></ol><p>所以在当前目录下创建一个<code>index.js</code>的文件，用来声明我们的<code>directive</code>的逻辑。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">const</span> LoadingConstructor = Vue.extend(<span class="built_in">require</span>(<span class="string">'./Loading.vue'</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  install: <span class="function"><span class="params">Vue</span> =&gt;</span> &#123;</span><br><span class="line">    Vue.directive(<span class="string">'loading'</span>, &#123; <span class="comment">// 指令的关键</span></span><br><span class="line">      bind: <span class="function">(<span class="params">el, binding</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> loading = <span class="keyword">new</span> LoadingConstructor(&#123; <span class="comment">// 实例化一个loading</span></span><br><span class="line">          el: <span class="built_in">document</span>.createElement(<span class="string">'div'</span>),</span><br><span class="line">          data: &#123;</span><br><span class="line">            text: el.getAttribute(<span class="string">'loading-text'</span>), <span class="comment">// 通过loading-text属性获取loading的文字</span></span><br><span class="line">            fullscreen: !!binding.modifiers.fullscreen </span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        el.instance = loading; <span class="comment">// el.instance是个Vue实例</span></span><br><span class="line">        el.loading = loading.$el; <span class="comment">// el.loading的DOM元素是loading.$el</span></span><br><span class="line">        el.loadingStyle = &#123;&#125;;</span><br><span class="line">        toggleLoading(el, binding);</span><br><span class="line">      &#125;,</span><br><span class="line">      update: <span class="function">(<span class="params">el, binding</span>) =&gt;</span> &#123;</span><br><span class="line">        el.instance.setText(el.getAttribute(<span class="string">'loading-text'</span>))</span><br><span class="line">        <span class="keyword">if</span>(binding.oldValue !== binding.value) &#123;</span><br><span class="line">          toggleLoading(el, binding)</span><br><span class="line">        &#125;   </span><br><span class="line">      &#125;,</span><br><span class="line">      unbind: <span class="function">(<span class="params">el, binding</span>) =&gt;</span> &#123; <span class="comment">// 解绑</span></span><br><span class="line">        <span class="keyword">if</span>(el.domInserted) &#123;</span><br><span class="line">          <span class="keyword">if</span>(binding.modifiers.fullscreen) &#123;</span><br><span class="line">              <span class="built_in">document</span>.body.removeChild(el.loading);</span><br><span class="line">          &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            el.loading &amp;&amp;</span><br><span class="line">            el.loading.parentNode &amp;&amp;</span><br><span class="line">            el.loading.parentNode.removeChild(el.loading);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> toggleLoading = <span class="function">(<span class="params">el, binding</span>) =&gt;</span> &#123; <span class="comment">// 用于控制Loading的出现与消失</span></span><br><span class="line">      <span class="keyword">if</span>(binding.value) &#123; </span><br><span class="line">        Vue.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (binding.modifiers.fullscreen) &#123; <span class="comment">// 如果是全屏</span></span><br><span class="line">            el.originalPosition = <span class="built_in">document</span>.body.style.position;</span><br><span class="line">            el.originalOverflow = <span class="built_in">document</span>.body.style.overflow;</span><br><span class="line">            insertDom(<span class="built_in">document</span>.body, el, binding); <span class="comment">// 插入dom</span></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            el.originalPosition = el.style.position;</span><br><span class="line">            insertDom(el, el, binding); <span class="comment">// 如果非全屏，插入元素自身</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (el.domVisible) &#123;</span><br><span class="line">          el.instance.$on(<span class="string">'after-leave'</span>, () =&gt; &#123;</span><br><span class="line">            el.domVisible = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (binding.modifiers.fullscreen &amp;&amp; el.originalOverflow !== <span class="string">'hidden'</span>) &#123;</span><br><span class="line">              <span class="built_in">document</span>.body.style.overflow = el.originalOverflow;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binding.modifiers.fullscreen) &#123;</span><br><span class="line">              <span class="built_in">document</span>.body.style.position = el.originalPosition;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              el.style.position = el.originalPosition;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">          el.instance.visible = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> insertDom = <span class="function">(<span class="params">parent, el, binding</span>) =&gt;</span> &#123; <span class="comment">// 插入dom的逻辑</span></span><br><span class="line">      <span class="keyword">if</span>(!el.domVisible) &#123;</span><br><span class="line">        <span class="built_in">Object</span>.keys(el.loadingStyle).forEach(<span class="function"><span class="params">property</span> =&gt;</span> &#123;</span><br><span class="line">          el.loading.style[property] = el.loadingStyle[property];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span>(el.originalPosition !== <span class="string">'absolute'</span>) &#123;</span><br><span class="line">          parent.style.position = <span class="string">'relative'</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (binding.modifiers.fullscreen) &#123;</span><br><span class="line">          parent.style.overflow = <span class="string">'hidden'</span></span><br><span class="line">        &#125;</span><br><span class="line">        el.domVisible = <span class="literal">true</span>;</span><br><span class="line">        parent.appendChild(el.loading) <span class="comment">// 插入的是el.loading而不是el本身</span></span><br><span class="line">        Vue.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          el.instance.visible = <span class="literal">true</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        el.domInserted = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，写完整个逻辑，我们需要将其注册到项目里的Vue下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">import</span> Loading <span class="keyword">from</span> <span class="string">'loading/index.js'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Loading)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>至此我们已经可以使用形如</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-loading.fullscreen</span>=<span class="string">"loading"</span> <span class="attr">loading-text</span>=<span class="string">"正在加载中"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样的方式来实现调用一个loading组件了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在用Vue写我们的项目的时候，不管是写页面还是写形如这样的功能型组件，其实都是一件很有意思的事情。本文介绍的三种调用组件的方式，也是根据实际情况出发而实际操作、实现的。不同的组件通过不同的方式去调用，方便了开发人员，也能更好地对代码进行维护。当然也许还有其他的方式，我并没有了解，也欢迎大家在评论里指出！</p><p>最后再次感谢<a href="https://github.com/ElemeFE/element" target="_blank" rel="noopener">element-ui</a>的源码给予的极大启发。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在写&lt;a href=&quot;https://fj.teamsz.xyz&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;fj-service-system&lt;/a&gt;的时候，遇到了一些问题。那就是我有些组件，比如&lt;code&gt;Dialog&lt;/code&gt;、&lt;code&gt;Message&lt;/code&gt;这样的组件，是引入三方组件库，比如&lt;code&gt;element-ui&lt;/code&gt;这样的，还是自己实现一个？虽然它们有按需引入的功能，但是整体风格和我的整个系统不搭。于是就可以考虑自己手动实现这些简单的组件了。&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="https://molunerfinn.com/categories/Web/"/>
    
      <category term="开发" scheme="https://molunerfinn.com/categories/Web/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="前端" scheme="https://molunerfinn.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Vue" scheme="https://molunerfinn.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vuejs项目的Webpack2构建优化</title>
    <link href="https://molunerfinn.com/Webpack-Optimize/"/>
    <id>https://molunerfinn.com/Webpack-Optimize/</id>
    <published>2017-05-25T11:35:00.000Z</published>
    <updated>2018-04-27T08:26:51.713Z</updated>
    
    <content type="html"><![CDATA[<p>最近在做的项目因为相对较大（打包有100多个chunk），在build构建的时候速度一直上不去，甚是烦恼。由于用的是<code>vue-cli</code>的<code>webpack2</code>模板，一开始并没有想着要对其进行优化，一直觉得是webpack本身慢+硬件慢（在开发机上开发，内存和CPU都不是很强力）的原因。后来慢到实在受不了了，转移到本地（i7+16G）开发的时候，发现生产构建居然需要90s，实在太长了。所以开始着手Webpack2构建优化。</p><a id="more"></a><p>优化webpack构建速度，总的来说有几个思路：</p><ol><li>优化本身项目结构，模块的引入、拆分、共用</li><li>优化结构路径、让webpack接管的文件能够快速定位</li><li>优化uglify编译速度</li><li>优化webpack本身编译速度</li></ol><p>有些是在开发的时候代码层面上的，有些则是需要在webpack配置层面上的。对于开发层面上来说，按需引入是很重要的一点。通常为了方便我们可以直接引入一个<code>echarts</code>，但是实际上并不需要<code>echarts</code>的所有功能。而按需引入则能最大程度上让</p><p>总得来说作用最大的有这几个：</p><ul><li>开启<code>webpack</code>的cache</li><li>开启<code>babel-loader</code>的cache</li><li>指定<code>modules</code>以及配置项目相关的<code>alias</code></li><li>配置<code>loader</code>的<code>include</code>和<code>exclude</code></li><li>用<code>CommonsChunkPlugin</code>提取公用模块</li><li>使用<code>DllPlugin</code>和<code>DllReferencePlugin</code>预编译</li><li>换用<code>happypack</code>多进程构建</li><li><code>css-loader</code>换成<code>0.14.5</code>版本。</li><li>换用<code>webpack-uglify-parallel</code>并行压缩代码</li></ul><p>以下的配置都是基于<code>vue-cli</code>的<code>webpack</code>模板进行的优化。</p><h3 id="开启webpack的cache"><a href="#开启webpack的cache" class="headerlink" title="开启webpack的cache"></a>开启webpack的cache</h3><p>打开<code>webpack.base.conf.js</code>，在<code>module.exports</code>里加上<code>cache: true</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  cache: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// ... 其他配置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="开启babel-loader的cache"><a href="#开启babel-loader的cache" class="headerlink" title="开启babel-loader的cache"></a>开启<code>babel-loader</code>的cache</h3><p>开启了cache的<code>babel-loader</code>，在下次编译的时候，遇到不变的部分可以直接拿取cache里的内容，能够较为明显地提高构建速度。在<code>loader</code>选项里只需要对<code>babel-loader</code>开启<code>cacheDirectory=true</code>即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... 其他配置</span></span><br><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      loader: [<span class="string">'babel-loader?cacheDirectory=true'</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// ... 其他loader</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置modules以及配置项目相关的alias"><a href="#配置modules以及配置项目相关的alias" class="headerlink" title="配置modules以及配置项目相关的alias"></a>配置<code>modules</code>以及配置项目相关的<code>alias</code></h3><p>这个部分的配置实际上都是对webpack接管的文件路径的一些配置。通过这些配置，webpack可以不必自己遍历去搜索模块等，而可以通过我们定义的路径，快速定位。尤其是<code>node_modules</code>的位置，这个位置可以通过<code>modules</code>选项配置，节省webpack去查找的时间。</p><p>而<code>alias</code>是别名。通过编写<code>alias</code>，既能让webpack查找文件定位更快，在开发的时候，也能少些很多相对路径的<code>../..</code>，在引入模块的时候很方便。</p><p>同样是打开<code>webpack.base.conf.js</code>，在<code>module.exports</code>的<code>resolve</code>属性里配置<code>modules</code>和<code>alias</code>。其中<code>vue-cli</code>会自动配置一些默认的<code>alias</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">  <span class="comment">//... 其他配置</span></span><br><span class="line">  modules: [path.resolve(__dirname, <span class="string">'../../node_modules'</span>)], <span class="comment">// node_modules文件夹所在的位置取决于跟webpack.base.conf.js相对的路径</span></span><br><span class="line">  alias: &#123;</span><br><span class="line">    <span class="comment">//... 其他配置</span></span><br><span class="line">    api: path.resolve(__dirname, <span class="string">'../../server/api'</span>) <span class="comment">// api文件所在的位置取决于跟webpack.base.conf.js相对的路径，在项目中会自动转换跟项目文件的相对路径</span></span><br><span class="line">    <span class="comment">//... 其他配置</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果配置了如上的<code>alias</code>，那么我们在项目里，要引用比如<code>api.js</code>这个模块，可以直接这样做了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> api <span class="keyword">from</span> <span class="string">'api'</span> <span class="comment">// 'api'是个alias，webpack会直接去找`server/api`</span></span><br></pre></td></tr></table></figure><p>而不用手动去根据项目文件和api所在路径的相对位置去书写import的路径了。</p><h3 id="配置loader的include和exclude"><a href="#配置loader的include和exclude" class="headerlink" title="配置loader的include和exclude"></a>配置<code>loader</code>的<code>include</code>和<code>exclude</code></h3><p><code>loader</code>的<code>include</code>和<code>exclude</code>也就是需要<code>loader</code>接管编译的文件和不需要<code>loader</code>接管编译的文件。</p><p>这里我们举<code>babel-loader</code>为例。通常情况下，我们不需要<code>loader</code>去编译<code>node_modules</code>下的js文件，而我们只需要编译我们项目目录下的<code>js</code>就行了。这样可以通过配置这两个选项，能够最小范围的限制<code>babel-loader</code>需要编译的内容，能够有效提升构建速度。</p><p>同样打开<code>webpack.base.conf.js</code>，在<code>rules</code>的<code>babel-loader</code>那块加上<code>include</code>和<code>exclude</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... 其他配置</span></span><br><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      loader: [<span class="string">'babel-loader?cacheDirectory=true'</span>],</span><br><span class="line">      include: [resolve(<span class="string">'src'</span>)], <span class="comment">// src是项目开发的目录</span></span><br><span class="line">      exclude: [path.resolve(<span class="string">'../../node_modules'</span>)] <span class="comment">// 不需要编译node_modules下的js </span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// ... 其他loader</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用CommonsChunkPlugin提取公用模块"><a href="#使用CommonsChunkPlugin提取公用模块" class="headerlink" title="使用CommonsChunkPlugin提取公用模块"></a>使用<code>CommonsChunkPlugin</code>提取公用模块</h3><p>我们经常会有这种场景：在<code>a.vue</code>组件里引入了<code>a.js</code>或者比如<code>c.vue</code>，在<code>b.vue</code>组件里也引入了<code>a.js</code>或者<code>c.vue</code>。这样，打包了之后将会把引入的模块重复打包。而<code>CommonsChuncksPlugin</code>就是把这样重复打包的模块给抽取出来单独打包的插件。这个能够显著降低最后打包的体积，也能提升一些打包速度。</p><p>在<code>webpack.base.conf.js</code>里的<code>plugins</code>可以加上这段：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">    <span class="keyword">async</span>: <span class="string">'shared-module'</span>,</span><br><span class="line">    minChunks: <span class="function">(<span class="params"><span class="built_in">module</span>, count</span>) =&gt;</span> (</span><br><span class="line">      count &gt;= <span class="number">2</span>    <span class="comment">// 当一个模块被重复引用2次或以上的时候单独打包起来。 </span></span><br><span class="line">    )</span><br><span class="line">  &#125;),</span><br><span class="line"></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="使用DllPlugin和DllReferencePlugin预编译"><a href="#使用DllPlugin和DllReferencePlugin预编译" class="headerlink" title="使用DllPlugin和DllReferencePlugin预编译"></a>使用<code>DllPlugin</code>和<code>DllReferencePlugin</code>预编译</h3><p>这个也是一个大杀器。将一些全局都要用到的依赖抽离出来，预编译一遍，然后引入项目中，作为依赖项。而webpack在正式编译的时候就可以放过他们了。能够很明显地提升webpack的构建速度。类似于Windows的<code>dll</code>文件的设计理念。dll资源能够有效的解决资源循环依赖的问题。能够大大减少项目里重复依赖的问题。</p><p>在<code>webpack.base.conf.js</code>所在的文件夹里建立一个<code>webpack.dll.conf.js</code>，我们将一些常用的依赖打包成<code>dll</code>。</p><p>首先配置一下<code>DllPlugin</code>的资源列表。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    vendor: [<span class="string">'vue/dist/vue.esm.js'</span>,<span class="string">'vue-router'</span>,<span class="string">'axios'</span>,<span class="string">'vuex'</span>] <span class="comment">// 需要打包起来的依赖</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.join(__dirname, <span class="string">'../../public/js'</span>), <span class="comment">// 输出的路径</span></span><br><span class="line">    filename: <span class="string">'[name].dll.js'</span>, <span class="comment">// 输出的文件，将会根据entry命名为vendor.dll.js</span></span><br><span class="line">    library: <span class="string">'[name]_library'</span> <span class="comment">// 暴露出的全局变量名</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.DllPlugin(&#123;</span><br><span class="line">      path: path.join(__dirname, <span class="string">'../../public/js/'</span>, <span class="string">'[name]-mainfest.json'</span>), <span class="comment">// 描述依赖对应关系的json文件</span></span><br><span class="line">      name: <span class="string">'[name]_library'</span>, </span><br><span class="line">      context: __dirname <span class="comment">// 执行的上下文环境，对之后DllReferencePlugin有用</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin(&#123; <span class="comment">// uglifjs压缩</span></span><br><span class="line">      compress: &#123;</span><br><span class="line">        warnings: <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了方便之后构建，可以在<code>package.json</code>里加上这么一句<code>scripts</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scripts: &#123;</span><br><span class="line">  <span class="comment">//... 其他scripts</span></span><br><span class="line">  <span class="string">"build:dll"</span>: <span class="string">"webpack --config ./webpack/build/webpack.dll.conf.js"</span> <span class="comment">// 填写你项目中webpack.dll.conf.js的路径</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后执行一下<code>npm run build:dll</code>，就可以在输出的目录里输出一个<code>vendor.dll.js</code>和<code>vendor-mainfest.json</code>两个文件。</p><p>之后打开<code>webpack.base.conf.js</code>。在plugins一项里加上<code>DllReferencePlugin</code>。这个plugin是用于引入上一层里生成的json的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//... 其他配置</span></span><br><span class="line">  </span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// ... 其他插件</span></span><br><span class="line">    <span class="keyword">new</span> webpack.DllReferencePlugin(&#123;</span><br><span class="line">      context: __dirname,</span><br><span class="line">      manifest: <span class="built_in">require</span>(<span class="string">'../../public/js/vendor-mainfest.json'</span>) <span class="comment">// 指向这个json</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，在项目输出的<code>index.html</code>里，最先引入这个js：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"public/js/vendor.dll.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样，webpack将不会再解析dll里的资源了。构建速度将会有质的提高。</p><h3 id="换用happypack多进程构建"><a href="#换用happypack多进程构建" class="headerlink" title="换用happypack多进程构建"></a>换用<code>happypack</code>多进程构建</h3><p>webpack的构建毕竟还是单进程的。采用<code>happypack</code>可以改为多进程构建。而对于小文件而言，<code>happypack</code>效果并不明显。而对于<code>babel-loader</code>编译的庞大的js文件群来说，则是一大利器。</p><p>首先安装：<code>npm install happypack --save-dev</code>或者<code>yarn add happypack</code></p><p>然后修改<code>webpack.base.conf.js</code>的配置如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> os = <span class="built_in">require</span>(<span class="string">'os'</span>);</span><br><span class="line"><span class="keyword">const</span> HappyPack  = <span class="built_in">require</span>(<span class="string">'happypack'</span>);</span><br><span class="line"><span class="keyword">const</span> happThreadPool = HappyPack.ThreadPool(&#123;<span class="attr">size</span>: os.cpus().length&#125;); <span class="comment">// 采用多进程，进程数由CPU核数决定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line">      id: <span class="string">'js'</span>,</span><br><span class="line">      cache: <span class="literal">true</span>,</span><br><span class="line">      loaders: [<span class="string">'babel-loader?cacheDirectory=true'</span>],</span><br><span class="line">      threadPool: happThreadPool</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">        loader: <span class="string">'vue-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          loaders: &#123;</span><br><span class="line">            js: <span class="string">'happypack/loader?id=js'</span> <span class="comment">// 将loader换成happypack</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        loader: [<span class="string">'happypack/loader?id=js'</span>], <span class="comment">// 将loader换成happypack</span></span><br><span class="line">        include: [resolve(<span class="string">'src'</span>)], <span class="comment">// src是项目开发的目录</span></span><br><span class="line">        exclude: [path.resolve(<span class="string">'../../node_modules'</span>)] <span class="comment">// 不需要编译node_modules下的js </span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提速还是比较明显的。</p><h3 id="css-loader换成0-14-5版本"><a href="#css-loader换成0-14-5版本" class="headerlink" title="css-loader换成0.14.5版本"></a><code>css-loader</code>换成<code>0.14.5</code>版本</h3><p>可以查看这个<a href="https://github.com/webpack-contrib/css-loader/issues/124" target="_blank" rel="noopener">issue</a>，说是该版本之上的版本会拖慢webpack的构建速度。我自己实验了之后确实能快几秒钟。</p><h3 id="换用webpack-uglify-parallel并行压缩代码"><a href="#换用webpack-uglify-parallel并行压缩代码" class="headerlink" title="换用webpack-uglify-parallel并行压缩代码"></a>换用<code>webpack-uglify-parallel</code>并行压缩代码</h3><p>webpack自带的uglifyjs插件效果确实不错。只不过由于受限于单线程，所以压缩速度不够高。换成<code>webpack-uglify-parallel</code>这个插件之后能够有效减少压缩的时间。</p><p>首先安装：<code>npm install webpack-uglify-parallel --save-dev</code> 或者 <code>yarn add webpack-uglify-parallel</code></p><p>找到<code>webpack.prod.conf.js</code>（由于开发模式不需要进行uglify压缩），将原本的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin(&#123;</span><br><span class="line">    compress: &#123;</span><br><span class="line">      warnings: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    sourceMap: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// ... 其他配置</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>替换为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> UglifyJsparallelPlugin = <span class="built_in">require</span>(<span class="string">'webpack-uglify-parallel'</span>);</span><br><span class="line"><span class="keyword">const</span> os = <span class="built_in">require</span>(<span class="string">'os'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 其他配置</span></span><br><span class="line">plugins: []</span><br><span class="line"><span class="keyword">new</span> UglifyJsparallelPlugin(&#123;</span><br><span class="line">  workers: os.cpus().length,</span><br><span class="line">  mangle: <span class="literal">true</span>,</span><br><span class="line">  compressor: &#123;</span><br><span class="line">    warnings: <span class="literal">false</span>,</span><br><span class="line">    drop_console: <span class="literal">true</span>,</span><br><span class="line">    drop_debugger: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><hr><h3 id="效果综述"><a href="#效果综述" class="headerlink" title="效果综述"></a>效果综述</h3><p>经过以上优化，原本90+s的构建时间，优化到30+秒效果还是很明显的。原本HMR模式初始化需要50+秒，也优化到了20+秒的程度。不过，还是有一个至今我自己还无法解决的问题，那就是HMR模式，rebuild时间会越来越长，直到超过初始化的20+秒。此时只能重新开关一次HMR模式。这一点我还无法找到具体原因是什么。不过，至少生产的构建时间得到了60%的优化，效果还是挺好的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在做的项目因为相对较大（打包有100多个chunk），在build构建的时候速度一直上不去，甚是烦恼。由于用的是&lt;code&gt;vue-cli&lt;/code&gt;的&lt;code&gt;webpack2&lt;/code&gt;模板，一开始并没有想着要对其进行优化，一直觉得是webpack本身慢+硬件慢（在开发机上开发，内存和CPU都不是很强力）的原因。后来慢到实在受不了了，转移到本地（i7+16G）开发的时候，发现生产构建居然需要90s，实在太长了。所以开始着手Webpack2构建优化。&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="https://molunerfinn.com/categories/Web/"/>
    
      <category term="开发" scheme="https://molunerfinn.com/categories/Web/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="前端" scheme="https://molunerfinn.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Webpack" scheme="https://molunerfinn.com/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>全栈开发实战：用Vue2+Koa1开发完整的前后端项目（更新Koa2）</title>
    <link href="https://molunerfinn.com/Vue+Koa/"/>
    <id>https://molunerfinn.com/Vue+Koa/</id>
    <published>2017-05-03T14:09:00.000Z</published>
    <updated>2018-04-27T08:26:51.713Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本文从一名新手的角度（默认对Vue有了解，对Koa或者Express有了解）出发，从0开始构建一个数据通过Koa提供API的形式获取，页面通过Vue渲染的完整的前端项目。可以了解到Vue构建单页面的一些知识以及前端路由的使用、Koa如何提供API接口，如何进行访问过滤（路由）、验证（JSON-WEB-TOKEN）以及Sequelize操作MySQL数据库的一些知识和技巧，希望能够作为一篇入门全栈开发的文章吧。</p><p><strong>更新</strong>：文末给出的github仓库已经更新Koa2版本。请使用Node.js v7.6.0及以上版本体验~</p><a id="more"></a><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>我曾经写过一篇<a href="https://molunerfinn.com/nodejs-2/">文章</a>，是用express和mongodb入门Nodejs的前后端开发，这篇文章里简单的做了一个小demo，能够让你读写mongodb数据库，并且从数据库里将数据读取出来显示到页面上。算是一个简单的读写小demo吧，也算是服务端渲染的一次初尝试。并且我还写过用nodejs写简单小爬虫的<a href="https://molunerfinn.com/nodejs-1/">文章</a>，用爬虫来获取数据写入数据库。通过以上的的方法我用express写了一个小网站，记录并显示北邮人论坛每天的十大的<a href="http://topten.piegg.cn" target="_blank" rel="noopener">内容</a>。挺好玩的对吧，可以把想要做的事用代码来实现。</p><p>后来我接触到了Koa，并开始了学习，从express迁移到Koa其实曲线还算是比较平滑的。不过用Koa的方式也还是采用服务端渲染页面的方式。而且我发现目前网络上少有写过用Koa构建的前后端分离的应用、网站文章，我最近做的一个项目里需要用到的方式就是用Vue构建页面，数据的获取全部走后端API的形式，也就是所谓的前后端分离吧。正好在这过程中走了不少的坑，包括数据库的使用上也算是个新手，所以写篇文章记录一下，用同样的思路和方法构建一个简单的Todolist，欢迎讨论，轻拍~</p><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── LICENSE</span><br><span class="line">├── README.md</span><br><span class="line">├── .env  // 环境变量配置文件</span><br><span class="line">├── app.js  // Koa入口文件</span><br><span class="line">├── build // vue-cli 生成，用于webpack监听、构建</span><br><span class="line">│   ├── build.js</span><br><span class="line">│   ├── check-versions.js</span><br><span class="line">│   ├── dev-client.js</span><br><span class="line">│   ├── dev-server.js</span><br><span class="line">│   ├── utils.js</span><br><span class="line">│   ├── webpack.base.conf.js</span><br><span class="line">│   ├── webpack.dev.conf.js</span><br><span class="line">│   └── webpack.prod.conf.js</span><br><span class="line">├── config // vue-cli 生成&amp;自己加的一些配置文件</span><br><span class="line">│   ├── default.conf</span><br><span class="line">│   ├── dev.env.js</span><br><span class="line">│   ├── index.js</span><br><span class="line">│   └── prod.env.js</span><br><span class="line">├── dist // Vue build 后的文件夹</span><br><span class="line">│   ├── index.html // 入口文件</span><br><span class="line">│   └── static // 静态资源</span><br><span class="line">├── index.html // vue-cli生成，用于容纳Vue组件的主html文件。单页应用就只有一个html</span><br><span class="line">├── package.json // npm的依赖、项目信息文件</span><br><span class="line">├── server // Koa后端，用于提供Api</span><br><span class="line">│   ├── config // 配置文件夹</span><br><span class="line">│   ├── controllers // controller-控制器</span><br><span class="line">│   ├── models // model-模型</span><br><span class="line">│   ├── routes // route-路由</span><br><span class="line">│   └── schema // schema-数据库表结构</span><br><span class="line">├── src // vue-cli 生成&amp;自己添加的utils工具类</span><br><span class="line">│   ├── App.vue // 主文件</span><br><span class="line">│   ├── assets // 相关静态资源存放</span><br><span class="line">│   ├── components // 单文件组件</span><br><span class="line">│   ├── main.js // 引入Vue等资源、挂载Vue的入口js</span><br><span class="line">│   └── utils // 工具文件夹-封装的可复用的方法、功能</span><br><span class="line">└── yarn.lock // 用yarn自动生成的lock文件</span><br></pre></td></tr></table></figure><p>看起来好像很复杂的样子，其实很大一部分文件夹的结构是<code>vue-cli</code>这个工具帮我们生成的。而我们需要额外添加的主要是Koa的入口文件以及一个<code>server</code>文件夹用于Koa提供API。这样的话，在获取数据的方面就可以走Koa所提供的API，而Vue只需关心怎么把这些数据渲染到页面上就好了。</p><h2 id="项目用到的一些关键依赖"><a href="#项目用到的一些关键依赖" class="headerlink" title="项目用到的一些关键依赖"></a>项目用到的一些关键依赖</h2><p>以下依赖的版本都是本文所写的时候的版本，或者更旧一些</p><ul><li>Vue.js(v2.1.8)</li><li>Vue-Router(v2.1.1)</li><li>Axios(v0.15.3)</li><li>Element(v1.1.2)</li><li>Koa.js(v1.2.4) // 没采用Koa2</li><li><a href="mailto:Koa-Router@5.4" target="_blank" rel="noopener">Koa-Router@5.4</a>\Koa-jwt\Koa-static等一系列Koa中间件</li><li>Mysql(v2.12.0) // nodejs的mysql驱动，并不是mysql本身版本（项目采用mysql5.6）</li><li>Sequelize(v3.28.0) // 操作数据库的ORM</li><li>Yarn(v0.18.1) // 比起npm更快一些</li></ul><p>剩下依赖可以参考本文最后给出的项目demo仓库。</p><h2 id="项目启动"><a href="#项目启动" class="headerlink" title="项目启动"></a>项目启动</h2><p>Nodejs与npm的安装不再叙述（希望大家装上的node版本大于等于6.x，不然还需要加上–harmony标志才可以开启es6），默认读者已经掌握npm安装依赖的方法。首先全局安装<code>npm i vue-cli -g</code>，当然本项目基本上是采用<code>yarn</code>，所以也可以<code>yarn global add vue-cli</code>。</p><blockquote><p>Tips: 可以给yarn换上淘宝源，速度更快: <code>yarn config set registry &quot;https://registry.npm.taobao.org&quot;</code></p></blockquote><p>然后我们初始化一个<code>Vue2的webpack</code>的模板：</p><p><code>vue init webpack demo</code></p><blockquote><p>Tips: 上面的demo可以填写你自己的项目名称</p></blockquote><p>然后进行一些基本配置选择之后，你就可以得到一个基本的<code>vue-cli</code>生成的项目结构。</p><p>接着我们进入<code>vue-cli</code>生成的目录，安装<code>Vue</code>的项目依赖并安装<code>Koa</code>的项目依赖：<code>yarn &amp;&amp; yarn add koa koa-router@5.4 koa-logger koa-json koa-bodyparser</code>，（注意是安装<code>koa-router</code>的5.4版，因为7.X版本是支持Koa2的）然后进行一些基本目录建立：</p><p>在<code>vue-cli</code>生成的<code>demo</code>目录下，建立<code>server</code>文件夹以及子文件夹：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">├── server // Koa后端，用于提供Api</span><br><span class="line">    ├── config // 配置文件夹</span><br><span class="line">    ├── controllers // controller-控制器</span><br><span class="line">    ├── models // model-模型</span><br><span class="line">    ├── routes // route-路由</span><br><span class="line">    └── schema // schema-数据库表结构</span><br></pre></td></tr></table></figure><p>然后在<code>demo</code>文件夹下我们创建一个<code>app.js</code>的文件，作为<code>Koa</code>的启动文件。</p><p>写入如下基本的内容就可以启动<code>Koa</code>啦：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="built_in">require</span>(<span class="string">'koa'</span>)()</span><br><span class="line">  , koa = <span class="built_in">require</span>(<span class="string">'koa-router'</span>)()</span><br><span class="line">  , json = <span class="built_in">require</span>(<span class="string">'koa-json'</span>)</span><br><span class="line">  , logger = <span class="built_in">require</span>(<span class="string">'koa-logger'</span>); <span class="comment">// 引入各种依赖</span></span><br><span class="line"></span><br><span class="line">app.use(<span class="built_in">require</span>(<span class="string">'koa-bodyparser'</span>)());</span><br><span class="line">app.use(json());</span><br><span class="line">app.use(logger());</span><br><span class="line"></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>* (<span class="params">next</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> start = <span class="keyword">new</span> <span class="built_in">Date</span>;</span><br><span class="line">  <span class="keyword">yield</span> next;</span><br><span class="line">  <span class="keyword">let</span> ms = <span class="keyword">new</span> <span class="built_in">Date</span> - start;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'%s %s - %s'</span>, <span class="keyword">this</span>.method, <span class="keyword">this</span>.url, ms); <span class="comment">// 显示执行的时间</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, ctx</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'server error'</span>, err);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8889</span>,() =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Koa is listening in 8889'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = app;</span><br></pre></td></tr></table></figure><p>然后在控制台输入<code>node app.js</code>，能看到输出<code>Koa is listening in 8889</code>，则说明我们的<code>Koa</code>已经启动成功了，并在8889端口监听。</p><h2 id="前端页面构建"><a href="#前端页面构建" class="headerlink" title="前端页面构建"></a>前端页面构建</h2><p>这个DEMO是做一个Todo-List，我们首先来做一个登录页面。</p><blockquote><p>Tips: 为了方便构建页面和美观，本文采用的Vue2的前端UI框架是<code>element-ui</code>。安装：<code>yarn add element-ui</code></p></blockquote><p>模板引擎我习惯用<code>pug</code>，CSS预处理我习惯用<code>stylus</code>，当然每个人自己的习惯和喜好是不一样的，所以大家根据自己平时的喜好来就行了。</p><p>为了方便大家查看代码，就不用<code>pug</code>了，学习成本相对高一些。不过CSS用<code>stylus</code>写起来简便，看起来也不会难懂，是我自己的习惯，所以还需要安装一下<code>yarn add stylus stylus-loader</code>。</p><blockquote><p>Tips: 安装stylus-loader是为了让webpack能够渲染stylus</p></blockquote><p>然后要把<code>element-ui</code>引入项目中。打开<code>src/main.js</code>，将文件改写如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span></span><br><span class="line"><span class="keyword">import</span> ElementUI <span class="keyword">from</span> <span class="string">'element-ui'</span> <span class="comment">// 引入element-ui</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'element-ui/lib/theme-default/index.css'</span></span><br><span class="line"></span><br><span class="line">Vue.use(ElementUI) <span class="comment">// Vue全局使用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  template: <span class="string">'&lt;App/&gt;'</span>,</span><br><span class="line">  components: &#123; App &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然后我们在项目根目录下输入<code>npm run dev</code>，启动开发模式，这个模式有webpack的热加载，也就是你写完代码，浏览器立即就能响应变化。</p><p>为了实现响应式页面，我们要在项目目录下的<code>index.html</code>的<code>head</code>标签内加入以下<code>meta</code>：</p><p><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;</code></p><h3 id="登录界面"><a href="#登录界面" class="headerlink" title="登录界面"></a>登录界面</h3><p>进入<code>src/components</code>目录，新建一个<code>Login.vue</code>的文件。然后我们来写第一个页面：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">el-row</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-col</span> <span class="attr">:xs</span>=<span class="string">"24"</span> <span class="attr">:sm</span>=<span class="string">"&#123;span: 6,offset: 9&#125;"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"title"</span>&gt;</span></span><br><span class="line">       欢迎登录 </span><br><span class="line">      <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">el-row</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-input</span> </span></span><br><span class="line"><span class="tag">          <span class="attr">v-model</span>=<span class="string">"account"</span> </span></span><br><span class="line"><span class="tag">          <span class="attr">placeholder</span>=<span class="string">"账号"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">el-input</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-input</span> </span></span><br><span class="line"><span class="tag">          <span class="attr">v-model</span>=<span class="string">"password"</span> </span></span><br><span class="line"><span class="tag">          <span class="attr">placeholder</span>=<span class="string">"密码"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">type</span>=<span class="string">"password"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">el-input</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">"primary"</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">el-row</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-col</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">el-row</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="undefined">  data () &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      account: <span class="string">''</span>,</span></span><br><span class="line"><span class="javascript">      password: <span class="string">''</span></span></span><br><span class="line"><span class="undefined">    &#125;;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined">&#125;;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">"stylus"</span> <span class="attr">scoped</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.el-row</span><span class="selector-class">.content</span></span></span><br><span class="line"><span class="undefined">    padding 16px</span></span><br><span class="line"><span class="css">  <span class="selector-class">.title</span></span></span><br><span class="line"><span class="undefined">    font-size 28px</span></span><br><span class="line"><span class="css">  <span class="selector-class">.el-input</span></span></span><br><span class="line"><span class="undefined">    margin 12px 0</span></span><br><span class="line"><span class="css">  <span class="selector-class">.el-button</span></span></span><br><span class="line"><span class="undefined">    width 100%</span></span><br><span class="line"><span class="undefined">    margin-top 12px    </span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这里就有一些值得注意的地方。首先是<code>template</code>标签内的直接子元素最多只能挂载一个。也就是你不能这么写：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">el-row</span>&gt;</span><span class="tag">&lt;/<span class="name">el-row</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">el-row</span>&gt;</span><span class="tag">&lt;/<span class="name">el-row</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>否则会报错：<code>template syntax error Component template should contain exactly one root element</code>，template下只能有一个根元素。不过为了写多个元素，你可以这样：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-row</span>&gt;</span><span class="tag">&lt;/<span class="name">el-row</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-row</span>&gt;</span><span class="tag">&lt;/<span class="name">el-row</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>同时注意到，在<code>Login.vue</code>的<code>style</code>标签内有个<code>scoped</code>属性，这个属性能够使这些样式只在这个组件内生效（因为Webpack在渲染的时候会将这个组件内的元素自动打上一串形如<code>data-v-62a7f97e</code>这样的属性，对于这些样式也会变成形如<code>.title[data-v-62a7f97e]{ font-size: 28px;}</code>的样子，保证了不会和其他组件的样式冲突。</p><p>页面写完之后，如果不把组件注册到Vue之下那么页面是不会显示的。因此这个时候需要把<code>APP.vue</code>这个文件改写一下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./assets/logo.png"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Login</span>&gt;</span><span class="tag">&lt;/<span class="name">Login</span>&gt;</span> <span class="comment">&lt;!--使用Login组件--&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> Login <span class="keyword">from</span> <span class="string">'./components/Login'</span> <span class="comment">// 引入Login组件</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  name: <span class="string">'app'</span>,</span></span><br><span class="line"><span class="undefined">  components: &#123;</span></span><br><span class="line"><span class="javascript">    Login <span class="comment">// 注册组件</span></span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css"><span class="selector-id">#app</span> &#123;</span></span><br><span class="line"><span class="undefined">  font-family: 'Avenir', Helvetica, Arial, sans-serif;</span></span><br><span class="line"><span class="undefined">  -webkit-font-smoothing: antialiased;</span></span><br><span class="line"><span class="undefined">  -moz-osx-font-smoothing: grayscale;</span></span><br><span class="line"><span class="undefined">  text-align: center;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">color</span>: <span class="selector-id">#2c3e50</span>;</span></span><br><span class="line"><span class="undefined">  margin-top: 60px;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>也就是把<code>Login</code>这个组件注册到<code>Vue</code>下，同时你再看浏览器，已经不再是<code>vue-cli</code>默认生成的<code>Hello</code>欢迎界面了。</p><p><img src="https://img.piegg.cn/vue-koa-demo/login.png" alt="Login" title="Login"></p><p>接着我们写一下登录成功后的界面。</p><h3 id="TodoList页面"><a href="#TodoList页面" class="headerlink" title="TodoList页面"></a>TodoList页面</h3><p>还是在<code>src/components</code>目录下，写一个叫做<code>TodoList.vue</code>的文件。</p><p>接着我们开始写一个TodoList：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">el-row</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-col</span> <span class="attr">:xs</span>=<span class="string">"&#123;span:20,offset:2&#125;"</span> <span class="attr">:sm</span>=<span class="string">"&#123;span:8,offset:8&#125;"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">        欢迎：&#123;&#123;name&#125;&#125;！你的待办事项是：</span><br><span class="line">      <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">placeholder</span>=<span class="string">"请输入待办事项"</span> <span class="attr">v-model</span>=<span class="string">"todos"</span> @<span class="attr">keyup.enter.native</span>=<span class="string">"addTodos"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-input</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">el-tabs</span> <span class="attr">v-model</span>=<span class="string">"activeName"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-tab-pane</span> <span class="attr">label</span>=<span class="string">"待办事项"</span> <span class="attr">name</span>=<span class="string">"first"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">el-col</span> <span class="attr">:xs</span>=<span class="string">"24"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">"!Done"</span>&gt;</span> <span class="comment">&lt;!--v-if和v-for不能同时在一个元素内使用，因为Vue总会先执行v-for--&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-for</span>=<span class="string">"(item, index) in list"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"todo-list"</span> <span class="attr">v-if</span>=<span class="string">"item.status == false"</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span></span><br><span class="line">                    &#123;&#123; index + 1 &#125;&#125;. &#123;&#123; item.content &#125;&#125;</span><br><span class="line">                  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"pull-right"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">size</span>=<span class="string">"small"</span> <span class="attr">type</span>=<span class="string">"primary"</span> @<span class="attr">click</span>=<span class="string">"finished(index)"</span>&gt;</span>完成<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">size</span>=<span class="string">"small"</span> <span class="attr">:plain</span>=<span class="string">"true"</span> <span class="attr">type</span>=<span class="string">"danger"</span> @<span class="attr">click</span>=<span class="string">"remove(index)"</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">template</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">"Done"</span>&gt;</span></span><br><span class="line">              暂无待办事项</span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">el-col</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">el-tab-pane</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-tab-pane</span> <span class="attr">label</span>=<span class="string">"已完成事项"</span> <span class="attr">name</span>=<span class="string">"second"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">"count &gt; 0"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-for</span>=<span class="string">"(item, index) in list"</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"todo-list"</span> <span class="attr">v-if</span>=<span class="string">"item.status == true"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"item finished"</span>&gt;</span></span><br><span class="line">                  &#123;&#123; index + 1 &#125;&#125;. &#123;&#123; item.content &#125;&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"pull-right"</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">size</span>=<span class="string">"small"</span> <span class="attr">type</span>=<span class="string">"primary"</span> @<span class="attr">click</span>=<span class="string">"restore(index)"</span>&gt;</span>还原<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">template</span>&gt;</span> </span><br><span class="line">          <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">            暂无已完成事项</span><br><span class="line">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">el-tab-pane</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">el-tabs</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-col</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">el-row</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="undefined">  data () &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      name: <span class="string">'Molunerfinn'</span>,</span></span><br><span class="line"><span class="javascript">      todos: <span class="string">''</span>,</span></span><br><span class="line"><span class="javascript">      activeName: <span class="string">'first'</span>,</span></span><br><span class="line"><span class="undefined">      list:[],</span></span><br><span class="line"><span class="undefined">      count: 0</span></span><br><span class="line"><span class="undefined">    &#125;;</span></span><br><span class="line"><span class="undefined">  &#125;,</span></span><br><span class="line"><span class="javascript">  computed: &#123; <span class="comment">// 计算属性用于计算是否已经完成了所有任务</span></span></span><br><span class="line"><span class="undefined">    Done()&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> count = <span class="number">0</span>;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> length = <span class="keyword">this</span>.list.length;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> <span class="keyword">this</span>.list)&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.list[i].status == <span class="literal">true</span> ? count += <span class="number">1</span> : <span class="string">''</span>;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.count = count;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span>(count == length || length == <span class="number">0</span>)&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="literal">true</span></span></span><br><span class="line"><span class="javascript">      &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="literal">false</span></span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;,</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">  methods: &#123;</span></span><br><span class="line"><span class="undefined">    addTodos() &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span>(<span class="keyword">this</span>.todos == <span class="string">''</span>)</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> obj = &#123;</span></span><br><span class="line"><span class="javascript">        status: <span class="literal">false</span>,</span></span><br><span class="line"><span class="javascript">        content: <span class="keyword">this</span>.todos</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.list.push(obj);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.todos = <span class="string">''</span>;</span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="undefined">    finished(index) &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.$set(<span class="keyword">this</span>.list[index],<span class="string">'status'</span>,<span class="literal">true</span>) <span class="comment">// 通过set的方法让数组的变动能够让Vue检测到</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.$message(&#123;</span></span><br><span class="line"><span class="javascript">        type: <span class="string">'success'</span>,</span></span><br><span class="line"><span class="javascript">        message: <span class="string">'任务完成'</span></span></span><br><span class="line"><span class="undefined">      &#125;)</span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="undefined">    remove(index) &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.list.splice(index,<span class="number">1</span>);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.$message(&#123;</span></span><br><span class="line"><span class="javascript">        type: <span class="string">'info'</span>,</span></span><br><span class="line"><span class="javascript">        message: <span class="string">'任务删除'</span></span></span><br><span class="line"><span class="undefined">      &#125;)</span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="undefined">    restore(index) &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.$set(<span class="keyword">this</span>.list[index],<span class="string">'status'</span>,<span class="literal">false</span>)</span></span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.$message(&#123;</span></span><br><span class="line"><span class="javascript">        type: <span class="string">'info'</span>,</span></span><br><span class="line"><span class="javascript">        message: <span class="string">'任务还原'</span></span></span><br><span class="line"><span class="undefined">      &#125;)</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined">&#125;;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">"stylus"</span> <span class="attr">scoped</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.el-input</span></span></span><br><span class="line"><span class="undefined">    margin 20px auto</span></span><br><span class="line"><span class="css">  <span class="selector-class">.todo-list</span></span></span><br><span class="line"><span class="undefined">    width 100%</span></span><br><span class="line"><span class="undefined">    margin-top 8px</span></span><br><span class="line"><span class="undefined">    padding-bottom 8px</span></span><br><span class="line"><span class="css">    <span class="selector-tag">border-bottom</span> 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#eee</span></span></span><br><span class="line"><span class="undefined">    overflow hidden</span></span><br><span class="line"><span class="undefined">    text-align left</span></span><br><span class="line"><span class="css">    <span class="selector-class">.item</span></span></span><br><span class="line"><span class="undefined">      font-size 20px</span></span><br><span class="line"><span class="css">      &amp;<span class="selector-class">.finished</span></span></span><br><span class="line"><span class="undefined">        text-decoration line-through</span></span><br><span class="line"><span class="css">        <span class="selector-tag">color</span> <span class="selector-id">#ddd</span></span></span><br><span class="line"><span class="css">  <span class="selector-class">.pull-right</span></span></span><br><span class="line"><span class="undefined">    float right</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>页面构建其实没有什么特别好说的，但是因为我自己有踩点坑，所以还是专门讲一下：</p><ol><li><p><code>v-if</code>和<code>v-for</code>放在一个元素内同时使用，因为Vue总会先执行<code>v-for</code>，所以导致<code>v-if</code>不会被执行。替代地，你可以使用一个额外的<code>template</code>元素用来放置<code>v-if</code>或者<code>v-for</code>从而达到同样的目的。这是相关的<a href="https://github.com/vuejs/vue/issues/3106" target="_blank" rel="noopener">issue</a>。</p></li><li><p>计算属性对于直接的数据比如<code>a: 2</code> -&gt; <code>a: 3</code>这样的数据变动可以直接检测到。但是如果是本例中的<code>list</code>的某一项的<code>status</code>这个属性变化了，如果我们直接使用<code>list[index].status = true</code>这样的写法的话，Vue将无法检测到数据变动。替代地，可以使用<code>set</code>方法（全局是<code>Vue.set()</code>，实例中是<code>this.$set()</code>），通过<code>set</code>方法可以让数据的变动变得可以被检测到。从而让计算属性能够捕捉到变化。可以参考官方文档对于响应式原理的<a href="https://cn.vuejs.org/v2/guide/reactivity.html" target="_blank" rel="noopener">描述</a>。</p></li></ol><p><img src="https://img.piegg.cn/vue-koa-demo/todolist.gif" alt="Todolist" title="Todolist"></p><p>写完<code>TodoList</code>之后，我们需要将它和<code>vue-router</code>配合起来，从而使这个单页应用能够进行页面跳转。</p><h3 id="页面路由"><a href="#页面路由" class="headerlink" title="页面路由"></a>页面路由</h3><p>由于不采用服务端渲染，所以页面路由走的是前端路由。安装一下<code>vue-router</code>：<code>yarn add vue-router</code>。</p><p>安装好后，我们挂载一下路由。打开<code>main.js</code>文件改写如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/main.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span></span><br><span class="line"><span class="keyword">import</span> ElementUI <span class="keyword">from</span> <span class="string">'element-ui'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'element-ui/lib/theme-default/index.css'</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"></span><br><span class="line">Vue.use(ElementUI);</span><br><span class="line">Vue.use(VueRouter);</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Login <span class="keyword">from</span> <span class="string">`./components/Login`</span></span><br><span class="line"><span class="keyword">import</span> TodoList <span class="keyword">from</span> <span class="string">`./components/TodoList`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router =  <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  mode: <span class="string">'history'</span>, <span class="comment">// 开启HTML5的history模式，可以让地址栏的url长得跟正常页面跳转的url一样。（不过还需要后端配合，讲Koa的时候会说）</span></span><br><span class="line">  base: __dirname, </span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/'</span>,  <span class="comment">// 默认首页打开是登录页</span></span><br><span class="line">      component: Login</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/todolist'</span>,</span><br><span class="line">      component: TodoList</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'*'</span>,</span><br><span class="line">      redirect: <span class="string">'/'</span> <span class="comment">// 输入其他不存在的地址自动跳回首页</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  router: router, <span class="comment">// 启用router</span></span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App) </span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>) <span class="comment">//挂载到id为app的元素上</span></span><br></pre></td></tr></table></figure><p>这样就把路由挂载好了，但是你打开页面发现好像还是没有什么变化。这是因为我们没有把路由视图放到页面上。现在我们改写一下<code>APP.vue</code>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- APP.vue --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./assets/logo.png"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span> <span class="comment">&lt;!-- 原本的Login换成了router-view 这就是路由视图渲染的目标元素--&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  name: <span class="string">'app'</span> <span class="comment">// 不需要再引入`Login`\`TodoList`组件了，因为在路由里已经注册了</span></span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css"><span class="selector-id">#app</span> &#123;</span></span><br><span class="line"><span class="undefined">  font-family: 'Avenir', Helvetica, Arial, sans-serif;</span></span><br><span class="line"><span class="undefined">  -webkit-font-smoothing: antialiased;</span></span><br><span class="line"><span class="undefined">  -moz-osx-font-smoothing: grayscale;</span></span><br><span class="line"><span class="undefined">  text-align: center;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">color</span>: <span class="selector-id">#2c3e50</span>;</span></span><br><span class="line"><span class="undefined">  margin-top: 60px;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后再看一下你的页面，这个时候你如果在地址栏后加上<code>/todolist</code>那么就会跳转到<code>TodoList</code>页面啦。</p><p>不过我们如何通过点击登录按钮跳转到<code>TodoList</code>呢？改写一下<code>Login.vue</code>，就可以跳转了。</p><p>只需要给登录的<code>button</code>加一个方法即可：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Login.vue --&gt;</span></span><br><span class="line">······</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 给input增加键盘事件，当输入完密码回车也执行loginToDo方法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-input</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">v-model</span>=<span class="string">"password"</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">placeholder</span>=<span class="string">"密码"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">type</span>=<span class="string">"password"</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">keyup.enter.native</span>=<span class="string">"loginToDo"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-input</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 增加一个click方法 loginToDo --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">"primary"</span> @<span class="attr">click</span>=<span class="string">"loginToDo"</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">······</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="undefined">  data () &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      account: <span class="string">''</span>,</span></span><br><span class="line"><span class="javascript">      password: <span class="string">''</span></span></span><br><span class="line"><span class="undefined">    &#125;;</span></span><br><span class="line"><span class="undefined">  &#125;,</span></span><br><span class="line"><span class="undefined">  methods: &#123;</span></span><br><span class="line"><span class="undefined">    loginToDo() &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.$router.push(<span class="string">'/todolist'</span>) <span class="comment">// 编程式路由，通过push方法，改变路由。</span></span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined">&#125;;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后你就可以通过点击<code>登录</code>按钮进行页面跳转了。并且你可以发现，页面地址从<code>localhost:8080</code>变成了<code>localhost:8080/todolist</code>，长得跟正常的url跳转一样。（但是实际上我们是单页应用，只是在应用内进行页面跳转而已，没有向后端额外请求）</p><p><img src="https://img.piegg.cn/vue-koa-demo/login2todolist.gif" alt="login2todolist" title="login2todolist"></p><p>至此，我们已经完成了一个纯前端的单页应用，能够进行页面跳转，能够做简单的ToDoList的添加和删除和还原。当然这个东西只能算是个能看不能用的东西——因为登录系统有名无实、ToDoList只要页面刷新一下就没了。</p><p>于是我们可以先把前端放一放。开启我们的后端之旅。</p><h2 id="后端环境搭建"><a href="#后端环境搭建" class="headerlink" title="后端环境搭建"></a>后端环境搭建</h2><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><p>之所以没有用Node界大家普遍喜爱的<code>Mongodb</code>主要是因为之前我用过它，而没有用过<code>MySQL</code>，本着学习的态度，我决定用用<code>MySQL</code>。还有就是<code>Express + Mongodb</code>的教程其实很早之前就已经满大街都是了。所以如果你觉得<code>Mongodb</code>更合你的胃口，看完本文你完全可以用<code>Mongodb</code>构建一个类似的应用。</p><p>去<code>MySQL</code>的<a href="http://dev.mysql.com/downloads/" target="_blank" rel="noopener">官网</a>下载安装对应平台<code>MySQL</code>的<code>Community Server</code>。</p><p>通常来说安装的步骤都是比较简单的。对于<code>MySQL</code>的基本安装、开启步骤可以参考这篇<a href="http://www.rathishkumar.in/2016/01/how-to-install-mysql-server-on-windows.html" target="_blank" rel="noopener">文章</a>，这篇是windows的。当然其他平台的安装也是很方便的，都有相应的包管理工具可以获取。值得注意的就是，安装完<code>MySQL</code>之后你需要设定一下<code>root</code>账户的密码。保证安全性。如果你漏了设定，或者你不知道怎么设定，可以参考这篇<a href="https://www.howtoforge.com/setting-changing-resetting-mysql-root-passwords" target="_blank" rel="noopener">文章</a></p><p>因为我对<code>MySQL</code>的SQL语句不是很熟悉，所以我需要一个可视化的工具来操作<code>MySQL</code>。Windows上我用的是<a href="http://www.heidisql.com/" target="_blank" rel="noopener">HediSQL</a>，macOS上我用的是<a href="https://www.sequelpro.com/" target="_blank" rel="noopener">Sequel Pro</a>。它们都是免费的。</p><p>然后我们可以用这些可视化工具连上MySQL的server（默认端口是3306）之后，创建一个新的数据库，叫做<code>todolist</code>。（当然你也可以用SQL语句:<code>CREATE DATABASE todolist</code>，之后不再赘述）。</p><p>接着我们可以来开始创建数据表了。</p><p>我们需要创建两张表，一张是用户表，一张是待办事项表。用户表用于登录、验证，待办事项表用于展示我们的待办事项。</p><p>创建一张<code>user</code>表，其中<code>password</code>我们稍后会进行<code>bcrypt</code>加密（取128位）。</p><table><thead><tr><th>字段</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>id</td><td>int（自增）</td><td>用户的id</td></tr><tr><td>user_name</td><td>CHAR(50)</td><td>用户的名字</td></tr><tr><td>password</td><td>CHAR(128)</td><td>用户的密码</td></tr></tbody></table><p>创建一张<code>list</code>表，所需的字段是<code>id</code>、<code>user_id</code>、<code>content</code>、<code>status</code>即可。</p><table><thead><tr><th>字段</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>id</td><td>int（自增）</td><td>list的id</td></tr><tr><td>user_id</td><td>int(11)</td><td>用户的id</td></tr><tr><td>content</td><td>CHAR(255)</td><td>list的内容</td></tr><tr><td>status</td><td>tinyint(1)</td><td>list的状态</td></tr></tbody></table><p>直接跟数据库打交道的部分基本就是这样了。</p><h3 id="Sequelize"><a href="#Sequelize" class="headerlink" title="Sequelize"></a>Sequelize</h3><p>跟数据库打交道的时候我们都需要一个好的操作数据库的工具，能够让我们用比较简单的方法来对数据库进行增删改查。对于<code>Mongodb</code>来说大家熟悉的是<a href="http://mongoosejs.com/" target="_blank" rel="noopener"><code>Mongoose</code></a>以及我用过一个相对更简单点的<a href="https://github.com/Automattic/monk" target="_blank" rel="noopener"><code>Monk</code></a>。对于<code>MySQL</code>，我选用的是<a href="https://github.com/sequelize/sequelize" target="_blank" rel="noopener"><code>Sequelize</code></a>，它支持多种关系型数据库（<code>Sqlite</code>、<code>MySQL</code>、<code>Postgres</code>等），它的操作基本都能返回一个<code>Promise</code>对象，这样在Koa里面我们能够很方便地进行”同步”操作。</p><blockquote><p>更多关于Sequelize的用法，可以参考<a href="http://docs.sequelizejs.com/en/latest/" target="_blank" rel="noopener">官方文档</a>，以及这两篇文章——<a href="http://itbilu.com/nodejs/npm/VkYIaRPz-.html" target="_blank" rel="noopener">Sequelize中文API文档</a>、<a href="https://segmentfault.com/a/1190000003987871" target="_blank" rel="noopener">Sequelize和MySQL对照</a></p></blockquote><p>在用<code>Sequelize</code>连接数据库之前我们需要把数据库的表结构用<code>sequelize-auto</code>导出来。</p><blockquote><p>更多关于<code>sequelize-auto</code>的使用可以参考<a href="https://github.com/sequelize/sequelize-auto" target="_blank" rel="noopener">官方介绍</a>或者<a href="http://itbilu.com/nodejs/npm/41mRdls_Z.html" target="_blank" rel="noopener">这篇文章</a></p></blockquote><p>由此我们需要分别安装这几个依赖：<code>yarn global add sequelize-auto &amp;&amp; yarn add sequelize mysql</code>。</p><blockquote><p>注：上面用yarn安装的mysql是nodejs环境下的mysql驱动。</p></blockquote><p>进入<code>server</code>的目录，执行如下语句<code>sequelize-auto -o &quot;./schema&quot; -d todolist -h 127.0.0.1 -u root -p 3306 -x XXXXX -e mysql</code>，（其中 -o 参数后面的是输出的文件夹目录， -d 参数后面的是数据库名， -h 参数后面是数据库地址， -u 参数后面是数据库用户名， -p 参数后面是端口号， -x 参数后面是数据库密码，这个要根据自己的数据库密码来！ -e 参数后面指定数据库为mysql）</p><p>然后就会在<code>schema</code>文件夹下自动生成两个文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user.js</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">sequelize, DataTypes</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sequelize.define(<span class="string">'user'</span>, &#123;</span><br><span class="line">    id: &#123;</span><br><span class="line">      type: DataTypes.INTEGER(<span class="number">11</span>), <span class="comment">// 字段类型</span></span><br><span class="line">      allowNull: <span class="literal">false</span>, <span class="comment">// 是否允许为NULL</span></span><br><span class="line">      primaryKey: <span class="literal">true</span>, <span class="comment">// 主键</span></span><br><span class="line">      autoIncrement: <span class="literal">true</span> <span class="comment">// 是否自增</span></span><br><span class="line">    &#125;,</span><br><span class="line">    user_name: &#123;</span><br><span class="line">      type: DataTypes.CHAR(<span class="number">50</span>), <span class="comment">// 最大长度为50的字符串</span></span><br><span class="line">      allowNull: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    password: &#123;</span><br><span class="line">      type: DataTypes.CHAR(<span class="number">32</span>),</span><br><span class="line">      allowNull: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    tableName: <span class="string">'user'</span> <span class="comment">// 表名</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// list.js</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">sequelize, DataTypes</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sequelize.define(<span class="string">'list'</span>, &#123;</span><br><span class="line">    id: &#123;</span><br><span class="line">      type: DataTypes.INTEGER(<span class="number">11</span>),</span><br><span class="line">      allowNull: <span class="literal">false</span>,</span><br><span class="line">      primaryKey: <span class="literal">true</span>,</span><br><span class="line">      autoIncrement: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    user_id: &#123;</span><br><span class="line">      type: DataTypes.INTEGER(<span class="number">11</span>),</span><br><span class="line">      allowNull: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    content: &#123;</span><br><span class="line">      type: DataTypes.CHAR(<span class="number">255</span>),</span><br><span class="line">      allowNull: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    status: &#123;</span><br><span class="line">      type: DataTypes.INTEGER(<span class="number">1</span>),</span><br><span class="line">      allowNull: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    tableName: <span class="string">'list'</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>自动化工具省去了很多我们手动定义表结构的时间。同时注意到生成的数据库表结构文件都自动帮我们<code>module.exports</code>出来了，所以很方便我们之后的引入。</p><p>在<code>server</code>目录下的<code>config</code>目录下我们新建一个<code>db.js</code>，用于初始化<code>Sequelize</code>和数据库的连接。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// db.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Sequelize = <span class="built_in">require</span>(<span class="string">'sequelize'</span>); <span class="comment">// 引入sequelize</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用url连接的形式进行连接，注意将root: 后面的XXXX改成自己数据库的密码</span></span><br><span class="line"><span class="keyword">const</span> Todolist = <span class="keyword">new</span> Sequelize(<span class="string">'mysql://root:XXXX@localhost/todolist'</span>,&#123;</span><br><span class="line">  define: &#123;</span><br><span class="line">    timestamps: <span class="literal">false</span> <span class="comment">// 取消Sequelzie自动给数据表加入时间戳（createdAt以及updatedAt）</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;) </span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  Todolist <span class="comment">// 将Todolist暴露出接口方便Model调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们去<code>models</code>文件夹里将数据库和表结构文件连接起来。在这个文件夹下新建一个<code>user.js</code>的文件。我们先来写一个查询用户<code>id</code>的东西。</p><p>为此我们可以先在数据库里随意加一条数据：</p><p><img src="https://img.piegg.cn/vue-koa-demo/database-1.png" alt="test" title="test"></p><p>通常我们要查询一个用户id为1的数据，会很自然的想到类似如下的写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> userInfo = User.findOne(&#123; <span class="attr">where</span>: &#123; <span class="attr">id</span>: <span class="number">1</span>&#125; &#125;); <span class="comment">// 查询</span></span><br><span class="line"><span class="built_in">console</span>.log(userInfo); <span class="comment">// 输出结果</span></span><br></pre></td></tr></table></figure><p>但是上面的写法实际上是行不通的。因为JS的特性让它的IO操作是异步的。而上面的写法，<code>userInfo</code>将是返回的一个<code>Promise</code>对象，而不是最终的<code>userInfo</code>。如果又想用同步的写法获取异步IO操作得到的数据的话，通常情况下是不能直接得到的。但是在Koa里，由于有<a href="https://github.com/tj/co" target="_blank" rel="noopener"><code>co</code></a>的存在，让这一切变得十分简单。改写如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// models/user.js</span></span><br><span class="line"><span class="keyword">const</span> db = <span class="built_in">require</span>(<span class="string">'../config/db.js'</span>), </span><br><span class="line">      userModel = <span class="string">'../schema/user.js'</span>; <span class="comment">// 引入user的表结构</span></span><br><span class="line"><span class="keyword">const</span> TodolistDb = db.Todolist; <span class="comment">// 引入数据库</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> User = TodolistDb.import(userModel); <span class="comment">// 用sequelize的import方法引入表结构，实例化了User。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getUserById = <span class="function"><span class="keyword">function</span>* (<span class="params">id</span>)</span>&#123; <span class="comment">// 注意是function* 而不是function 对于需要yield操作的函数都需要这种generator函数。</span></span><br><span class="line">  <span class="keyword">const</span> userInfo = <span class="keyword">yield</span> User.findOne(&#123; <span class="comment">// 用yield控制异步操作，将返回的Promise对象里的数据返回出来。也就实现了“同步”的写法获取异步IO操作的数据</span></span><br><span class="line">    where: &#123;</span><br><span class="line">      id: id</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> userInfo <span class="comment">// 返回数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  getUserById  <span class="comment">// 导出getUserById的方法，将会在controller里调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们在<code>controllers</code>写一个user的controller，来执行这个方法，并返回结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// controllers/user.js </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user = <span class="built_in">require</span>(<span class="string">'../models/user.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getUserInfo = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> id = <span class="keyword">this</span>.params.id; <span class="comment">// 获取url里传过来的参数里的id</span></span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">yield</span> user.getUserById(id);  <span class="comment">// 通过yield “同步”地返回查询结果</span></span><br><span class="line">  <span class="keyword">this</span>.body = result <span class="comment">// 将请求的结果放到response的body里返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  getUserInfo <span class="comment">// 把获取用户信息的方法暴露出去 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写完这个还不能直接请求，因为我们还没有定义路由，请求经过<code>Koa</code>找不到这个路径是没有反应的。</p><p>在<code>routes</code>文件夹下写一个<code>auth.js</code>的文件。（其实<code>user</code>表是用于登录的，所以走<code>auth</code>）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// routes/auth.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> auth = <span class="built_in">require</span>(<span class="string">'../controllers/user.js'</span>); </span><br><span class="line"><span class="keyword">const</span> router = <span class="built_in">require</span>(<span class="string">'koa-router'</span>)();</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/user/:id'</span>, auth.getUserInfo); <span class="comment">// 定义url的参数是id,用user的auth方法引入router</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = router; <span class="comment">// 把router规则暴露出去</span></span><br></pre></td></tr></table></figure><p>至此我们已经接近完成我们的第一个API了，还缺最后一步，将这个路由规则“挂载”到Koa上去。</p><p>回到根目录的<code>app.js</code>，改写如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="built_in">require</span>(<span class="string">'koa'</span>)()</span><br><span class="line">  , koa = <span class="built_in">require</span>(<span class="string">'koa-router'</span>)()</span><br><span class="line">  , json = <span class="built_in">require</span>(<span class="string">'koa-json'</span>)</span><br><span class="line">  , logger = <span class="built_in">require</span>(<span class="string">'koa-logger'</span>)</span><br><span class="line">  , auth = <span class="built_in">require</span>(<span class="string">'./server/routes/auth.js'</span>); <span class="comment">// 引入auth</span></span><br><span class="line"></span><br><span class="line">app.use(<span class="built_in">require</span>(<span class="string">'koa-bodyparser'</span>)());</span><br><span class="line">app.use(json());</span><br><span class="line">app.use(logger());</span><br><span class="line"></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>* (<span class="params">next</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> start = <span class="keyword">new</span> <span class="built_in">Date</span>;</span><br><span class="line">  <span class="keyword">yield</span> next;</span><br><span class="line">  <span class="keyword">let</span> ms = <span class="keyword">new</span> <span class="built_in">Date</span> - start;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'%s %s - %s'</span>, <span class="keyword">this</span>.method, <span class="keyword">this</span>.url, ms);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, ctx</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'server error'</span>, err);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">koa.use(<span class="string">'/auth'</span>, auth.routes()); <span class="comment">// 挂载到koa-router上，同时会让所有的auth的请求路径前面加上'/auth'的请求路径。</span></span><br><span class="line"></span><br><span class="line">app.use(koa.routes()); <span class="comment">// 将路由规则挂载到Koa上。</span></span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8889</span>,() =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Koa is listening in 8889'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = app;</span><br></pre></td></tr></table></figure><p>打开你的控制台，输入<code>node app.js</code>，一切运行正常没有报错的话，大功告成，我们的第一个API已经构建完成！</p><p>如何测试呢？</p><h3 id="API-Test"><a href="#API-Test" class="headerlink" title="API Test"></a>API Test</h3><p>接口在跟跟前端对接之前，我们应该先进行一遍测试，防止出现问题。在测试接口的工具上，我推荐<a href="https://www.getpostman.com/" target="_blank" rel="noopener"><code>Postman</code></a>，这个工具能够很好的模拟发送的各种请求，方便的查看响应结果，用来进行测试是最好不过了。</p><p><img src="https://img.piegg.cn/vue-koa-demo/postman-1.png" alt="Postman"></p><p>测试成功，我发送了正确的url请求，返回的结果也是我想看到的。我们看到返回的结果实际上是个JSON，这对于我们前后端来说都是十分方便处理的数据格式。</p><p>但是如果我们代码出了问题，返回error了我们该怎么测试呢？如果说控制台能够反馈一定的信息，但是绝对不充分，并且我们很可能不知道哪步出错了导致最终结果出问题。</p><p>所以我推荐用<a href="https://code.visualstudio.com/" target="_blank" rel="noopener">VSCode</a>这个工具来帮我们调试nodejs后端的代码。它能够添加断点，能够很方便地查看请求的信息。并且配合上<a href="https://github.com/remy/nodemon" target="_blank" rel="noopener"><code>nodemon</code></a>这类的工具，调试简直不要更舒服。</p><p>关于<code>VSCode</code>的nodejs调试，可以参考官方的这篇<a href="https://code.visualstudio.com/docs/editor/node-debugging" target="_blank" rel="noopener">文章</a></p><blockquote><p>我自己是用Sublime写代码，用VSCode调试，哈哈。</p></blockquote><h3 id="登录系统的实现"><a href="#登录系统的实现" class="headerlink" title="登录系统的实现"></a>登录系统的实现</h3><p>刚才实现的不过是一个简单的用户信息查询的接口，但是我们要实现的是一个登录系统，所以还需要做一些工作。</p><h4 id="JSON-WEB-TOKEN"><a href="#JSON-WEB-TOKEN" class="headerlink" title="JSON-WEB-TOKEN"></a>JSON-WEB-TOKEN</h4><p>基于cookie或者session的登录验证已经屡见不鲜，前段时间<code>JSON-WEB-TOKEN</code>出来后很是风光了一把。引入了它之后，能够实现真正无状态的请求，而不是基于session和cookie的存储式的有状态验证。</p><p>关于JSON-WEB-TOKEN的描述可以参考这篇<a href="http://blog.leapoahead.com/2015/09/07/user-authentication-with-jwt/?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">文章</a>比较简单，我还推荐一篇<a href="https://segmentfault.com/a/1190000005783306" target="_blank" rel="noopener">文章</a>，将如何使用JSON-WEB-TOKEN写得很清楚。</p><p>另外可以在JSON-WEB-TOKEN的<a href="https://jwt.io/" target="_blank" rel="noopener">官网</a>上感受一下。</p><blockquote><p>Tips：JSON-WEB-TOKEN分三部分，头部信息+主体信息+密钥信息，其中主体传递的信息（是我们存放我们需要的信息的部分）是用BASE64编码的，所以很容易被解码，一定不能存放明文密码这种关键信息！替代地可以存放一些不是特别关键的信息，比如用户名这样能够做区分的信息。</p></blockquote><p>简单来说，运用了JSON-WEB-TOKEN的登录系统应该是这样的：</p><ol><li>用户在登录页输入账号密码，将账号密码（密码进行md5加密）发送请求给后端</li><li>后端验证一下用户的账号和密码的信息，如果符合，就下发一个TOKEN返回给客户端。如果不符合就不发送TOKEN回去，返回验证错误信息。</li><li>如果登录成功，客户端将TOKEN用某种方式存下来（SessionStorage、LocalStorage）,之后要请求其他资源的时候，在请求头（Header）里带上这个TOKEN进行请求。</li><li>后端收到请求信息，先验证一下TOKEN是否有效，有效则下发请求的资源，无效则返回验证错误。</li></ol><p>通过这个TOKEN的方式，客户端和服务端之间的访问，是<code>无状态</code>的：也就是服务端不知道你这个用户到底还在不在线，只要你发送的请求头里的TOKEN是正确的我就给你返回你想要的资源。这样能够不占用服务端宝贵的空间资源，而且如果涉及到服务器集群，如果服务器进行维护或者迁移或者需要CDN节点的分配的话，<code>无状态</code>的设计显然维护成本更低。</p><p>话不多说，我们来把<code>JSON-WEB-TOKEN</code>用到我们的项目中。</p><p><code>yarn add koa-jwt</code>，安装<code>Koa</code>的<code>JSON-WEB-TOKEN</code>库。</p><p>我们需要在<code>models</code>里的<code>user.js</code>加一个方法，通过用户名查找用户：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// models/user.js</span></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"><span class="comment">// 前面的省略了</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新增一个方法，通过用户名查找</span></span><br><span class="line"><span class="keyword">const</span> getUserByName = <span class="function"><span class="keyword">function</span>* (<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> userInfo = <span class="keyword">yield</span> User.findOne(&#123;</span><br><span class="line">    where: &#123;</span><br><span class="line">      user_name: name</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> userInfo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  getUserById, <span class="comment">// 导出getUserById的方法，将会在controller里调用</span></span><br><span class="line">  getUserByName</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们写一下<code>controllers</code>里的<code>user.js</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// controllers/user.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user = <span class="built_in">require</span>(<span class="string">'../models/user.js'</span>);</span><br><span class="line"><span class="keyword">const</span> jwt = <span class="built_in">require</span>(<span class="string">'koa-jwt'</span>); <span class="comment">// 引入koa-jwt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getUserInfo = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> id = <span class="keyword">this</span>.params.id; <span class="comment">// 获取url里传过来的参数里的id</span></span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">yield</span> user.getUserById(id);  <span class="comment">// 通过yield “同步”地返回查询结果</span></span><br><span class="line">  <span class="keyword">this</span>.body = result <span class="comment">// 将请求的结果放到response的body里返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> postUserAuth = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">this</span>.request.body; <span class="comment">// post过来的数据存在request.body里</span></span><br><span class="line">  <span class="keyword">const</span> userInfo = <span class="keyword">yield</span> user.getUserByName(data.name);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(userInfo != <span class="literal">null</span>)&#123; <span class="comment">// 如果查无此用户会返回null</span></span><br><span class="line">    <span class="keyword">if</span>(userInfo.password != data.password)&#123;</span><br><span class="line">      <span class="keyword">this</span>.body = &#123;</span><br><span class="line">        success: <span class="literal">false</span>, <span class="comment">// success标志位是方便前端判断返回是正确与否</span></span><br><span class="line">        info: <span class="string">'密码错误！'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123; <span class="comment">// 如果密码正确</span></span><br><span class="line">      <span class="keyword">const</span> userToken = &#123;</span><br><span class="line">        name: userInfo.user_name,</span><br><span class="line">        id: userInfo.id</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> secret = <span class="string">'vue-koa-demo'</span>; <span class="comment">// 指定密钥，这是之后用来判断token合法性的标志</span></span><br><span class="line">      <span class="keyword">const</span> token = jwt.sign(userToken,secret); <span class="comment">// 签发token</span></span><br><span class="line">      <span class="keyword">this</span>.body = &#123;</span><br><span class="line">        success: <span class="literal">true</span>,</span><br><span class="line">        token: token, <span class="comment">// 返回token</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.body = &#123;</span><br><span class="line">      success: <span class="literal">false</span>,</span><br><span class="line">      info: <span class="string">'用户不存在！'</span> <span class="comment">// 如果用户不存在返回用户不存在</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  getUserInfo,</span><br><span class="line">  postUserAuth</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再把<code>routes</code>里的路由规则更新一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// routes/auth.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> auth = <span class="built_in">require</span>(<span class="string">'../controllers/user.js'</span>); </span><br><span class="line"><span class="keyword">const</span> router = <span class="built_in">require</span>(<span class="string">'koa-router'</span>)();</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/user/:id'</span>, auth.getUserInfo); <span class="comment">// 定义url的参数是id,用user的auth方法引入router</span></span><br><span class="line">router.post(<span class="string">'/user'</span>, auth.postUserAuth);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = router; <span class="comment">// 把router规则暴露出去</span></span><br></pre></td></tr></table></figure><p>由此我们写完了用户认证的部分。接下去我们要改写一下前端登录的方法。</p><h4 id="引入Axios"><a href="#引入Axios" class="headerlink" title="引入Axios"></a>引入Axios</h4><p>之前在学<code>Vue</code>的时候一直用的是<a href="https://github.com/pagekit/vue-resource" target="_blank" rel="noopener"><code>vue-resource</code></a>，不过后来<code>Vue2</code>出来之后，Vue官方不再默认推荐它为官方的<code>ajax</code>网络请求库了。替代地推荐了一些其他的库，比如就有我们今天要用的<a href="https://github.com/mzabriskie/axios" target="_blank" rel="noopener"><code>axios</code></a>。我之前也没有用过它，不过看完它的star和简要介绍<code>Promise based HTTP client for the browser and node.js</code>，能够同时支持node和浏览器端的ajax请求工具（还是基于Promised的！），我想就有必要用一用啦。</p><p><code>yarn add axios</code>，安装<code>axios</code>。然后我们在<code>src/main.js</code>里面引入<code>axios</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// scr/main.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"></span><br><span class="line">Vue.prototype.$http = Axios <span class="comment">// 类似于vue-resource的调用方法，之后可以在实例里直接用this.$http.get()等</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Login.vue</span></span><br><span class="line"><span class="comment">// 省略前面的部分</span></span><br><span class="line"></span><br><span class="line"> methods: &#123;</span><br><span class="line">    loginToDo() &#123;</span><br><span class="line">      <span class="keyword">let</span> obj = &#123;</span><br><span class="line">        name: <span class="keyword">this</span>.account,</span><br><span class="line">        password: <span class="keyword">this</span>.password</span><br><span class="line">      &#125; </span><br><span class="line">      <span class="keyword">this</span>.$http.post(<span class="string">'/auth/user'</span>, obj) <span class="comment">// 将信息发送给后端</span></span><br><span class="line">        .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123; <span class="comment">// axios返回的数据都在res.data里</span></span><br><span class="line">          <span class="keyword">if</span>(res.data.success)&#123; <span class="comment">// 如果成功</span></span><br><span class="line">            sessionStorage.setItem(<span class="string">'demo-token'</span>,res.data.token); <span class="comment">// 用sessionStorage把token存下来</span></span><br><span class="line">            <span class="keyword">this</span>.$message(&#123; <span class="comment">// 登录成功，显示提示语</span></span><br><span class="line">              type: <span class="string">'success'</span>,</span><br><span class="line">              message: <span class="string">'登录成功！'</span></span><br><span class="line">            &#125;); </span><br><span class="line">            <span class="keyword">this</span>.$router.push(<span class="string">'/todolist'</span>) <span class="comment">// 进入todolist页面，登录成功</span></span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.$message.error(res.data.info); <span class="comment">// 登录失败，显示提示语</span></span><br><span class="line">            sessionStorage.setItem(<span class="string">'demo-token'</span>,<span class="literal">null</span>); <span class="comment">// 将token清空</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, (err) =&gt; &#123;</span><br><span class="line">            <span class="keyword">this</span>.$message.error(<span class="string">'请求错误！'</span>)</span><br><span class="line">            sessionStorage.setItem(<span class="string">'demo-token'</span>,<span class="literal">null</span>); <span class="comment">// 将token清空</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="密码bcrypt加密"><a href="#密码bcrypt加密" class="headerlink" title="密码bcrypt加密"></a>密码bcrypt加密</h4><p>最早的时候我是在前端用了md5加密，但是后来经过提醒这种方式并不安全。md5加密的容易被破解。所以就采用了<code>bcrypt</code>的加密方式。全部走后端加密。也许你会问这样明文给后端发送密码安全吗？没问题，只要用上HTTPS，这将不是问题。</p><p><code>yarn add bcryptjs</code>安装bcryptjs。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// controllers/user.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user = <span class="built_in">require</span>(<span class="string">'../models/user.js'</span>);</span><br><span class="line"><span class="keyword">const</span> jwt = <span class="built_in">require</span>(<span class="string">'koa-jwt'</span>); <span class="comment">// 引入koa-jwt</span></span><br><span class="line"><span class="keyword">const</span> bcrypt = <span class="built_in">require</span>(<span class="string">'bcryptjs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getUserInfo = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> id = <span class="keyword">this</span>.params.id; <span class="comment">// 获取url里传过来的参数里的id</span></span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">yield</span> user.getUserById(id);  <span class="comment">// 通过yield “同步”地返回查询结果</span></span><br><span class="line">  <span class="keyword">this</span>.body = result <span class="comment">// 将请求的结果放到response的body里返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> postUserAuth = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">this</span>.request.body; <span class="comment">// post过来的数据存在request.body里</span></span><br><span class="line">  <span class="keyword">const</span> userInfo = <span class="keyword">yield</span> user.getUserByName(data.name);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(userInfo != <span class="literal">null</span>)&#123; <span class="comment">// 如果查无此用户会返回null</span></span><br><span class="line">    <span class="keyword">if</span>(!bcrypt.compareSync(data.password, userInfo.password))&#123; <span class="comment">// 验证密码是否正确</span></span><br><span class="line">      <span class="keyword">this</span>.body = &#123;</span><br><span class="line">        success: <span class="literal">false</span>, <span class="comment">// success标志位是方便前端判断返回是正确与否</span></span><br><span class="line">        info: <span class="string">'密码错误！'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123; <span class="comment">// 如果密码正确</span></span><br><span class="line">      <span class="keyword">const</span> userToken = &#123;</span><br><span class="line">        name: userInfo.user_name,</span><br><span class="line">        id: userInfo.id</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> secret = <span class="string">'vue-koa-demo'</span>; <span class="comment">// 指定密钥，这是之后用来判断token合法性的标志</span></span><br><span class="line">      <span class="keyword">const</span> token = jwt.sign(userToken,secret); <span class="comment">// 签发token</span></span><br><span class="line">      <span class="keyword">this</span>.body = &#123;</span><br><span class="line">        success: <span class="literal">true</span>,</span><br><span class="line">        token: token, <span class="comment">// 返回token</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.body = &#123;</span><br><span class="line">      success: <span class="literal">false</span>,</span><br><span class="line">      info: <span class="string">'用户不存在！'</span> <span class="comment">// 如果用户不存在返回用户不存在</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  getUserInfo,</span><br><span class="line">  postUserAuth</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们数据库里还是存着明文的<code>123</code>作为密码，现在要先将它bcrypt化，加密后变为：<code>$2a$10$x3f0Y2SNAmyAfqhKVAV.7uE7RHs3FDGuSYw.LlZhOFoyK7cjfZ.Q6</code>，将其替换掉数据库里的<code>123</code>。不做这步我们将无法登录。</p><p>还没有大功告成，因为我们的界面跑在<code>8080</code>端口，但是Koa提供的API跑在<code>8889</code>端口，所以如果直接通过<code>/auth/user</code>这个url去post是请求不到的。就算写成<code>localhost:8889/auth/user</code>也会因为跨域问题导致请求失败。</p><p>这个时候有两种最方便的解决办法：</p><ol><li>如果是跨域，服务端只要在请求头上加上<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="noopener"><code>CORS</code></a>，客户端即可跨域发送请求。</li><li>变成同域，即可解决跨域请求问题。</li></ol><p>第一种也很方便，采用<a href="https://github.com/koajs/cors" target="_blank" rel="noopener"><code>kcors</code></a>即可解决。<br>不过为了之后部署方便，我们采用第二种，变成同域请求。</p><p>打开根目录下的<code>config/index.js</code>，找到<code>dev</code>下的<code>proxyTable</code>，利用这个<code>proxyTable</code>我们能够将外部的请求通过<code>webpack</code>转发给本地，也就能够将跨域请求变成同域请求了。</p><p>将<code>proxyTable</code>改写如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> proxyTable: &#123;</span><br><span class="line">  <span class="string">'/auth'</span>:&#123;</span><br><span class="line">    target: <span class="string">'http://localhost:8889'</span>,</span><br><span class="line">    changeOrigin: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">'/api'</span>:&#123;</span><br><span class="line">    target: <span class="string">'http://localhost:8889'</span>,</span><br><span class="line">    changeOrigin: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的意思是，我们在组件里请求的地址如果是<code>/api/xxxx</code>实际上请求的是<code>http://localhost:8889/api/xxxx</code>，但是由于<code>webpack</code>帮我们代理了localhost的8889端口的服务，所以我们可以把实际是跨域的请求当做是同域下的接口来调用。</p><p>此时重新启动一下<code>webpack</code>：先<code>ctrl+c</code>退出当前进程，然后<code>npm run dev</code>。</p><p>一切都万事了之后，我们可以看到如下激动人心的画面：</p><p><img src="https://img.piegg.cn/vue-koa-demo/login2todolist-2.gif" alt="login2todolist" title="login2todolist"></p><h4 id="跳转拦截"><a href="#跳转拦截" class="headerlink" title="跳转拦截"></a>跳转拦截</h4><p>虽然我们现在能够成功登录系统了，但是还是存在一个问题：我在地址栏手动将地址改为<code>localhost:8080/todolist</code>我还是能够成功跳转到登录后的界面啊。于是这就需要一个跳转拦截，当没有登录的时候，不管地址栏输入什么地址，最终都重新定向回登录页。</p><p>这个时候，从后端给我们传回来的<code>token</code>就派上大用处。有<code>token</code>就说明我们的身份是经过验证的，否则就是非法的。</p><p><code>vue-router</code>提供了页面跳转的钩子，我们可以在<code>router</code>跳转前进行验证，如果<code>token</code>存在就跳转，如果不存在就返回登录页。</p><p>参考路由的<a href="https://router.vuejs.org/zh-cn/advanced/navigation-guards.html" target="_blank" rel="noopener">导航钩子</a></p><p>打开<code>src/main.js</code>，修改如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/main.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;....&#125;) <span class="comment">// 省略</span></span><br><span class="line"></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to,<span class="keyword">from</span>,next</span>) =&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> token = sessionStorage.getItem(<span class="string">'demo-token'</span>);</span><br><span class="line">  <span class="keyword">if</span>(to.path == <span class="string">'/'</span>)&#123; <span class="comment">// 如果是跳转到登录页的</span></span><br><span class="line">    <span class="keyword">if</span>(token != <span class="string">'null'</span> &amp;&amp; token != <span class="literal">null</span>)&#123;</span><br><span class="line">      next(<span class="string">'/todolist'</span>) <span class="comment">// 如果有token就转向todolist不返回登录页</span></span><br><span class="line">    &#125;</span><br><span class="line">    next(); <span class="comment">// 否则跳转回登录页</span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(token != <span class="string">'null'</span> &amp;&amp; token != <span class="literal">null</span>)&#123;</span><br><span class="line">      next() <span class="comment">// 如果有token就正常转向</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      next(<span class="string">'/'</span>) <span class="comment">// 否则跳转回登录页</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;...&#125;) <span class="comment">// 省略</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：一定要确保要调用 <code>next()</code> 方法，否则钩子就不会被 resolved。</strong>如果纯粹调用<code>next(path)</code>这样的方法最终还是会回到<code>.beforeEach()</code>这个钩子里面来，如果没有写对条件就有可能出现死循环，栈溢出的情况。</p></blockquote><p>然后我们就可以看到如下效果：</p><p><img src="https://img.piegg.cn/vue-koa-demo/login2todolist-3.gif" alt="login2todolist" title="login2todolist"></p><blockquote><p>Tips：这种只判断token存不存在就通过的验证是很不安全的，此例只是做了一个演示，实际上还应该进行更深一层的判断，比如从token解包出来的信息里包含我们想要的信息才可以作为有效token，才可以登录。等等。本文只是做一个简要介绍。</p></blockquote><h4 id="解析token"><a href="#解析token" class="headerlink" title="解析token"></a>解析token</h4><p>注意到我们在签发<code>token</code>的时候，写过这样几句话：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// server/controllers/user.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> userToken = &#123;</span><br><span class="line">  name: userInfo.user_name,</span><br><span class="line">  id: userInfo.id</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> secret = <span class="string">'vue-koa-demo'</span>; <span class="comment">// 指定密钥，这是之后用来判断token合法性的标志</span></span><br><span class="line"><span class="keyword">const</span> token = jwt.sign(userToken,secret); <span class="comment">// 签发token</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>我们将用户名和id打包进JWT的主体部分，同时我们解密的密钥是<code>vue-koa-demo</code>。所以我们可以通过这个信息，来进行登录后的用户名显示，以及用来区别这个用户是谁，这个用户有哪些<code>Todolist</code>。</p><p>接下来在<code>Todolist</code>页面进行token解析，从而让用户名显示为登录用户名。</p><p><strong>注意：</strong> 前端直接暴露<code>secret-key</code>的做法其实并不安全。正确的做法应该是把token跟用户名和其他不是很重要的信息一起传过来，token只用于验证，而其他信息作为返回值正常返回。这样就不会暴露<code>secret-key</code>了。当然本文只是为了方便说明，给出的一个不恰当的获取用户信息的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// src/components/TodoList.vue</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jwt <span class="keyword">from</span> <span class="string">'jsonwebtoken'</span> <span class="comment">// 我们安装koa-jwt的时候会自动下载这个依赖</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line"></span><br><span class="line">  created()&#123; <span class="comment">// 组件创建时调用</span></span><br><span class="line">    <span class="keyword">const</span> userInfo = <span class="keyword">this</span>.getUserInfo(); <span class="comment">// 新增一个获取用户信息的方法</span></span><br><span class="line">    <span class="keyword">if</span>(userInfo != <span class="literal">null</span>)&#123;</span><br><span class="line">      <span class="keyword">this</span>.id = userInfo.id;</span><br><span class="line">      <span class="keyword">this</span>.name = userInfo.name;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.id = <span class="string">''</span>;</span><br><span class="line">      <span class="keyword">this</span>.name = <span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      name: <span class="string">''</span>, <span class="comment">// 用户名改为空</span></span><br><span class="line">      todos: <span class="string">''</span>,</span><br><span class="line">      activeName: <span class="string">'first'</span>,</span><br><span class="line">      list:[],</span><br><span class="line">      count: <span class="number">0</span>,</span><br><span class="line">      id: <span class="string">''</span> <span class="comment">// 新增用户id属性，用于区别用户</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;...&#125;, <span class="comment">//省略</span></span><br><span class="line"></span><br><span class="line">  methods: &#123;</span><br><span class="line">    addTodos() &#123;...&#125;, <span class="comment">// 省略</span></span><br><span class="line">    finished(index) &#123;...&#125;,</span><br><span class="line">    remove(index) &#123;...&#125;,</span><br><span class="line">    restore(index) &#123;...&#125;,</span><br><span class="line">    getUserInfo()&#123; <span class="comment">// 获取用户信息</span></span><br><span class="line">      <span class="keyword">const</span> token = sessionStorage.getItem(<span class="string">'demo-token'</span>);</span><br><span class="line">      <span class="keyword">if</span>(token != <span class="literal">null</span> &amp;&amp; token != <span class="string">'null'</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> decode = jwt.decode(token); <span class="comment">// 解析token</span></span><br><span class="line">        <span class="keyword">return</span> decode <span class="comment">// decode解析出来实际上就是&#123;name: XXX,id: XXX&#125;</span></span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>于是你就可以看到：</p><p><img src="https://img.piegg.cn/vue-koa-demo/todolist-1.png" alt="todolist" title="todolist"></p><p>用户名已经不是我们之前默认的<code>Molunerfinn</code>而是登录名<code>molunerfinn</code>了。</p><h2 id="Todolist-增删改查的实现"><a href="#Todolist-增删改查的实现" class="headerlink" title="Todolist 增删改查的实现"></a>Todolist 增删改查的实现</h2><p>这个部分就是前后端协作了。我们要实现之前在纯前端部分实现的内容。我以最基本的两个方法来举例子：获取<code>Todolist</code>以及增加<code>Todolist</code>，剩下其实思路大同小异，我就提供代码和注释了，我相信也很容易懂。</p><h3 id="Token的发送"><a href="#Token的发送" class="headerlink" title="Token的发送"></a>Token的发送</h3><p>之前说了，用JSON-WEB-TOKEN之后，这个系统的验证就完全依靠token了。如果token正确就下发资源，如果资源不正确，就返回错误信息。</p><p>因为我们用了<code>koa-jwt</code>，所以只需要在每条请求头上加上<code>Authorization</code>属性，值是<code>Bearer {token值}</code>，然后让<code>Koa</code>在接收请求之前验证一下token即可。但是如果每发一条请求就要手动写一句这个，太累了。于是我们可以做到全局<code>Header</code>设定。</p><p>打开<code>src/main.js</code>，在路由跳转的钩子里加上这句：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// scr/main.json</span></span><br><span class="line"></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to,<span class="keyword">from</span>,next</span>) =&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> token = sessionStorage.getItem(<span class="string">'demo-token'</span>);</span><br><span class="line">  <span class="keyword">if</span>(to.path == <span class="string">'/'</span>)&#123; </span><br><span class="line">    <span class="keyword">if</span>(token != <span class="string">'null'</span> &amp;&amp; token != <span class="literal">null</span>)&#123;</span><br><span class="line">      next(<span class="string">'/todolist'</span>) </span><br><span class="line">    &#125;</span><br><span class="line">    next(); </span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(token != <span class="string">'null'</span> &amp;&amp; token != <span class="literal">null</span>)&#123;</span><br><span class="line">      Vue.prototype.$http.defaults.headers.common[<span class="string">'Authorization'</span>] = <span class="string">'Bearer '</span> + token; <span class="comment">// 全局设定header的token验证，注意Bearer后有个空格</span></span><br><span class="line">      next() </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      next(<span class="string">'/'</span>) </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样就完成了token的客户端发送设定。</p><h3 id="Koa端对Token的验证"><a href="#Koa端对Token的验证" class="headerlink" title="Koa端对Token的验证"></a>Koa端对Token的验证</h3><p>接着我们实现两个简单的api，这两个api请求的路径就不是<code>/auth/xxx</code>而是<code>/api/xxx</code>了。我们还需要实现，访问<code>/api/*</code>路径的请求都需要经过<code>koa-jwt</code>的验证，而<code>/auth/*</code>的请求不需要。</p><p>首先去<code>models</code>目录下新建一个<code>todolist.js</code>的文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// server/models/todolist.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> db = <span class="built_in">require</span>(<span class="string">'../config/db.js'</span>), </span><br><span class="line">      todoModel = <span class="string">'../schema/list.js'</span>; <span class="comment">// 引入todolist的表结构</span></span><br><span class="line"><span class="keyword">const</span> TodolistDb = db.Todolist; <span class="comment">// 引入数据库</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Todolist = TodolistDb.import(todoModel); </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getTodolistById = <span class="function"><span class="keyword">function</span>* (<span class="params">id</span>)</span>&#123;  <span class="comment">// 获取某个用户的全部todolist</span></span><br><span class="line">  <span class="keyword">const</span> todolist = <span class="keyword">yield</span> Todolist.findAll(&#123; <span class="comment">// 查找全部的todolist</span></span><br><span class="line">    where: &#123;</span><br><span class="line">      user_id: id</span><br><span class="line">    &#125;,</span><br><span class="line">    attributes: [<span class="string">'id'</span>,<span class="string">'content'</span>,<span class="string">'status'</span>] <span class="comment">// 只需返回这三个字段的结果即可</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> todolist <span class="comment">// 返回数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> createTodolist = <span class="function"><span class="keyword">function</span>* (<span class="params">data</span>)</span>&#123; <span class="comment">// 给某个用户创建一条todolist</span></span><br><span class="line">  <span class="keyword">yield</span> Todolist.create(&#123;</span><br><span class="line">    user_id: data.id, <span class="comment">// 用户的id，用来确定给哪个用户创建</span></span><br><span class="line">    content: data.content,</span><br><span class="line">    status: data.status </span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  getTodolistById,</span><br><span class="line">  createTodolist</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着去<code>controllers</code>目录下新建一个<code>todolist.js</code>的文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server/controllers/todolist</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> todolist = <span class="built_in">require</span>(<span class="string">'../models/todolist.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getTodolist = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123; <span class="comment">// 获取某个用户的所有todolist</span></span><br><span class="line">  <span class="keyword">const</span> id = <span class="keyword">this</span>.params.id; <span class="comment">// 获取url里传过来的参数里的id</span></span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">yield</span> todolist.getTodolistById(id);  <span class="comment">// 通过yield “同步”地返回查询结果</span></span><br><span class="line">  <span class="keyword">this</span>.body = result <span class="comment">// 将请求的结果放到response的body里返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> createTodolist = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123; <span class="comment">// 给某个用户创建一条todolist</span></span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">this</span>.request.body; <span class="comment">// post请求，数据是在request.body里的</span></span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">yield</span> todolist.createTodolist(data);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.body = &#123;</span><br><span class="line">    success: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  getTodolist,</span><br><span class="line">  createTodolist</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后去<code>routes</code>文件夹里新建一个<code>api.js</code>文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// server/routes/api.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> todolist = <span class="built_in">require</span>(<span class="string">'../controllers/todolist.js'</span>);</span><br><span class="line"><span class="keyword">const</span> router = <span class="built_in">require</span>(<span class="string">'koa-router'</span>)();</span><br><span class="line"></span><br><span class="line">todolist(router); <span class="comment">// 引入koa-router</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = router; <span class="comment">// 导出router规则</span></span><br></pre></td></tr></table></figure><p>最后，去根目录下的<code>app.js</code>，给koa加上新的路由规则：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// app.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="built_in">require</span>(<span class="string">'koa'</span>)()</span><br><span class="line">  , koa = <span class="built_in">require</span>(<span class="string">'koa-router'</span>)()</span><br><span class="line">  , json = <span class="built_in">require</span>(<span class="string">'koa-json'</span>)</span><br><span class="line">  , logger = <span class="built_in">require</span>(<span class="string">'koa-logger'</span>)</span><br><span class="line">  , auth = <span class="built_in">require</span>(<span class="string">'./server/routes/auth.js'</span>)</span><br><span class="line">  , api = <span class="built_in">require</span>(<span class="string">'./server/routes/api.js'</span>)</span><br><span class="line">  , jwt = <span class="built_in">require</span>(<span class="string">'koa-jwt'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ..... 省略</span></span><br><span class="line"></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>* (<span class="params">next</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> start = <span class="keyword">new</span> <span class="built_in">Date</span>;</span><br><span class="line">  <span class="keyword">yield</span> next;</span><br><span class="line">  <span class="keyword">let</span> ms = <span class="keyword">new</span> <span class="built_in">Date</span> - start;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'%s %s - %s'</span>, <span class="keyword">this</span>.method, <span class="keyword">this</span>.url, ms);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span> *(<span class="params">next</span>)</span>&#123;  <span class="comment">//  如果JWT验证失败，返回验证失败信息</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> next;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">401</span> == err.status) &#123;</span><br><span class="line">      <span class="keyword">this</span>.status = <span class="number">401</span>;</span><br><span class="line">      <span class="keyword">this</span>.body = &#123;</span><br><span class="line">        success: <span class="literal">false</span>,</span><br><span class="line">        token: <span class="literal">null</span>,</span><br><span class="line">        info: <span class="string">'Protected resource, use Authorization header to get access'</span></span><br><span class="line">      &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, ctx</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'server error'</span>, err);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">koa.use(<span class="string">'/auth'</span>, auth.routes()); <span class="comment">// 挂载到koa-router上，同时会让所有的auth的请求路径前面加上'/auth'的请求路径。</span></span><br><span class="line">koa.use(<span class="string">"/api"</span>,jwt(&#123;<span class="attr">secret</span>: <span class="string">'vue-koa-demo'</span>&#125;),api.routes()) <span class="comment">// 所有走/api/打头的请求都需要经过jwt中间件的验证。secret密钥必须跟我们当初签发的secret一致</span></span><br><span class="line"></span><br><span class="line">app.use(koa.routes()); <span class="comment">// 将路由规则挂载到Koa上。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...省略</span></span><br></pre></td></tr></table></figure><p>至此，后端的两个api已经构建完成。</p><p>初始化配置相对复杂一些，涉及到<code>model</code>、<code>controllers</code>、<code>routes</code>和<code>app.js</code>，可能会让人望而却步。实际上第一次构建完成之后，后续要添加api，基本上只需要在<code>model</code>和<code>controllers</code>写好方法，定好接口即可，十分方便。</p><h3 id="前端对接接口"><a href="#前端对接接口" class="headerlink" title="前端对接接口"></a>前端对接接口</h3><p>后端接口已经开放，接下来要把前端和后端进行对接。主要有两个对接接口：</p><ol><li>获取某个用户的所有todolist</li><li>创建某个用户的一条todolist</li></ol><p>接下来就是改写<code>Todolist.vue</code>里的方法了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// todolist.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 省略</span></span><br><span class="line"></span><br><span class="line">created()&#123;</span><br><span class="line">  <span class="keyword">const</span> userInfo = <span class="keyword">this</span>.getUserInfo();</span><br><span class="line">  <span class="keyword">if</span>(userInfo != <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="keyword">this</span>.id = userInfo.id;</span><br><span class="line">    <span class="keyword">this</span>.name = userInfo.name;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.id = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">''</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.getTodolist(); <span class="comment">// 新增：在组件创建时获取todolist</span></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 省略</span></span><br><span class="line"></span><br><span class="line">methods: &#123;</span><br><span class="line">  addTodos() &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.todos == <span class="string">''</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">let</span> obj = &#123;</span><br><span class="line">      status: <span class="literal">false</span>,</span><br><span class="line">      content: <span class="keyword">this</span>.todos,</span><br><span class="line">      id: <span class="keyword">this</span>.id</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.$http.post(<span class="string">'/api/todolist'</span>, obj) <span class="comment">// 新增创建请求</span></span><br><span class="line">      .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(res.status == <span class="number">200</span>)&#123; <span class="comment">// 当返回的状态为200成功时</span></span><br><span class="line">          <span class="keyword">this</span>.$message(&#123;</span><br><span class="line">            type: <span class="string">'success'</span>,</span><br><span class="line">            message: <span class="string">'创建成功！'</span> </span><br><span class="line">          &#125;)</span><br><span class="line">          <span class="keyword">this</span>.getTodolist(); <span class="comment">// 获得最新的todolist</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="keyword">this</span>.$message.error(<span class="string">'创建失败！'</span>) <span class="comment">// 当返回不是200说明处理出问题</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, (err) =&gt; &#123;</span><br><span class="line">        <span class="keyword">this</span>.$message.error(<span class="string">'创建失败！'</span>) <span class="comment">// 当没有返回值说明服务端错误或者请求没发送出去</span></span><br><span class="line">        <span class="built_in">console</span>.log(err)</span><br><span class="line">      &#125;)</span><br><span class="line">    <span class="keyword">this</span>.todos = <span class="string">''</span>; <span class="comment">// 将当前todos清空</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ... 省略一些方法</span></span><br><span class="line">  getTodolist()&#123;</span><br><span class="line">    <span class="keyword">this</span>.$http.get(<span class="string">'/api/todolist/'</span> + <span class="keyword">this</span>.id) <span class="comment">// 向后端发送获取todolist的请求</span></span><br><span class="line">      .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(res.status == <span class="number">200</span>)&#123;</span><br><span class="line">          <span class="keyword">this</span>.list = res.data <span class="comment">// 将获取的信息塞入实例里的list</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="keyword">this</span>.$message.error(<span class="string">'获取列表失败！'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, (err) =&gt; &#123;</span><br><span class="line">        <span class="keyword">this</span>.$message.error(<span class="string">'获取列表失败！'</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(err)</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，前后端的部分已经完整构建。让我们来看看效果：</p><p><img src="https://img.piegg.cn/vue-koa-demo/login2todolist-4.gif" alt="todolist" title="todolist"></p><p>做到这一步的时候其实我们的应用已经基本完成了。最后的收尾工作，让我们来收一下。</p><p>原本的前端版本还有<code>完成</code>、<code>删除</code>、<code>还原</code>三种状态，其中<code>完成</code>和<code>还原</code>只是状态的切换（更新），所以可以算是一个api，然后就是删除是单独一个api。于是我们就能算是完成了增、删、改、查了。接下去的部分就提供代码就行，其实思路跟之前的是一样的，只不过操作的函数不一样罢了。</p><h3 id="Todolist的改、删"><a href="#Todolist的改、删" class="headerlink" title="Todolist的改、删"></a>Todolist的改、删</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// server/models/todolist.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...省略</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> removeTodolist = <span class="function"><span class="keyword">function</span>* (<span class="params">id,user_id</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> Todolist.destroy(&#123;</span><br><span class="line">    where: &#123;</span><br><span class="line">      id,</span><br><span class="line">      user_id</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> updateTodolist = <span class="function"><span class="keyword">function</span>* (<span class="params">id,user_id,status</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> Todolist.update(</span><br><span class="line">    &#123;</span><br><span class="line">      status</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      where: &#123;</span><br><span class="line">        id,</span><br><span class="line">        user_id</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  getTodolistById,</span><br><span class="line">  createTodolist,</span><br><span class="line">  removeTodolist,</span><br><span class="line">  updateTodolist</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// server/controllers/todolist.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 省略</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> removeTodolist = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> id = <span class="keyword">this</span>.params.id;</span><br><span class="line">  <span class="keyword">const</span> user_id = <span class="keyword">this</span>.params.userId;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">yield</span> todolist.removeTodolist(id,user_id);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.body = &#123;</span><br><span class="line">    success: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> updateTodolist = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> id = <span class="keyword">this</span>.params.id;</span><br><span class="line">  <span class="keyword">const</span> user_id = <span class="keyword">this</span>.params.userId;</span><br><span class="line">  <span class="keyword">let</span> status = <span class="keyword">this</span>.params.status; </span><br><span class="line">  status == <span class="string">'0'</span> ? status = <span class="literal">true</span> : status =  <span class="literal">false</span>;<span class="comment">// 状态反转（更新）</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">yield</span> todolist.updateTodolist(id,user_id,status);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.body = &#123;</span><br><span class="line">    success: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">router</span>) =&gt;</span> &#123;</span><br><span class="line">  getTodolist,</span><br><span class="line">  createTodolist,</span><br><span class="line">  removeTodolist,</span><br><span class="line">  updateTodolist</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">&lt;!-- src/components/TodoList.vue --&gt;</span></span><br><span class="line"></span><br><span class="line">....</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 把完成和还原的方法替换成了update --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-button</span> <span class="attr">size</span>=<span class="string">"small"</span> <span class="attr">type</span>=<span class="string">"primary"</span> @<span class="attr">click</span>=<span class="string">"update(index)"</span>&gt;</span>完成<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">....</span><br><span class="line"><span class="tag">&lt;<span class="name">el-button</span> <span class="attr">size</span>=<span class="string">"small"</span> <span class="attr">type</span>=<span class="string">"primary"</span> @<span class="attr">click</span>=<span class="string">"update(index)"</span>&gt;</span>还原<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">....</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="comment">// ....省略</span></span></span><br><span class="line"><span class="undefined">  methods:&#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// ... 省略</span></span></span><br><span class="line"><span class="undefined">    update(index) &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.$http.put(<span class="string">'/api/todolist/'</span>+ <span class="keyword">this</span>.id + <span class="string">'/'</span> + <span class="keyword">this</span>.list[index].id + <span class="string">'/'</span> + <span class="keyword">this</span>.list[index].status)</span></span><br><span class="line"><span class="javascript">        .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">if</span>(res.status == <span class="number">200</span>)&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.$message(&#123;</span></span><br><span class="line"><span class="javascript">              type: <span class="string">'success'</span>,</span></span><br><span class="line"><span class="javascript">              message: <span class="string">'任务状态更新成功！'</span></span></span><br><span class="line"><span class="undefined">            &#125;)</span></span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.getTodolist();</span></span><br><span class="line"><span class="javascript">          &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.$message.error(<span class="string">'任务状态更新失败！'</span>)</span></span><br><span class="line"><span class="undefined">          &#125;</span></span><br><span class="line"><span class="undefined">        &#125;, (err) =&gt; &#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">this</span>.$message.error(<span class="string">'任务状态更新失败！'</span>)</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(err)</span></span><br><span class="line"><span class="undefined">        &#125;)</span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="undefined">    remove(index) &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.$http.delete(<span class="string">'/api/todolist/'</span>+ <span class="keyword">this</span>.id + <span class="string">'/'</span> + <span class="keyword">this</span>.list[index].id)</span></span><br><span class="line"><span class="javascript">        .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">if</span>(res.status == <span class="number">200</span>)&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.$message(&#123;</span></span><br><span class="line"><span class="javascript">              type: <span class="string">'success'</span>,</span></span><br><span class="line"><span class="javascript">              message: <span class="string">'任务删除成功！'</span></span></span><br><span class="line"><span class="undefined">            &#125;)</span></span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.getTodolist();</span></span><br><span class="line"><span class="javascript">          &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.$message.error(<span class="string">'任务删除失败！'</span>)</span></span><br><span class="line"><span class="undefined">          &#125;</span></span><br><span class="line"><span class="undefined">        &#125;, (err) =&gt; &#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">this</span>.$message.error(<span class="string">'任务删除失败！'</span>)</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(err)</span></span><br><span class="line"><span class="undefined">        &#125;)</span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="javascript"><span class="comment">// ... 省略</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>让我们来看看最后99%成品的效果吧：</p><p><img src="https://img.piegg.cn/vue-koa-demo/todolist-5.gif" alt="Todolist" title="todolist"></p><h2 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h2><p>很多教程到类似于我上面的部分就结束了。但是实际上我们做一个项目最想要的就是部署给大家用不是么？</p><p>在部署这块有些坑，需要让大家也一起知道一下。这个项目是个全栈项目（虽然是个很简单的。。。），所以就涉及到前后端通信的问题，也就会涉及到是同域请求还是跨域请求。</p><p>我们也说过，要解决这个问题有两种方便的解决办法，第一种，服务端加上<code>cors</code>，客户端就可以随意的跨域请求。但是这样会有个问题，因为我们是以同域的形式开发，请求的地址也是写的相对地址：<code>/api/*</code>、<code>auth/*</code>这样的路径，访问的路径的自然是同域。如果要在服务端加上<code>cors</code>，我们还需要将我们的所有请求地址改成<code>localhost:8889/api/*</code>，<code>localhost:8889/auth/*</code>，这样的话，如果服务端的端口号一变，我们还需要重新修改前端所有的请求地址。这样很不方便也很不科学。</p><p>因此，要将请求变为同域才是最好的解决办法——不管服务端端口号怎么变，只要是同域都可以请求到。</p><p>于是要把Vue和Koa结合起来变成一个完整的项目（之前实际上都是在开发模式下，webpack帮我们进行请求的代理转发，所以看起来像是同域请求，而Vue和Koa并没有完全结合起来），就得在生产模式下，将Vue的静态文件交给Koa“托管”，所有访问前端的请求全部走Koa端，包括静态文件资源的请求，也走Koa端，把Koa作为一个Vue项目的静态资源服务器，这样就可以让Vue里的请求走的都是同域了。（相当于，之前开发模式是webpack开启了一个服务器托管了Vue的资源和请求，现在生产模式下改成Koa托管Vue的资源和请求）</p><p>要在开发和生产模式改变不同的托管服务器，其实也很简单，只需要在生产模式下，用Koa的静态资源服务中间件托管构建好的Vue文件即可。</p><h3 id="Webpack打包"><a href="#Webpack打包" class="headerlink" title="Webpack打包"></a>Webpack打包</h3><p>部署之前我们要用Webpack将我们的前端项目打包输出一下。但是如果直接用<code>npm run build</code>，你会发现打包出来的文件太大了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">                                                  Asset       Size  Chunks             Chunk Names</span><br><span class="line">    static/css/app.d9034fc06fd57ce00d6e75ed49f0dafe.css     120 kB    2, 0  [emitted]  app</span><br><span class="line">                 static/fonts/element-icons.a61be9c.eot    13.5 kB          [emitted]</span><br><span class="line">                   static/img/element-icons.09162bc.svg    17.4 kB          [emitted]</span><br><span class="line">             static/js/manifest.8ea250834bdc80e4d73b.js  832 bytes       0  [emitted]  manifest</span><br><span class="line">               static/js/vendor.75bbe7ecea37b0d4c62d.js     623 kB    1, 0  [emitted]  vendor</span><br><span class="line">                  static/js/app.e2d125562bfc4c57f9cb.js    16.5 kB    2, 0  [emitted]  app</span><br><span class="line">                 static/fonts/element-icons.b02bdc1.ttf    13.2 kB          [emitted]</span><br><span class="line">         static/js/manifest.8ea250834bdc80e4d73b.js.map    8.86 kB       0  [emitted]  manifest</span><br><span class="line">           static/js/vendor.75bbe7ecea37b0d4c62d.js.map    3.94 MB    1, 0  [emitted]  vendor</span><br><span class="line">              static/js/app.e2d125562bfc4c57f9cb.js.map    64.8 kB    2, 0  [emitted]  app</span><br><span class="line">static/css/app.d9034fc06fd57ce00d6e75ed49f0dafe.css.map     151 kB    2, 0  [emitted]  app</span><br><span class="line">                                             index.html  563 bytes          [emitted]</span><br></pre></td></tr></table></figure><p>竟然有3.94MB的map文件。这肯定是不能接受的。于是要修改一下webpack的输出的设置，取消输出map文件。</p><p>找到根目录下的<code>config/index.js</code>：把<code>productionSourceMap: true</code>这句话改成<code>productionSourceMap: false</code>。然后再执行一遍<code>npm run build</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">                                              Asset       Size  Chunks             Chunk Names</span><br><span class="line">             static/fonts/element-icons.a61be9c.eot    13.5 kB          [emitted]</span><br><span class="line">             static/fonts/element-icons.b02bdc1.ttf    13.2 kB          [emitted]</span><br><span class="line">               static/img/element-icons.09162bc.svg    17.4 kB          [emitted]</span><br><span class="line">         static/js/manifest.3ba218c80028a707a728.js  774 bytes       0  [emitted]  manifest</span><br><span class="line">           static/js/vendor.75bbe7ecea37b0d4c62d.js     623 kB    1, 0  [emitted]  vendor</span><br><span class="line">              static/js/app.b6acaca2531fc0baa447.js    16.5 kB    2, 0  [emitted]  app</span><br><span class="line">static/css/app.d9034fc06fd57ce00d6e75ed49f0dafe.css     120 kB    2, 0  [emitted]  app</span><br><span class="line">                                         index.html  563 bytes          [emitted]</span><br></pre></td></tr></table></figure><p>把sourceMap去掉了之后，体积就小下来了。虽然600+kb的大小还是有点大，不过放到服务端，gzip之后只剩150+kb的体积勉强还是可以接受。当然，对于webpack输出的优化，不是本文讨论的范围，有很多更好的文章讲述了这个东西，故本文不再详细展开。</p><p>打包好后就是相当于输出了一堆静态文件，当然这堆静态文件需要放在服务端才可以访问。我们要将这堆静态资源用Koa托管。</p><h3 id="Koa-serve静态资源"><a href="#Koa-serve静态资源" class="headerlink" title="Koa serve静态资源"></a>Koa serve静态资源</h3><p><code>yarn add koa-static</code></p><p>打开<code>app.js</code>，引入两个新依赖，其中<code>path</code>是nodejs原生自带。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// .... </span></span><br><span class="line"><span class="keyword">const</span> path =<span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line">    , serve = <span class="built_in">require</span>(<span class="string">'koa-static'</span>);</span><br><span class="line"><span class="comment">// ....</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态文件serve在koa-router的其他规则之上 </span></span><br><span class="line">app.use(serve(path.resolve(<span class="string">'dist'</span>))); <span class="comment">// 将webpack打包好的项目目录作为Koa静态文件服务的目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面这些是之前就有的。。。为了方便找位置故标示出来</span></span><br><span class="line">koa.use(<span class="string">'/auth'</span>, auth.routes());</span><br><span class="line">koa.use(<span class="string">"/api"</span>,jwt(&#123;<span class="attr">secret</span>: <span class="string">'vue-koa-demo'</span>&#125;),api.routes()) </span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>然后重新运行一遍<code>node app.js</code>，看到输出<code>Koa is listening in 8889</code>后，你可以打开浏览器<code>localhost:8889</code>就可以看到如下情景：</p><p><img src="https://img.piegg.cn/vue-koa-demo/vue-koa.png" alt="vue-koa"></p><p>至此已经基本上接近尾声，不过还存在一个问题：如果我们登录进去之后，在todolist页面一刷新，就会出现：</p><p><img src="https://img.piegg.cn/vue-koa-demo/404.png" alt="404" title="404"></p><p>为什么会出现这种情况？简单来说是因为我们使用了前端路由，用了HTML5 的History模式，如果没有做其他任何配置的话，刷新页面，那么浏览器将会去服务端访问这个页面地址，因为服务端并没有配置这个地址的路由，所以自然就返回404 Not Found了。</p><p>详细可以参考vue-router的<a href="https://router.vuejs.org/zh-cn/essentials/history-mode.html" target="_blank" rel="noopener">这篇文档</a></p><p>该怎么解决？其实也很简单，多加一个中间件：<code>koa-history-api-fallback</code>即可.</p><p><code>yarn add koa-history-api-fallback</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//... 省略</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> historyApiFallback = <span class="built_in">require</span>(<span class="string">'koa-history-api-fallback'</span>); <span class="comment">// 引入依赖</span></span><br><span class="line"></span><br><span class="line">app.use(<span class="built_in">require</span>(<span class="string">'koa-bodyparser'</span>)());</span><br><span class="line">app.use(json());</span><br><span class="line">app.use(logger());</span><br><span class="line">app.use(historyApiFallback()); <span class="comment">// 在这个地方加入。一定要加在静态文件的serve之前，否则会失效。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>这个时候，你再重新启动一下koa，登录之后再刷新页面，就不会再出现404 Not Found了。</p><h3 id="API-Test-1"><a href="#API-Test-1" class="headerlink" title="API Test"></a>API Test</h3><p>本来写到上面基本本文已经算是结束了。但是由于我在开发的过程中遇到了一些问题，所以还需要做一些微调。</p><p>我们知道koa的use方法是有顺序只差的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line">app.use(A);</span><br><span class="line">app.use(B);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line">app.use(B);</span><br><span class="line">app.use(A);</span><br></pre></td></tr></table></figure><p>这二者是有区别的，谁先被use，谁的规则就放到前面先执行。</p><p>因此如果我们将静态文件的serve以及<code>historyApiFallback</code>放在了api的请求之前，那么用postman测试api的时候总会先返回完整的页面：</p><p><img src="https://img.piegg.cn/vue-koa-demo/postman.png" alt="postman"></p><p>因此正确的做法，应该是将它们放到我们写的api的规则之后：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">koa.use(<span class="string">'/auth'</span>, auth.routes()); <span class="comment">// 挂载到koa-router上，同时会让所有的auth的请求路径前面加上'/auth'的请求路径。</span></span><br><span class="line">koa.use(<span class="string">"/api"</span>,jwt(&#123;<span class="attr">secret</span>: <span class="string">'vue-koa-demo'</span>&#125;),api.routes()) <span class="comment">// 所有走/api/打头的请求都需要经过jwt验证。</span></span><br><span class="line"></span><br><span class="line">app.use(koa.routes()); <span class="comment">// 将路由规则挂载到Koa上。</span></span><br><span class="line"></span><br><span class="line">app.use(historyApiFallback()); <span class="comment">// 将这两个中间件挂载在api的路由之后</span></span><br><span class="line">app.use(serve(path.resolve(<span class="string">'dist'</span>))); <span class="comment">// 将webpack打包好的项目目录作为Koa静态文件服务的目录</span></span><br></pre></td></tr></table></figure><p>这样就能正常返回数据了。</p><h3 id="Nginx配置"><a href="#Nginx配置" class="headerlink" title="Nginx配置"></a>Nginx配置</h3><p>真正部署到服务器的时候，我们肯定不会让大家输入<code>域名:8889</code>这样的方式让大家访问。所以需要用Nginx监听80端口，把访问我们指定域名的请求引导转发给Koa服务端。</p><p>大致的<code>nginx.conf</code>如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment"># ....</span></span><br><span class="line">  <span class="attribute">upstream</span> koa.server&#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:8889</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>   <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> xxx.xxx.com;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">      <span class="attribute">proxy_pass</span> http://koa.server;</span><br><span class="line">      <span class="attribute">proxy_redirect</span> <span class="literal">off</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#....</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">#....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有精力还可以配置一下Nginx的Gzip，能让请求的JS\CSS\HTML等静态文件更小，响应速度更快些。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>至此，我们已经完成了一个从前端到后端，从本地到服务器的完整项目。虽然它真的是个很简单的小东西，被大家也已经用其他的方式写烂了（比如用localStorage做存储）。但是它作为一个完整的前后端的DEMO，我觉得让大家入门也相对更容易一些，能够体会到全栈开发也不是想象中的“那么难”（入门的难度还是可以接受的嘛）。有了Nodejs之后我们能够做的事真的好多！</p><p>当然，由于篇幅有限，本文能够讲述东西毕竟不够多，而且讲的东西也不可能面面俱到，很多东西都是点到即止，让大家能够自己发挥。其实还想讲讲<code>Event Bus</code>的简单使用，还有分页的基本实现等等，东西太多了，一时间大家消化不了。</p><p>实际上我在做前段时间的项目的时候，也是完全不知道怎么把Vue和Koa结合起来开发。我甚至不知道怎么用Koa来提供API，我只会用Koa来做服务端渲染，比如那些JADE\EJS等模板引擎渲染的页面。所以之前那个项目做完让我自己学到良多东西，故而也分享给大家。</p><p>实际上本文的Koa的api提供的形式也尽量和RESTful靠拢了，因此你也可以学会如何通过Koa提供RESTful形式的API了。</p><p>最后放上本文项目的Github<a href="https://github.com/Molunerfinn/vue-koa-demo" target="_blank" rel="noopener">地址</a>，如果这个项目对你有帮助，希望大家可以fork，给我提建议，如果再有时间，可以点个Star那就更好啦~</p><p>另外，本文的版本是用Koa1写成的。仓库已经更新Koa2。从Koa1-&gt;Koa2并没有什么难度，其实很关键的两点是：</p><ol><li>用<code>async await</code>替代<code>yield generation</code></li><li>用<code>koa2</code>的中间件替代<code>koa1</code>的中间件，原因同上一条</li></ol><p>互相学习，如果能从这个项目里学到东西我就很开心啦~</p><blockquote><p>注： 转载需经过同意，必须署名</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;本文从一名新手的角度（默认对Vue有了解，对Koa或者Express有了解）出发，从0开始构建一个数据通过Koa提供API的形式获取，页面通过Vue渲染的完整的前端项目。可以了解到Vue构建单页面的一些知识以及前端路由的使用、Koa如何提供API接口，如何进行访问过滤（路由）、验证（JSON-WEB-TOKEN）以及Sequelize操作MySQL数据库的一些知识和技巧，希望能够作为一篇入门全栈开发的文章吧。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;更新&lt;/strong&gt;：文末给出的github仓库已经更新Koa2版本。请使用Node.js v7.6.0及以上版本体验~&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="https://molunerfinn.com/categories/Web/"/>
    
      <category term="开发" scheme="https://molunerfinn.com/categories/Web/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Nodejs" scheme="https://molunerfinn.com/categories/Web/%E5%BC%80%E5%8F%91/Nodejs/"/>
    
    
      <category term="前端" scheme="https://molunerfinn.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Nodejs" scheme="https://molunerfinn.com/tags/Nodejs/"/>
    
  </entry>
  
  <entry>
    <title>【译】Having fun with Html5 Canvas</title>
    <link href="https://molunerfinn.com/gear-system/"/>
    <id>https://molunerfinn.com/gear-system/</id>
    <published>2017-04-09T15:11:00.000Z</published>
    <updated>2018-04-27T08:26:51.717Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文翻译自<a href="http://www.dorodnic.com/blog/2014/10/17/html5-canvas-part1" target="_blank" rel="noopener">Having fun with Html5 Canvas</a>，感谢作者</p></blockquote><p>本篇教程我们将会构建一个齿轮系统，用HTML canvas和JavaScript描述出来。</p><blockquote><p>本教程适合刚学习JavaScript以及对齿轮系统只有最基本了解的读者。</p></blockquote><a id="more"></a><h3 id="第一部分-渲染单个齿轮"><a href="#第一部分-渲染单个齿轮" class="headerlink" title="第一部分 渲染单个齿轮"></a>第一部分 渲染单个齿轮</h3><p>这个简单的物理齿轮制作<a href="http://www.instructables.com/id/How-to-make-gears-easily/step4/Working-out-the-size-of-everything/" target="_blank" rel="noopener">教程</a>是一个好的开端。根据这个教程，我们的齿轮将由它的半径和齿数来定义。</p><p>首先，让我们用齿轮的有关属性来创建一个齿轮类：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Gear = <span class="function"><span class="keyword">function</span>(<span class="params">x, y, connectionRadius, teeth, fillStyle, strokeStyle</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 齿轮参数</span></span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">    <span class="keyword">this</span>.connectionRadius = connectionRadius;</span><br><span class="line">    <span class="keyword">this</span>.teeth = teeth;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染参数</span></span><br><span class="line">    <span class="keyword">this</span>.fillStyle = fillStyle;</span><br><span class="line">    <span class="keyword">this</span>.strokeStyle = strokeStyle;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算属性</span></span><br><span class="line">    <span class="keyword">this</span>.diameter = teeth * <span class="number">4</span> * connectionRadius; <span class="comment">// 每个轮齿是通过两个相连的半圆组成的</span></span><br><span class="line">    <span class="keyword">this</span>.radius = <span class="keyword">this</span>.diameter / (<span class="number">2</span> * <span class="built_in">Math</span>.PI); <span class="comment">// D = 2 PI r</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 运动属性</span></span><br><span class="line">    <span class="keyword">this</span>.phi0 = <span class="number">0</span>; <span class="comment">// 起始角度</span></span><br><span class="line">    <span class="keyword">this</span>.angularSpeed = <span class="number">0</span>; <span class="comment">// 角速度cond</span></span><br><span class="line">    <span class="keyword">this</span>.createdAt = <span class="keyword">new</span> <span class="built_in">Date</span>(); <span class="comment">// 时间戳</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着写渲染的方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Gear.prototype.render = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 更新旋转角</span></span><br><span class="line">    <span class="keyword">var</span> ellapsed = <span class="keyword">new</span> <span class="built_in">Date</span>() - <span class="keyword">this</span>.createdAt;</span><br><span class="line">    <span class="keyword">var</span> phiDegrees = <span class="keyword">this</span>.angularSpeed * (ellapsed / <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">var</span> phi = <span class="keyword">this</span>.phi0 + deg2rad(phiDegrees); <span class="comment">// 当前的角度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建渲染参数</span></span><br><span class="line">    context.fillStyle = <span class="keyword">this</span>.fillStyle;</span><br><span class="line">    context.strokeStyle = <span class="keyword">this</span>.strokeStyle;</span><br><span class="line">    context.lineCap = <span class="string">'round'</span>;</span><br><span class="line">    context.lineWidth = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制齿轮轮身</span></span><br><span class="line">    context.beginPath();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.teeth * <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> alpha = <span class="number">2</span> * <span class="built_in">Math</span>.PI * (i / (<span class="keyword">this</span>.teeth * <span class="number">2</span>)) + phi;</span><br><span class="line">        <span class="comment">// 计算每个轮齿的位置</span></span><br><span class="line">        <span class="keyword">var</span> x = <span class="keyword">this</span>.x + <span class="built_in">Math</span>.cos(alpha) * <span class="keyword">this</span>.radius;</span><br><span class="line">        <span class="keyword">var</span> y = <span class="keyword">this</span>.y + <span class="built_in">Math</span>.sin(alpha) * <span class="keyword">this</span>.radius;</span><br><span class="line">        <span class="comment">// 画一个半圆，随着alpha旋转</span></span><br><span class="line">        <span class="comment">// 在每个奇数齿，画相反的半圆</span></span><br><span class="line">        context.arc(x, y, <span class="keyword">this</span>.connectionRadius, -<span class="built_in">Math</span>.PI / <span class="number">2</span> + alpha, <span class="built_in">Math</span>.PI / <span class="number">2</span> + alpha, i % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    context.fill();</span><br><span class="line">    context.stroke();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 画中心的圆</span></span><br><span class="line">    context.beginPath();</span><br><span class="line">    context.arc(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y, <span class="keyword">this</span>.connectionRadius, <span class="number">0</span>, <span class="number">2</span> * <span class="built_in">Math</span>.PI, <span class="literal">true</span>);</span><br><span class="line">    context.fill();</span><br><span class="line">    context.stroke();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> context = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line"><span class="keyword">var</span> W = canvas.width;</span><br><span class="line"><span class="keyword">var</span> H = canvas.height;</span><br><span class="line"><span class="keyword">var</span> gear = <span class="keyword">new</span> Gear(W / <span class="number">2</span>, H / <span class="number">2</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="string">"white"</span>, <span class="string">"rgba(61, 142, 198, 1)"</span>);</span><br><span class="line">gear.angularSpeed = <span class="number">36</span>;</span><br><span class="line">setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    canvas.width = canvas.width;</span><br><span class="line">    gear.render(context);</span><br><span class="line">&#125;, <span class="number">20</span>);</span><br></pre></td></tr></table></figure><p>以及HTML：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"myCanvas"</span> <span class="attr">width</span>=<span class="string">"200"</span> <span class="attr">height</span>=<span class="string">"200"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"myScript.js"</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p data-height="265" data-theme-id="0" data-slug-hash="PpgQBB" data-default-tab="result" data-user="molunerfinn" data-embed-version="2" data-pen-title="PpgQBB" data-preview="true" class="codepen">See the Pen <a href="http://codepen.io/molunerfinn/pen/PpgQBB/" target="_blank" rel="noopener">PpgQBB</a> by molunerfinn (<a href="http://codepen.io/molunerfinn" target="_blank" rel="noopener">@molunerfinn</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.</p><p></p><script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script><h3 id="第二部分-渲染两个啮合的齿轮"><a href="#第二部分-渲染两个啮合的齿轮" class="headerlink" title="第二部分 渲染两个啮合的齿轮"></a>第二部分 渲染两个啮合的齿轮</h3><p>我们的目的是让用户控制第二个齿轮的位置。同时我们想要保证齿轮仍然啮合并且同步转动。</p><p>下面是个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Gear.prototype.connect = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> r = <span class="keyword">this</span>.radius;</span><br><span class="line">    <span class="keyword">var</span> dist = distance(x, y, <span class="keyword">this</span>.x, <span class="keyword">this</span>.y); <span class="comment">// 计算两个齿轮之间的距离</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 要创建一个新的齿轮我们必须知道它的齿数</span></span><br><span class="line">    <span class="keyword">var</span> newRadius = <span class="built_in">Math</span>.max(dist - r, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">var</span> newDiam = newRadius * <span class="number">2</span> * <span class="built_in">Math</span>.PI;</span><br><span class="line">    <span class="keyword">var</span> newTeeth = <span class="built_in">Math</span>.round(newDiam / (<span class="number">4</span> * <span class="keyword">this</span>.connectionRadius)); <span class="comment">// 齿数必须是整数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个新的齿轮</span></span><br><span class="line">    <span class="keyword">var</span> newGear = <span class="keyword">new</span> Gear(x, y, <span class="keyword">this</span>.connectionRadius, newTeeth, <span class="keyword">this</span>.fillStyle, <span class="keyword">this</span>.strokeStyle);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整新齿轮的旋转方向使其与原来的方向相反</span></span><br><span class="line">    <span class="keyword">var</span> gearRatio = <span class="keyword">this</span>.teeth / newTeeth;</span><br><span class="line">    newGear.angularSpeed = -<span class="keyword">this</span>.angularSpeed * gearRatio;</span><br><span class="line">    <span class="keyword">return</span> newGear;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以把这个挂载在Canvas的<code>mousemove</code>的事件上。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gear2 = gear.connect(<span class="number">3</span> * (W / <span class="number">4</span>), H / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是一个辅助函数，用于转换鼠标在canvas内部的坐标值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMousePos</span>(<span class="params">canvas, evnt</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> rect = canvas.getBoundingClientRect();</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        x: evnt.clientX - rect.left,</span><br><span class="line">        y: evnt.clientY - rect.top</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">canvas.onmousemove = <span class="function"><span class="keyword">function</span> (<span class="params">evnt</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> pos = getMousePos(canvas, evnt);</span><br><span class="line">    <span class="keyword">var</span> x = <span class="built_in">Math</span>.min(<span class="number">0.7</span> * W, <span class="built_in">Math</span>.max(<span class="number">0.3</span> * W, pos.x));</span><br><span class="line">    <span class="keyword">var</span> y = <span class="built_in">Math</span>.min(<span class="number">0.7</span> * H, <span class="built_in">Math</span>.max(<span class="number">0.3</span> * H, pos.y));</span><br><span class="line">    gear2 = gear.connect(x, y);</span><br><span class="line">&#125;</span><br><span class="line">setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    canvas.width = canvas.width;</span><br><span class="line">    gear.render(context);</span><br><span class="line">    gear2.render(context);</span><br><span class="line">&#125;, <span class="number">20</span>);</span><br></pre></td></tr></table></figure><p></p><p data-height="381" data-theme-id="0" data-slug-hash="Mpdvwo" data-default-tab="result" data-user="molunerfinn" data-embed-version="2" data-pen-title="Mpdvwo" data-preview="true" class="codepen">See the Pen <a href="http://codepen.io/molunerfinn/pen/Mpdvwo/" target="_blank" rel="noopener">Mpdvwo</a> by molunerfinn (<a href="http://codepen.io/molunerfinn" target="_blank" rel="noopener">@molunerfinn</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.</p><p></p><script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script><p>上面的步骤可以实现正确的旋转方向，但是并不是那么准确——齿轮没有啮合，并且每个齿轮只是在做自己的运动。</p><p>以下是我们必须解决的两个问题：</p><ol><li><code>gear2.radius</code>（齿轮2的理论半径）与我们计算的<code>newRadius</code>（实际半径）不一致。这是因为我们不得不保留齿数的缘故。</li><li>齿轮2并没有和齿轮1同步转动。</li></ol><p>要解决第一个问题，我们必须让我们的新齿轮改变它的实际位置以确保在拥有它所需要的齿数的同时还能和第一个齿轮啮合。</p><p>（下面是对于问题1的解决方案）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Gear.prototype.connect = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> r = <span class="keyword">this</span>.radius;</span><br><span class="line">    <span class="keyword">var</span> dist = distance(x, y, <span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 要创建一个新的齿轮我们必须知道它的齿数</span></span><br><span class="line">    <span class="keyword">var</span> newRadius = <span class="built_in">Math</span>.max(dist - r, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">var</span> newDiam = newRadius * <span class="number">2</span> * <span class="built_in">Math</span>.PI;</span><br><span class="line">    <span class="keyword">var</span> newTeeth = <span class="built_in">Math</span>.round(newDiam / (<span class="number">4</span> * <span class="keyword">this</span>.connectionRadius));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算新齿轮的实际位置，使其能够于该齿轮啮合</span></span><br><span class="line">    <span class="keyword">var</span> actualDiameter = newTeeth * <span class="number">4</span> * <span class="keyword">this</span>.connectionRadius;</span><br><span class="line">    <span class="keyword">var</span> actualRadius = actualDiameter / (<span class="number">2</span> * <span class="built_in">Math</span>.PI);</span><br><span class="line">    <span class="keyword">var</span> actualDist = r + actualRadius; <span class="comment">// 距离该齿轮中心的实际距离</span></span><br><span class="line">    <span class="keyword">var</span> alpha = <span class="built_in">Math</span>.atan2(y - <span class="keyword">this</span>.y, x - <span class="keyword">this</span>.x); <span class="comment">// 该齿轮中心和(x,y)的角度值</span></span><br><span class="line">    <span class="keyword">var</span> actualX = <span class="keyword">this</span>.x + <span class="built_in">Math</span>.cos(alpha) * actualDist; </span><br><span class="line">    <span class="keyword">var</span> actualY = <span class="keyword">this</span>.y + <span class="built_in">Math</span>.sin(alpha) * actualDist;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个新的齿轮</span></span><br><span class="line">    <span class="keyword">var</span> newGear = <span class="keyword">new</span> Gear(actualX, actualY, <span class="keyword">this</span>.connectionRadius, newTeeth, <span class="keyword">this</span>.fillStyle, <span class="keyword">this</span>.strokeStyle);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整新齿轮的旋转方向使其与原来的方向相反</span></span><br><span class="line">    <span class="keyword">var</span> gearRatio = <span class="keyword">this</span>.teeth / newTeeth;</span><br><span class="line">    newGear.angularSpeed = -<span class="keyword">this</span>.angularSpeed * gearRatio;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newGear;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p data-height="389" data-theme-id="0" data-slug-hash="BWedRK" data-default-tab="result" data-user="molunerfinn" data-embed-version="2" data-pen-title="Gear-2-2" data-preview="true" class="codepen">See the Pen <a href="http://codepen.io/molunerfinn/pen/BWedRK/" target="_blank" rel="noopener">Gear-2-2</a> by molunerfinn (<a href="http://codepen.io/molunerfinn" target="_blank" rel="noopener">@molunerfinn</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.</p><p></p><script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script><p>上面的调整单独处理了一个令人讨厌的问题，我们可以在一个齿轮上放置另一个齿轮了。但是这还不足以同步两个齿轮的旋转。</p><p>现在我们必须在连接点使齿轮互相啮合：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.phi0 = alpha; <span class="comment">// 在时间t=0,将此齿轮旋转角度α</span></span><br><span class="line">newGear.phi0 = alpha + <span class="built_in">Math</span>.PI + (<span class="built_in">Math</span>.PI / newTeeth);</span><br><span class="line"><span class="comment">// 同时（t=0)，旋转新齿轮角度（180-α），对着第一个齿轮</span></span><br><span class="line"><span class="comment">// 并且加上一半的齿轮旋转使它们的轮齿能够啮合</span></span><br><span class="line">newGear.createdAt = <span class="keyword">this</span>.createdAt; <span class="comment">// 当然，还得同步它们的时钟</span></span><br></pre></td></tr></table></figure><p>上面的做法是有效的。然而，这种方法的缺点是我们在一直改变<code>this.phi</code>，这意味着以前与之同步的任何其他齿轮将不再同步。</p><p>每次<code>this.phi</code>都被一些<code>delta</code>更新，那么<code>newGear.phi</code>应该被更新多少？答案是<code>delta * (newGear.angularSpeed / this.angularSpeed)</code>，因为要考虑齿轮转速之比。了解到这个之后，我们可以把两个齿轮都更新一下：<code>delta = (this.phi0 - alpha)</code>，以消除这种影响：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在时间t=0,将此齿轮旋转角度α</span></span><br><span class="line"><span class="keyword">this</span>.phi0 = alpha + (<span class="keyword">this</span>.phi0 - alpha); <span class="comment">// this.phi0，没啥用，仅供展示。</span></span><br><span class="line">newGear.phi0 = alpha + <span class="built_in">Math</span>.PI + (<span class="built_in">Math</span>.PI / newTeeth) + (<span class="keyword">this</span>.phi0 - alpha) * (newGear.angularSpeed / <span class="keyword">this</span>.angularSpeed);</span><br><span class="line"><span class="comment">// 同时（t=0)，旋转新齿轮角度（180-α），对着第一个齿轮</span></span><br><span class="line"><span class="comment">// 并且加上一半的齿轮旋转使它们的轮齿能够啮合</span></span><br><span class="line">newGear.createdAt = <span class="keyword">this</span>.createdAt; <span class="comment">// 当然，还得同步它们的时钟</span></span><br></pre></td></tr></table></figure><p>通过这样的处理，<code>this.phi0</code>保持不变，不过另一个齿轮却得以同步：</p><p></p><p data-height="441" data-theme-id="0" data-slug-hash="GWavzq" data-default-tab="result" data-user="molunerfinn" data-embed-version="2" data-pen-title="Gear-2-3" data-preview="true" class="codepen">See the Pen <a href="http://codepen.io/molunerfinn/pen/GWavzq/" target="_blank" rel="noopener">Gear-2-3</a> by molunerfinn (<a href="http://codepen.io/molunerfinn" target="_blank" rel="noopener">@molunerfinn</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.</p><p></p><script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script><h3 id="第三部分-3D齿轮"><a href="#第三部分-3D齿轮" class="headerlink" title="第三部分 3D齿轮"></a>第三部分 3D齿轮</h3><p>在上一个部分，我们已经展示了如何通过HTML5 Canvas渲染出啮合的齿轮对。本部分，我们将会探索通过使用Three.js这个库，渲染出完全3D的JavaScript齿轮，同时也会进一步扩大视图的复杂性。</p><h4 id="3D渲染"><a href="#3D渲染" class="headerlink" title="3D渲染"></a>3D渲染</h4><p>Three.js是一个用于3D图形渲染的JavaScript库，是基于WebGL的。它是免费，开放，并且不断更新的。我们将从移植我们的渲染代码开始，首先试着描绘出2D平面里的齿轮轮廓。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shape = <span class="keyword">new</span> THREE.Shape();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳转到齿轮顶部的起始位置</span></span><br><span class="line"><span class="keyword">var</span> x0 = <span class="keyword">this</span>.radius;</span><br><span class="line"><span class="keyword">var</span> y0 = <span class="number">0</span>;</span><br><span class="line">shape.moveTo(x0, y0);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.legs * <span class="number">2</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> alpha = <span class="number">2</span> * <span class="built_in">Math</span>.PI * (i / (<span class="keyword">this</span>.legs * <span class="number">2</span>)) + <span class="keyword">this</span>.phi;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="built_in">Math</span>.cos(alpha) * <span class="keyword">this</span>.radius;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="built_in">Math</span>.sin(alpha) * <span class="keyword">this</span>.radius;</span><br><span class="line"></span><br><span class="line">    createArc(shape, x, y, <span class="keyword">this</span>.connectionRadius,</span><br><span class="line">        -<span class="built_in">Math</span>.PI / <span class="number">2</span> + alpha,  <span class="comment">// 起始角度 </span></span><br><span class="line">        <span class="built_in">Math</span>.PI / <span class="number">2</span> + alpha, <span class="comment">// 结束角度</span></span><br><span class="line">        i % <span class="number">2</span> == <span class="number">0</span>, <span class="comment">// 顺时针还是逆时针</span></span><br><span class="line">        <span class="number">3</span> <span class="comment">// 每段弧的离散段数</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> shape;</span><br></pre></td></tr></table></figure><p>我用了一个辅助函数把弧形段分割成离散的段：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createArc</span>(<span class="params">shape, x, y, radius, from, to, sign, parts</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> src = sign ? <span class="keyword">from</span> : to; <span class="comment">// 确保我们总是沿着一个方向移动</span></span><br><span class="line">    <span class="keyword">var</span> trg = sign ? to : <span class="keyword">from</span>;</span><br><span class="line">    <span class="keyword">var</span> delta = sign ? <span class="number">0</span> : <span class="built_in">Math</span>.PI; <span class="comment">// 但在需要的时候可以反转角度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; parts; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> t = i / parts;</span><br><span class="line">        <span class="keyword">var</span> cx = x + radius * <span class="built_in">Math</span>.cos(delta + (src * (<span class="number">1</span> - t) + trg * t));</span><br><span class="line">        <span class="keyword">var</span> cy = y + radius * <span class="built_in">Math</span>.sin(delta + (src * (<span class="number">1</span> - t) + trg * t));</span><br><span class="line">        shape.lineTo(cx, cy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当前的代码里有一个问题——啮合的齿轮会从一个小角度phi开始旋转，而不是恰好在<code>(r,0)</code>。要正确地获取<code>(x0,y0)</code>需要进行以下调整：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sign = <span class="keyword">this</span>.legs % <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="keyword">from</span> = -<span class="built_in">Math</span>.PI / <span class="number">2</span> + <span class="keyword">this</span>.phi;</span><br><span class="line"><span class="keyword">var</span> to = <span class="built_in">Math</span>.PI / <span class="number">2</span> + <span class="keyword">this</span>.phi;</span><br><span class="line"><span class="keyword">var</span> src = sign ? <span class="keyword">from</span> : to;</span><br><span class="line"><span class="keyword">var</span> trg = sign ? to : <span class="keyword">from</span>;</span><br><span class="line"><span class="keyword">var</span> delta = sign ? <span class="number">0</span> : <span class="built_in">Math</span>.PI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x0 = <span class="built_in">Math</span>.cos(<span class="keyword">this</span>.phi)*<span class="keyword">this</span>.radius + <span class="keyword">this</span>.connectionRadius*<span class="built_in">Math</span>.cos(delta + src);</span><br><span class="line"><span class="keyword">var</span> y0 = <span class="built_in">Math</span>.sin(<span class="keyword">this</span>.phi)*<span class="keyword">this</span>.radius + <span class="keyword">this</span>.connectionRadius*<span class="built_in">Math</span>.sin(delta + src);</span><br></pre></td></tr></table></figure><p>现在，让我们增加一些代码来渲染齿轮中心的孔：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> holePath = <span class="keyword">new</span> THREE.Path();</span><br><span class="line">holePath.moveTo(<span class="keyword">this</span>.connectionRadius, <span class="number">0</span>);</span><br><span class="line">createArc(holePath, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">this</span>.connectionRadius, <span class="number">0</span>, <span class="number">2</span> * <span class="built_in">Math</span>.PI, <span class="literal">true</span>, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">this</span>.shape.holes.push(holePath);</span><br></pre></td></tr></table></figure><p>一旦我们齿轮的轮廓被描绘，我们可以使用Three.js的拉伸功能使其变得更加真实起来：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> extrudeSettings = &#123;</span><br><span class="line">    steps: <span class="number">1</span>,</span><br><span class="line">    amount: gearDepth,</span><br><span class="line">    bevelEnabled: <span class="literal">false</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.ExtrudeGeometry(shape, extrudeSettings);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> THREE.MeshPhongMaterial(&#123;</span><br><span class="line">    color: color,</span><br><span class="line">    polygonOffset: <span class="literal">true</span>,</span><br><span class="line">    polygonOffsetFactor: <span class="number">1.0</span>,</span><br><span class="line">    polygonOffsetUnits: <span class="number">4.0</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mesh = <span class="keyword">new</span> THREE.Mesh(geometry, material);</span><br><span class="line">scene.add(mesh);</span><br></pre></td></tr></table></figure><p>这里是结果：</p><p></p><p data-height="374" data-theme-id="0" data-slug-hash="oZrExv" data-default-tab="result" data-user="molunerfinn" data-embed-version="2" data-pen-title="Gear-3-1" data-preview="true" class="codepen">See the Pen <a href="http://codepen.io/molunerfinn/pen/oZrExv/" target="_blank" rel="noopener">Gear-3-1</a> by molunerfinn (<a href="http://codepen.io/molunerfinn" target="_blank" rel="noopener">@molunerfinn</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.</p><p></p><script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script><h4 id="生成更复杂的场景"><a href="#生成更复杂的场景" class="headerlink" title="生成更复杂的场景"></a>生成更复杂的场景</h4><p>使用第二部分的代码我们可以生成一对互相啮合的齿轮，为了生成更复杂的场景，只要我们避免碰撞，可以一次添加一个齿轮。</p><p>这个能够生成我们的齿轮啮合网络的方法应该是这样的：</p><ol><li>放置随机的齿轮</li><li>找到不被任何其他齿轮占用的随机点p = (x,y)</li><li>找到最接近的齿轮g</li><li>创建一个新的齿轮中心点在p并且与g相连</li><li>回到第二步</li></ol><p>使用这个方法你可以生成互相啮合的齿轮的整个网络，如下所示：</p><p></p><p data-height="444" data-theme-id="0" data-slug-hash="GWbbpO" data-default-tab="result" data-user="molunerfinn" data-embed-version="2" data-pen-title="GWbbpO" data-preview="true" class="codepen">See the Pen <a href="http://codepen.io/molunerfinn/pen/GWbbpO/" target="_blank" rel="noopener">GWbbpO</a> by molunerfinn (<a href="http://codepen.io/molunerfinn" target="_blank" rel="noopener">@molunerfinn</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.</p><p></p><script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script><p>以下是冲突检测查询的一个可能的实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">detectCollision</span>(<span class="params">newGear, neighbor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">this</span>.gears.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">gear</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> dist = distance(gear.x, gear.y, newGear.x, newGear.y);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dist &lt; gear.radius + newGear.radius + <span class="number">2</span> * that.connectionRadius + <span class="number">5</span> </span><br><span class="line">            &amp;&amp; neighbor != gear) &#123;</span><br><span class="line">            result = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用类似的方法实现冲突的近邻查询。但是你应该注意一个细节，那就是我们必须避免大齿轮以很大的角速度旋转。否则一些齿轮在动画的帧与帧之间转动得太多，将会形成混乱的情况。</p><p>下一个逻辑步骤就是增加我们模型的深度。我们可以随机放置几层，但是这样会让它们看起来不自然。这些层可以通过一些共同的转轴来进行交互。我们可以通过从一层到另一层复制圆点和角速度来模拟这种效果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tryAddFromLayer</span>(<span class="params">x, y, legs, angularSpeed</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 通过所给的参数创建一个新的齿轮</span></span><br><span class="line">    <span class="keyword">var</span> newGear = <span class="keyword">new</span> Gear(x, y, <span class="keyword">this</span>.connectionRadius, </span><br><span class="line">                           legs, <span class="keyword">this</span>.fillStyle, <span class="keyword">this</span>.strokeStyle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.detectCollision(newGear, <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// 别忘了确保它不会转的太快</span></span><br><span class="line">        &amp;&amp; <span class="keyword">this</span>.minFps * angularSpeed * newGear.radius &lt; newGear.diameter</span><br><span class="line">        ) &#123;</span><br><span class="line">        newGear.angularSpeed = angularSpeed; <span class="comment">// 调整转速</span></span><br><span class="line">        <span class="keyword">this</span>.gears.push(newGear); <span class="comment">// 添加到图层</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们能够堆积从以前生成的层中挑选齿轮，并从中生成新的齿轮：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addFromLayer</span>(<span class="params">layers, options, maxR</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> retries = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>.gears.length &lt; options.maxGears &amp;&amp; retries &lt; options.qouta) &#123;</span><br><span class="line">        <span class="comment">// 选择一个随机的层</span></span><br><span class="line">        <span class="keyword">var</span> layerIdx = <span class="built_in">Math</span>.floor((options.generator.random() * layers.length));</span><br><span class="line">        <span class="keyword">var</span> layer = layers[layerIdx];</span><br><span class="line">        <span class="comment">// 从这个层里挑选一个随机的齿轮</span></span><br><span class="line">        <span class="keyword">var</span> gearIdx = <span class="built_in">Math</span>.floor((options.generator.random() * layer.gears.length));</span><br><span class="line">        <span class="keyword">var</span> gear = layer.gears[gearIdx];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 随机选择这个齿轮的齿数</span></span><br><span class="line">        <span class="keyword">var</span> legs = options.minLegs + <span class="built_in">Math</span>.floor((options.generator.random() *</span><br><span class="line">            (maxLegsFromRadius(maxR, <span class="keyword">this</span>.connectionRadius) - options.minLegs)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向当前的图层里添加结果</span></span><br><span class="line">        <span class="keyword">this</span>.tryAddFromLayer(gear.x, gear.y, legs, gear.angularSpeed);</span><br><span class="line"></span><br><span class="line">        retries++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是算法的一个可能的输出：</p><p></p><p data-height="566" data-theme-id="0" data-slug-hash="dvBBZz" data-default-tab="result" data-user="molunerfinn" data-embed-version="2" data-pen-title="dvBBZz" data-preview="true" class="codepen">See the Pen <a href="http://codepen.io/molunerfinn/pen/dvBBZz/" target="_blank" rel="noopener">dvBBZz</a> by molunerfinn (<a href="http://codepen.io/molunerfinn" target="_blank" rel="noopener">@molunerfinn</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.</p><p></p><script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script><p>所有的源码你都可以通过查看上面的<code>codepen</code>的源码以及github<a href="https://github.com/Molunerfinn/Gear-system" target="_blank" rel="noopener">仓库源码</a>获取</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;本文翻译自&lt;a href=&quot;http://www.dorodnic.com/blog/2014/10/17/html5-canvas-part1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Having fun with Html5 Canvas&lt;/a&gt;，感谢作者&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;本篇教程我们将会构建一个齿轮系统，用HTML canvas和JavaScript描述出来。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;本教程适合刚学习JavaScript以及对齿轮系统只有最基本了解的读者。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Web" scheme="https://molunerfinn.com/categories/Web/"/>
    
      <category term="开发" scheme="https://molunerfinn.com/categories/Web/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="前端" scheme="https://molunerfinn.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
</feed>
